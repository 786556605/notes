### **Chapter 10. Signals**

### Introduction

Signals are software interrupts. They provide a way of handling asynchronous events. Most nontrivial application programs need to deal with signals.

#### POSIX reliable signals

Signals have been provided since the early versions of the UNIX System, but the signal model provided with systems such as Version 7 was not reliable. Signals could get lost, and it was difficult for a process to turn off selected signals when executing critical regions of code. Both 4.3BSD and SVR3 made changes to the signal model, adding what are called **reliable signals**. But the changes made by Berkeley and AT&T were incompatible. Fortunately, POSIX.1 standardized the reliable-signal routines, and that is what we describe here.

This chapter starts with an overview of signals and a description of what each signal is normally used for, then discusses problems with earlier implementations, since it is often important to understand what is wrong with an implementation before seeing how to do things correctly. This chapter contains numerous examples that are not entirely correct and a discussion of the defects.

### Signal Concepts

* Every signal has a name. They all begin with the three characters `SIG`. For example:
    * `SIGABRT` is the abort signal that is generated when a process calls the `abort` function.
    * `SIGALRM` is the alarm signal that is generated when the timer set by the `alarm` function goes off.
    * FreeBSD 8.0 supports 32 different signals. Mac OS X 10.6.8 and Linux 3.2.0 each support 31 different signals, whereas Solaris 10 supports 40 different signals. FreeBSD, Linux, and Solaris, support additional application-defined signals introduced to support **real-time applications**.
* Signal names are all defined by positive integer constants (the signal number) in the header `<signal.h>`.
    * Implementations actually define the individual signals in a different header file, but this header file is included by `<signal.h>`.
    * It bad for the kernel to include header files meant for user-level applications, so if the applications and the kernel both need the same definitions, the information is placed in a kernel header file that is then included by the user-level header file.
        * `<sys/signal.h>`: FreeBSD 8.0 and Mac OS X 10.6.8
        * `<bits/signum.h>`: Linux 3.2.0
        * `<sys/iso/signal_iso.h>`: Solaris 10
* No signal has a signal number of 0. The `kill` function uses the signal number of 0 for a special case. POSIX.1 calls this value the null signal.
* Numerous conditions can generate a signal:
    * The terminal-generated signals occur when users press certain terminal keys. Pressing the DELETE key or Control-C on the terminal normally causes the interrupt signal (`SIGINT`) to be generated.
    * Hardware exceptions generate signals. For example, divide by 0 and invalid memory reference. These conditions are usually detected by the hardware, and the kernel is notified. The kernel then generates the appropriate signal for the process that was running at the time the condition occurred. For example, `SIGSEGV` is generated for a process that executes an invalid memory reference.
    * The `kill(2)` function allows a process to send any signal to another process or process group, with limitations: we have to be the owner of the process that we’re sending the signal to, or we have to be the superuser.
    * The `kill(1)` command allows us to send signals to other processes. This program is just an interface to the `kill` function. This command is often used to terminate a runaway background process.
    * Software conditions can generate signals when a process should be notified of various events. For example:
        * `SIGURG`: generated when out-of-band data arrives over a network connection),
        * `SIGPIPE`: generated when a process writes to a pipe that has no reader)
        * `SIGALRM`: generated when an alarm clock set by the process expires).

Signals are classic examples of asynchronous events. They occur at random times to the process. The process can’t simply test a variable (such as `errno`) to see whether a signal has occurred; instead, the process has to tell the kernel "if and when this signal occurs, do the following".

#### Signal dispositions

We can tell the kernel to do one of three things when a signal occurs. This is called the **disposition of the signal**, or the **action associated with a signal**. ([`signal(7)`](http://man7.org/linux/man-pages/man7/signal.7.html))

1. **Ignore the signal**. Most signals can be ignored, but two signals can never be ignored: `SIGKILL` and `SIGSTOP`.
    * The reason these two signals can’t be ignored is to provide the kernel and the superuser with a surefire way of either killing or stopping any process.
    * If we ignore some of the signals that are generated by a hardware exception (such as illegal memory reference or divide by 0), the behavior of the process is undefined.
2. **Catch the signal**. To do this, we tell the kernel to call a function of ours whenever the signal occurs. In our function, we can do whatever we want to handle the condition. For example:
    * If we’re writing a command interpreter, when the user generates the interrupt signal at the keyboard, we probably want to return to the main loop of the program, terminating whatever command we were executing for the user.
    * If the `SIGCHLD` signal is caught, it means that a child process has terminated, so the signal-catching function can call `waitpid` to fetch the child’s process ID and termination status.
    * If the process has created temporary files, we may want to write a signal-catching function for the SIGTERM signal (the termination signal that is the default signal sent by the kill command) to clean up the temporary files.
    * Note that the two signals `SIGKILL` and `SIGSTOP` can’t be caught.
3. **Let the default action apply**. Every signal has a default action. The default action for most signals is to terminate the process.

The signals `SIGKILL` and `SIGSTOP` cannot be caught, blocked, or ignored. ([`signal(7)`](http://man7.org/linux/man-pages/man7/signal.7.html))

#### UNIX System signals

The following table lists the names of all the signals, an indication of which systems support the signal, and the default action for the signal. The SUS column contains "x" if the signal is defined as part of the base POSIX.1 specification and XSI if it is defined as part of the XSI option. The supported systems are FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 and Solaris 10.

Name |  Description | ISO C	|	SUS	|	FreeBSD |	Linux |	Mac OS X |	Solaris |	Default action
---- | ------------ | ----- | --- | ------- | ----- | -------- | -------- | --------------
`SIGABRT`	|	abnormal termination (`abort`)	|	x	|	x	|	x	|	x	|	x	|	x	|	terminate+core
`SIGALRM`	|	timer expired (`alarm`)	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGBUS`	|	hardware fault	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate+core
`SIGCANCEL`	|	threads library internal use	|	 	|	 	|	 	|	 	|	 	|	x	|	ignore
`SIGCHLD`	|	change in status of child	|	 	|	x	|	x	|	x	|	x	|	x	|	ignore
`SIGCONT`	|	continue stopped process	|	 	|	x	|	x	|	x	|	x	|	x	|	continue/ignore
`SIGEMT`	|	hardware fault	|	 	|	 	|	x	|	x	|	x	|	x	|	terminate+core
`SIGFPE`	|	arithmetic exception	|	x	|	x	|	x	|	x	|	x	|	x	|	terminate+core
`SIGFREEZE`	|	checkpoint freeze	|	 	|	 	|	 	|	 	|	 	|	x	|	ignore
`SIGHUP`	|	hangup	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGILL`	|	illegal instruction	|	x	|	x	|	x	|	x	|	x	|	x	|	terminate+core
`SIGINFO`	|	status request from keyboard	|	 	|	 	|	x	|	 	|	x	|	 	|	ignore
`SIGINT`	|	terminal interrupt character	|	x	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGIO`	|	asynchronous I/O	|	 	|	 	|	x	|	x	|	x	|	x	|	terminate/ignore
`SIGIOT`	|	hardware fault	|	 	|	 	|	x	|	x	|	x	|	x	|	terminate+core
`SIGJVM1` | Java virtual machine internal use	|	 	|	 	|		|		|		|	x	|	ignore
`SIGJVM2` | Java virtual machine internal use	|	 	|	 	|		|		|		|	x	|	ignore
`SIGKILL`	|	termination	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGLWP`	|	threads library internal use	|	 	|	 	|	x	|	 	|	 	|	x	|	ignore
`SIGPIPE`	|	write to pipe with no readers	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGPOLL`	|	pollable event (`poll`)	|	 	|	  |	 	|	x	|	 	|	x	|	terminate
`SIGPROF`	|	profiling time alarm (`setitimer`)	|	 	|	  |	x	|	x	|	x	|	x	|	terminate
`SIGPWR`	|	power fail/restart	|	 	|	 	|	 	|	x	|	 	|	x	|	terminate/ignore
`SIGQUIT`	|	terminal quit character	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate+core
`SIGSEGV`	|	invalid memory reference	|	x	|	x	|	x	|	x	|	x	|	x	|	terminate+core
`SIGSTKFLT`	|	coprocessor stack fault	|	 	|	 	|	 	|	x	|	 	|	 	|	terminate
`SIGSTOP`	|	stop	|	 	|	x	|	x	|	x	|	x	|	x	|	stop process
`SIGSYS`	|	invalid system call	|	 	|	XSI	|	x	|	x	|	x	|	x	|	terminate+core
`SIGTERM`	|	termination	|	x	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGTHAW`	|	checkpoint thaw	|	 	|	 	|	 	|	 	|	 	|	x	|	ignore
`SIGTHR` | threads library internal use |	 	|	 	|	x	|	 	|	 	|	x	|	terminate
`SIGTRAP`	|	hardware fault	|	 	|	XSI	|	x	|	x	|	x	|	x	|	terminate+core
`SIGTSTP`	|	terminal stop character	|	 	|	x	|	x	|	x	|	x	|	x	|	stop process
`SIGTTIN`	|	background read from control tty	|	 	|	x	|	x	|	x	|	x	|	x	|	stop process
`SIGTTOU`	|	background write to control tty	|	 	|	x	|	x	|	x	|	x	|	x	|	stop process
`SIGURG`	|	urgent condition (sockets)	|	 	|	x	|	x	|	x	|	x	|	x	|	ignore
`SIGUSR1`	|	user-defined signal	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGUSR2`	|	user-defined signal	|	 	|	x	|	x	|	x	|	x	|	x	|	terminate
`SIGVTALRM`	|	virtual time alarm (`setitimer`)	|	 	|	XSI	|	x	|	x	|	x	|	x	|	terminate
`SIGWAITING`	|	threads library internal use	|	 	|	 	|	 	|	 	|	 	|	x	|	ignore
`SIGWINCH`	|	terminal window size change	|	 	|	 	|	x	|	x	|	x	|	x	|	ignore
`SIGXCPU`	|	CPU limit exceeded (`setrlimit`)	|	 	|	XSI	|	x	|	x	|	x	|	x	|	terminate+core/ignore
`SIGXFSZ`	|	file size limit exceeded (`setrlimit`)	|	 	|	XSI	|	x	|	x	|	x	|	x	|	terminate+core/ignore
`SIGXRES`	|	resource control exceeded	|	 	|	 	|	 	|	 	|	 	|	x	|	ignore

#### The core file

When the default action (in the table above) is labeled "terminate+core", it means that a memory image of the process is left in the file named `core` of the current working directory of the process. This file can be used with most UNIX System debuggers to examine the state of the process at the time it terminated.

The name of the `core` file varies among implementations.  On Mac OS X 10.6.8, the core file is named core.*pid*, where *pid* is the ID of the process that received the signal. On Linux 3.2.0, the name is configured through `/proc/sys/kernel/core_pattern`. ([`core(5)`](http://man7.org/linux/man-pages/man5/core.5.html)) [p315]

Most implementations leave the core file in the current working directory of the corresponding process; Mac OS X places all core files in `/cores` instead.

The core file will not be generated if:

* the process was set-user-ID and the current user is not the owner of the program file,
* the process was set-group-ID and the current user is not the group owner of the file,
* the user does not have permission to write in the current working directory,
* the file already exists and the user does not have permission to write to it,
* the file is too big (see `RLIMIT_CORE` limit in [Section 7.11](/apue/ch7/#getrlimit-and-setrlimit-functions))

The permissions of the core file (assuming that the file doesn’t already exist) are usually user-read and user-write, although Mac OS X sets only user-read.

In the table, the signals with a description of "hardware fault" correspond to implementation-defined hardware faults.

#### Detailed description of signals

* `SIGABRT`: generated by calling the `abort` function.  The process terminates abnormally.
* `SIGALRM`:
    * This signal is generated when a timer set with the `alarm` function expires.
    * This signal is also generated when an interval timer set by the `setitimer(2)` function expires.
