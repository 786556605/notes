### **Chapter 12. Memory Management**

Unlike user-space, the kernel is not always afforded the capability to easily allocate memory. This chapter discusses how the kernel handles memory and the methods used to obtain memory inside the kernel.

### Page

To kernel, physical pages are the basic unit of memory management. Although the processor’s smallest addressable unit is a byte or a word, the [memory management unit](https://en.wikipedia.org/wiki/Memory_management_unit) (MMU, the hardware that manages memory and performs virtual to physical address translations) typically deals in pages. Therefore, the MMU maintains the system’s page tables with page-sized granularity. In terms of virtual memory, pages are the smallest unit.

Each architecture defines its own page size. Many architectures even support multiple page sizes.

* Most 32-bit architectures have 4KB pages;
* Most 64-bit architectures have 8KB pages.

This implies that on a machine with 4KB pages and 1GB of memory, physical memory is divided into 262,144 distinct pages.

The kernel represents every physical page on the system with a `struct page` structure.  This structure is defined in `<linux/mm_types.h>` ([include/linux/mm_types.h](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mm_types.h)). The following is a simplified the definition (two confusing unions are removed):

<small>[include/linux/mm_types.h#L34](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mm_types.h#L34)</small>

```c
struct page {
    unsigned long flags;
    atomic_t _count;
    atomic_t _mapcount;
    unsigned long private;
    struct address_space *mapping;
    pgoff_t index;
    struct list_head lru;
    void *virtual;
};
```

* The `flags` field stores the status of the page, such as whether the page is dirty or whether it is locked in memory. Bit flags represent the various values, so at least 32 different flags are simultaneously available. The flag values are defined in `<linux/page-flags.h>` ([include/linux/page-flags.h](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/page-flags.h)).
* The `_count` field stores the usage count of the page: how many references there are to this page.
    * If `_count`'s value is negative one (-1) indicates that no one is using the page, and it becomes available for use in a new allocation.
    * Kernel code should not check this field directly but instead use the function `page_count()`, which takes a page structure as its sole parameter. `page_count()` returns zero to indicate free and a positive nonzero integer when the page is in use.
    * A page may be used by the page cache (in which case the `mapping` field points to the `address_space` object associated with this page), as private data (pointed at by `private`), or as a mapping in a process’s page table.
* The `virtual` field is the page’s virtual address. Normally, this is simply the address of the page in virtual memory.
    * Some memory (called high memory) is not permanently mapped in the kernel’s address space. In that case, this field is `NULL`, and the page must be dynamically mapped if needed.

The `page` structure is associated with physical pages, not virtual pages; what the structure describes is transient at best. Even if the data contained in the page continues to exist, it might not always be associated with the same `page` structure because of swapping and so on. <u>The kernel uses this data structure to describe the associated physical page. The data structure’s goal is to describe physical memory, not the data contained therein.</u>

The kernel uses this structure to keep track of all the pages in the system, because the kernel needs to know whether a page is free (whether the page is not allocated). If a page is not free, the kernel needs to know who owns the page. Possible owners include (but not limited to):

* User-space processes,
* Dynamically allocated kernel data,
* Static kernel code,
* Page cache.

Since an instance of this structure is allocated for each physical page in the system. How bad (or good) the space consumption is from all these pages?  Assume `struct page` consumes 40 bytes of memory, the system has 8KB physical pages, and the system has 4GB of physical memory. In that case, there are about 524,288 pages and page structures on the system. The page structures consume 20MB: perhaps a surprisingly large number in absolute terms, but only a small fraction of a percent relative to the system’s 4GB. This is not too high a cost for managing all the system’s physical pages.

### Zones

The kernel cannot treat all pages as identical due to hardware limitations. Some pages, because of their physical address in memory, cannot be used for certain tasks. Thus, the kernel divides pages into different *zones*. The kernel uses the zones to group pages of similar properties.

Linux has to deal with two shortcomings of hardware with respect to memory addressing:

* Some hardware devices can perform [DMA](https://en.wikipedia.org/wiki/Direct_memory_access) (direct memory access) to only certain memory addresses.
* Some architectures can physically addressing larger amounts of memory than they can virtually address. Consequently, some memory is not permanently mapped into the kernel address space.

Due to these contraints, Linux has four primary memory zones:

* `ZONE_DMA`. This zone contains pages that can undergo DMA.
* `ZONE_DMA32`. Like ZOME_DMA, this zone contains pages that can undergo DMA. Unlike `ZONE_DMA`, these pages are accessible only by 32-bit devices. On some architectures, this zone is a larger subset of memory.
* `ZONE_NORMAL`. This zone contains normal, regularly mapped, pages.
* `ZONE_HIGHMEM`. This zone contains "high memory", which are pages not permanently mapped into the kernel’s address space.

These zones are defined in `<linux/mmzone.h>` ([include/linux/mmzone.h](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mmzone.h))

The layout of the memory zones is architecture-dependent. For example:

* Some architectures can perform DMA into any memory address. In those architectures, `ZONE_DMA` is empty and `ZONE_NORMAL` is used for allocations regardless of their use.
* On the x86 architecture, [ISA](https://en.wikipedia.org/wiki/Industry_Standard_Architecture) devices cannot perform DMA into the full 32-bit address space1 because ISA devices can access only the first 16MB of physical memory. Consequently, `ZONE_DMA` on x86 consists of all memory in the range 0MB–16MB.

`ZONE_HIGHMEM` works similarly. On 32-bit x86 systems, `ZONE_HIGHMEM` is all memory above the physical 896MB mark. On other architectures, `ZONE_HIGHMEM` is empty because all memory is directly mapped. The memory contained in `ZONE_HIGHMEM` is called **high memory**. The rest of the system’s memory is called **low memory**.

`ZONE_NORMAL` is the remainder after the previous two zones claim their requisite shares. On x86, `ZONE_NORMAL` is all physical memory from 16MB to 896MB. On other architectures, `ZONE_NORMAL` is all available memory.

The following table is a listing of each zone and its consumed pages on x86-32.

Zone | Description | Physical Memory
---- | ----------- | ---------------
`ZONE_DMA` | DMA-able pages | < 16MB
`ZONE_NORMAL` | Normally addressable pages | 16–896MB
`ZONE_HIGHMEM` | Dynamically mapped pages | > 896MB

Linux partitions pages into zones to have a pooling in place to satisfy allocations as needed. For example, with a `ZONE_DMA` pool, the kernel has the capability to satisfy memory allocations needed for DMA. If such memory is needed, the kernel can simply pull the required number of pages from `ZONE_DMA`. The zones do not have any physical relevance but are simply logical groupings used by the kernel to keep track of pages.

Although some allocations may require pages from a particular zone, other allocations may pull from multiple zones. For example:

* An allocation for DMA-able memory must originate from `ZONE_DMA`
* A normal allocation can come from `ZONE_DMA` or `ZONE_NORMAL` but not both; allocations cannot cross zone boundaries. The kernel prefers to satisfy normal allocations from the normal zone to save the pages in `ZONE_DMA` for allocations that need it. [p234]

Not all architectures define all zones. For example, a 64-bit architecture such as Intel’s x86-64 can fully map and handle 64-bits of memory.Thus, x86-64 has no `ZONE_HIGHMEM` and all physical memory is contained within `ZONE_DMA` and `ZONE_NORMAL`.

Each zone is represented by struct zone, which is defined in `<linux/mmzone.h>`:

<small>[include/linux/mmzone.h#L280](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mmzone.h#L280)</small>

```c
struct zone {
    unsigned long watermark[NR_WMARK];
    unsigned long lowmem_reserve[MAX_NR_ZONES];
    struct per_cpu_pageset pageset[NR_CPUS];
    spinlock_t lock;
    struct free_area free_area[MAX_ORDER]
    spinlock_t lru_lock;
    struct zone_lru {
        struct list_head list;
        unsigned long nr_saved_scan;
    } lru[NR_LRU_LISTS];
    struct zone_reclaim_stat reclaim_stat;
    unsigned long pages_scanned;
    unsigned long flags;
    atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
    int prev_priority;
    unsigned int inactive_ratio;
    wait_queue_head_t *wait_table;
    unsigned long wait_table_hash_nr_entries;
    unsigned long wait_table_bits;
    struct pglist_data *zone_pgdat;
    unsigned long zone_start_pfn;
    unsigned long spanned_pages;
    unsigned long present_pages;
    const char *name;
};
```


* The `lock` field is a spin lock that protects the structure from concurrent access. It protects just the structure and not all the pages that reside in the zone. A specific lock does not protect individual pages, although parts of the kernel may lock the data that happens to reside in said pages.
* The `watermark` array holds the minimum, low, and high watermarks for this zone. The kernel uses watermarks to set benchmarks for suitable per-zone memory consumption. [p235]
* The `name` field is a NULL-terminated string representing the name of this zone. The kernel initializes this value during boot in [mm/page_alloc.c](https://github.com/shichao-an/linux/blob/v2.6.34/mm/page_alloc.c), and the three zones are given the names DMA, Normal, and HighMem.

### Getting Pages

This section discusses the interfaces the kernel implements to enable you to allocate and free memory within the kernel.

The kernel provides one low-level mechanism for requesting memory, along with several interfaces to access it. All these interfaces allocate memory with page-sized granularity and are declared in `<linux/gfp.h>` ([include/linux/gfp.h](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/gfp.h)). The core function is:

```c
struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)
```

This allocates 2<sup>order</sup> (`1 << order`) contiguous physical pages and returns a pointer to the first page’s `page` structure; on error it returns `NULL`.

You can convert a given page to its logical address with the function:

```c
void * page_address(struct page *page)
```

This returns a pointer to the logical address where the given physical page currently resides.

If you have no need for the actual `struct page`, you can call:

```c
unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)
```

This function works the same as `alloc_pages()`, except that it directly returns the logical address of the first requested page. Because the pages are contiguous, the other pages simply follow from the first.

If you need only one page, two functions are implemented as wrappers to save you a bit of typing:

```c
struct page * alloc_page(gfp_t gfp_mask)
unsigned long __get_free_page(gfp_t gfp_mask)
```

These functions work the same but pass zero for the order (2<sup>0</sup> = one page).

#### Getting Zeroed Pages

If you need the returned page filled with zeros, use the function:

```c
unsigned long get_zeroed_page(unsigned int gfp_mask)
```

This function works the same as `__get_free_page()`, except that the allocated page is then zero-filled (every bit of every byte is unset). This is useful for pages given to userspace because the random garbage in an allocated page is not so random; it might contain sensitive data. All data must be zeroed or otherwise cleaned before it is returned to userspace to ensure system security is not compromised.

The following table is a listing of all the low-level page allocation methods.

Flag | Description
---- | -----------
`alloc_page(gfp_mask)` | Allocates a single page and returns a pointer to its first page’s `page` structure
`alloc_pages(gfp_mask, order)` | Allocates 2<sup>order</sup> pages and returns a pointer to the first page’s `page` structure
`__get_free_page(gfp_mask)` | Allocates a single page and returns a pointer to its logical address
`__get_free_pages(gfp_mask, order)` | Allocates 2<sup>order</sup> pages and returns a pointer to the first page’s logical address
`get_zeroed_page(gfp_mask)` | Allocates a single page, zero its contents and returns a pointer to its logical address

#### Freeing Pages

A family of functions enables you to free allocated pages when you no longer need them:

```c
void __free_pages(struct page *page, unsigned int order)
void free_pages(unsigned long addr, unsigned int order)
void free_page(unsigned long addr)
```

Be careful to free only pages you allocate. Passing the wrong `struct page` or address, or the incorrect order, can result in corruption. [p237]

For example, we want to allocate eight pages:

```c
unsigned long page;
page = __get_free_pages(GFP_KERNEL, 3);
if (!page) {
    /* insufficient memory: you must handle this error! */
    return –ENOMEM;
}
/* 'page' is now the address of the first of eight contiguous pages ... */
```

Free the eight pages, after we are done using them:

```c
free_pages(page, 3);
/*
* our pages are now freed and we should no
* longer access the address stored in 'page'
*/
```

The `GFP_KERNEL` parameter is an example of a `gfp_mask` flag (discussed shortly).

A kernel allocation can fail, and your code must check for and handle such errors after the call to `__get_free_pages()`. <u>It therefore often makes sense to allocate your memory at the start of the routine to make handling the error easier.</u> [p237]

These low-level page functions are useful when you need page-sized chunks of physically contiguous pages, especially if you need exactly a single page or two. For more general byte-sized allocations, the kernel provides `kmalloc()`.

### `kmalloc()`

The `kmalloc()` function is similar to user-space’s `malloc()`, with the exception of the additional flags parameter. The `kmalloc()` function is a simple interface for obtaining kernel memory in byte-sized chunks. If you need whole pages, the previously discussed interfaces might be a better choice. For most kernel allocations, `kmalloc()` is the preferred interface.

The function is declared in `<linux/slab.h>` ([include/linux/slab.h](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab.h)):

<small>[include/linux/slab_def.h#L128](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab_def.h#L128)</small>

```c
void * kmalloc(size_t size, gfp_t flags)
```

The `kmalloc()` function returns a pointer to a region of memory that is at least `size` bytes in length. It may allocate more than you asked, although you have no way of knowing how much more. Because the kernel allocator is page-based, some allocations may be rounded up to fit within the available memory. The kernel never returns less memory than requested. If the kernel is unable to find at least the requested amount, the allocation fails and the function returns `NULL`. The region of memory allocated is physically contiguous. Kernel allocations always succeed, unless an insufficient amount of memory is available. Thus, you must check for `NULL` after all calls to `kmalloc()` and handle the error appropriately.

For example:

```c
struct dog *p;
p = kmalloc(sizeof(struct dog), GFP_KERNEL);
if (!p)
    /* handle error ... */
```

If the `kmalloc()` call succeeds, `p` now points to a block of memory that is at least the requested size.The `GFP_KERNEL` flag specifies the behavior of the memory allocator while trying to obtain the memory to return to the caller of `kmalloc()`.

#### `gfp_mask` Flags

Flags are represented by the `gfp_t` type, which is defined in `<linux/types.h>` ([include/linux/types.h#L179](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/types.h#L179)) as an `unsigned int`. *gfp* stands for `__get_free_pages()` (discussed earlier).

The flags are broken up into three categories:

* **Action modifiers** specify *how* the kernel is supposed to allocate the requested memory. In certain situations, only certain methods can be employed to allocate memory. For example, interrupt handlers must instruct the kernel not to sleep (because interrupt handlers cannot reschedule) while allocating memory.
* **Zone modifiers** specify from *where* (from which zones) to allocate memory.
* **Type** specify a combination of action and zone modifiers for a certain type of memory allocation. This simplifies the specification of multiple modifiers; instead of providing a combination of action and zone modifiers, you can specify just one type flag. The `GFP_KERNEL` is a type flag, which is used for code in process context inside the kernel.

##### **Action Modifiers**

All the flags are declared in `<linux/gfp.h>` ([include/linux/gfp.h](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/gfp.h)). The file
`<linux/slab.h>` ([include/linux/slab.h](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab.h)) includes this header.

The table below is a list of the action modifiers.

Flag | Description
---- | -----------
`__GFP_WAIT` | The allocator can sleep.
`__GFP_HIGH` | The allocator can access emergency pools.
`__GFP_IO` | The allocator can start disk I/O.
`__GFP_FS` | The allocator can start filesystem I/O.
`__GFP_COLD` | The allocator should use cache cold pages.
`__GFP_NOWARN` | The allocator does not print failure warnings.
`__GFP_REPEAT` | The allocator repeats the allocation if it fails, but the allocation can potentially fail.
`__GFP_NOFAIL` | The allocator indefinitely repeats the allocation. The allocation cannot fail.
`__GFP_NORETRY` | The allocator never retries if the allocation fails.
`__GFP_NOMEMALLOC` | The allocator does not fall back on reserves.
`__GFP_HARDWALL` | The allocator enforces "hardwall" [cpuset](http://man7.org/linux/man-pages/man7/cpuset.7.html) boundaries.
`__GFP_RECLAIMABLE` | The allocator marks the pages reclaimable.
`__GFP_COMP` | The allocator adds compound.

These allocations can be specified together. For example:

```c
ptr = kmalloc(size, __GFP_WAIT | __GFP_IO | __GFP_FS);
```

This call instructs the page allocator (ultimately `alloc_pages()`) that the allocation can block, perform I/O, and perform filesystem operations. This gives the kernel great freedom in how it can find the free memory to satisfy the allocation.

##### **Zone Modifiers**

Zone modifiers specify from which memory zone the allocation should originate. Though allocations can be fulfilled from any zone, the kernel prefers `ZONE_NORMAL` to ensure that the other zones have free pages when they are needed.

There are only three zone modifiers because there are only three zones other than `ZONE_NORMAL`, as in the following table:

Flag | Description
---- | -----------
`__GFP_DMA` | Allocates only from `ZONE_DMA`
`__GFP_DMA32` | Allocates only from `ZONE_DMA32`
`__GFP_HIGHMEM` | Allocates from `ZONE_HIGHMEM` or `ZONE_NORMAL`

* The `__GFP_DMA` flag forces the kernel to satisfy the request from `ZONE_DMA`.
* The `__GFP_HIGHMEM` flag instructs the allocator to satisfy the request from either `ZONE_NORMAL` or (preferentially) `ZONE_HIGHMEM`.

If neither flag is specified, the kernel fulfills the allocation from either `ZONE_DMA` or `ZONE_NORMAL`, with a strong preference to satisfy the allocation from `ZONE_NORMAL`.

You cannot specify `__GFP_HIGHMEM` to either `__get_free_pages()` or `kmalloc()`, because these both return a logical address, and not a `page` structure. It is possible that these functions would allocate memory not currently mapped in the kernel’s virtual address space and thus, does not have a logical address. Only `alloc_pages()` can allocate high memory.

The majoriy of allocations will not specify a zone modifier because `ZONE_NORMAL` is sufficient.

##### **Type Flags**

The type flags specify the required action and zone modifiers to fulfill a particular type of transaction. Therefore, kernel code tends to use the correct type flag and not specify the myriad of other flags it might need. This is both simpler and less error-prone.

The table below is a list of the type flags:

Flag | Description
---- | -----------
`GFP_ATOMIC` | The allocation is high priority and must not sleep. This is the flag to use in interrupt handlers, in bottom halves, while holding a spinlock, and in other situations where you cannot sleep.
`GFP_NOWAIT` | Like `GFP_ATOMIC`, except that the call will not fallback on emergency memory pools. This increases the liklihood of the memory allocation failing.
`GFP_NOIO` | This allocation can block, but must not initiate disk I/O. This is the flag to use in block I/O code when you cannot cause more disk I/O, which might lead to some unpleasant recursion.
`GFP_NOFS` | This allocation can block and can initiate disk I/O, if it must, but it will not initiate a filesystem operation. This is the flag to use in filesystem code when you cannot start another filesystem operation.
`GFP_KERNEL` | This is a normal allocation and might block. This is the flag to use in process context code when it is safe to sleep. The kernel will do whatever it has to do to obtain the memory requested by the caller. This flag should be your default choice.
`GFP_USER` | This is a normal allocation and might block. This flag is used to allocate memory for user-space processes.
`GFP_HIGHUSER` | This is an allocation from `ZONE_HIGHMEM` and might block. This flag is used to allocate memory for user-space processes.
`GFP_DMA` | This is an allocation from `ZONE_DMA`. Device drivers that need DMA-able memory use this flag, usually in combination with one of the preceding flags.

The following table shows which modifiers are associated with each type flag:

Flag | Modifier Flags
---- | --------------
`GFP_NOFS` | <code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO)</code>
`GFP_KERNEL` | <code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO &#124; &#95;&#95;GFP_FS)</code>
`GFP_USER` | <code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO &#124; &#95;&#95;GFP_FS)</code>
`GFP_HIGHUSER` | <code>(&#95;&#95;GFP_WAIT &#124; &#95;&#95;GFP_IO &#124; &#95;&#95;GFP_FS &#124; &#95;&#95;GFP_HIGHMEM)</code>
`GFP_DMA` | <code>__GFP_DMA</code>

* The `GFP_KERNEL` flag. This flag is used in vast majority of allocations. The resulting allocation is a normal priority allocation that might sleep. Because the call can block, this flag can be used only from process context that can safely reschedule (no locks are held and so on.) Because this flag does not make any stipulations as to how the kernel may obtain the requested memory, the memory allocation has a high probability of succeeding.

* The `GFP_ATOMIC` flag. Because this flag specifies a memory allocation that cannot sleep, the allocation is restrictive in the memory it can obtain for the caller. If no sufficiently sized contiguous chunk of memory is available, the kernel is not likely to free memory because it cannot put the caller to sleep. Conversely, the `GFP_KERNEL` allocation can put the caller to sleep to swap inactive pages to disk, flush dirty pages to disk, and so on. Because `GFP_ATOMIC` cannot perform any of these actions, it has less of a chance of succeeding (at least when memory is low) compared to `GFP_KERNEL` allocations. Nonetheless, the `GFP_ATOMIC` flag is the only option when the current code cannot sleep, such as with interrupt handlers, softirqs, and tasklets.

Allocations initiated with `GFP_NOIO` and `GFP_NOFS` might block, but they refrain from performing certain other operations.

* The `GFP_NOIO` allocation does not initiate any disk I/O whatsoever to fulfill the request.
* The `GFP_NOFS` allocation might initiate disk I/O, but does not initiate filesystem I/O.

They are needed for certain low-level block I/O or filesystem code. For example, <u>a common path in the filesystem code allocated memory without the `GFP_NOFS` flag, the allocation could result in more filesystem operations, which may beget other allocations. This could continue indefinitely. Such filesystem code that invokes the allocator must ensure that the allocator also does not execute itself, or else the allocation can create a deadlock.</u>

The `GFP_DMA` flag specifes that the allocator must satisfy the request from `ZONE_DMA`. This flag is used by device drivers, which need DMA-able memory for their devices. Normally, you combine this flag with the `GFP_ATOMIC` or `GFP_KERNEL` flag.

The majority of the code uses either `GFP_KERNEL` or `GFP_ATOMIC`. Regardless of the allocation type, you must check for and handle failures.

Below is a list of the common situations and the flags to use.

Situation | Solution
--------- | --------
Process context, can sleep | Use `GFP_KERNEL`.
Process context, cannot sleep | Use `GFP_ATOMIC`, or perform your allocations with `GFP_KERNEL` at an earlier or later point when you can sleep.
Interrupt handler | Use `GFP_ATOMIC`.
Softirq | Use `GFP_ATOMIC`.
Tasklet | Use `GFP_ATOMIC`.
Need DMA-able memory, can sleep | Use <code>(GFP_DMA  &#124; GFP_KERNEL)</code>.
Need DMA-able memory, cannot sleep | Use <code>(GFP_DMA &#124; GFP_ATOMIC)</code>, or perform your allocation at an earlier point when you can sleep.

#### `kfree()`

The counterpart to `kmalloc()` is `kfree()`, declared in `<linux/slab.h>`:

<small>[include/linux/slab.h#L144](https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab.h#L144)</small>

```c
void kfree(const void *ptr);
```

The `kfree()` method frees a block of memory previously allocated with `kmalloc()`.

Do not call this function on memory not previously allocated with `kmalloc(`), or on memory that has already been freed. Doing so is a bug, resulting in bad behavior such as freeing memory belonging to another part of the kernel.

As in user-space, be careful to balance your allocations with your deallocations to prevent memory leaks and other bugs.  `kfree(NULL)` is explicitly checked for and safe.





### Doubts and Solutions

#### Verbatim

p235 on zones:

> A specific lock does not protect individual pages, although parts of the kernel may lock the data that happens to reside in said pages.
