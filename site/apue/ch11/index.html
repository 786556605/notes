<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch11/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 11. Threads - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../ch10/">Chapter 10. Signals</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 11. Threads</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../asm/">x86 assembly</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/apue/ch11.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-11-threads">Chapter 11. Threads</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#thread-concepts">Thread Concepts</a></li>
        
    
        <li class="main "><a href="#thread-identification">Thread Identification</a></li>
        
    
        <li class="main "><a href="#thread-creation">Thread Creation</a></li>
        
    
        <li class="main "><a href="#thread-termination">Thread Termination</a></li>
        
            <li><a href="#the-pthread_exit-and-pthread_join-functions">The pthread_exit and pthread_join functions</a></li>
        
            <li><a href="#the-pthread_cancel-function">The pthread_cancel function</a></li>
        
            <li><a href="#the-pthread_cleanup_push-and-pthread_cleanup_pop-functions">The pthread_cleanup_push and pthread_cleanup_pop functions</a></li>
        
            <li><a href="#the-pthread_detach-function">The pthread_detach function</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-11-threads"><strong>Chapter 11. Threads</strong></h3>
<h3 id="introduction">Introduction</h3>
<p>Processes are discussed in earlier chapters. A limited amount of sharing can occur between related processes.</p>
<p>This chapter looks inside a process further to see how to use multiple threads of control (or simply threads) to perform multiple tasks within the environment of a single process. All threads within a single process have access to the same process components, such as file descriptors and memory.</p>
<p>This chapter is concluded with synchronization mechanisms available to prevent multiple threads from viewing inconsistencies in their shared resources.</p>
<h3 id="thread-concepts">Thread Concepts</h3>
<p>With multiple threads of control, the programs can more than one thing at a time within a single process, with each thread handling a separate task. This approach can have several benefits:</p>
<ul>
<li>We can simplify code that deals with asynchronous events by assigning a separate thread to handle each event type, while each thread can then handle its event using a synchronous programming model. A synchronous programming model is much simpler than an asynchronous one.</li>
<li>Multiple processes have to use complex mechanisms provided by the operating system to share memory and file descriptors. Threads, in contrast, automatically have access to the same memory address space and file descriptors</li>
<li>The processing of independent tasks can be interleaved by assigning a separate thread per task (only if they don’t depend on the processing performed by each other), so that overall program throughput can be improved. (A single-threaded process has to implicitly serializes those tasks.)</li>
<li>Interactive programs can be improved in response time by using multiple threads to separate the portions of the program that deal with user input and output from the other parts of the program.</li>
</ul>
<p>The benefits of a multithreaded programming model can be realized on multiprocessor or multicore systems, and even on uniprocessor systems. A program can be simplified using threads regardless of the number of processors, since that doesn’t affect the program structure. As long as your program has to block when serializing tasks, there are improvements in response time and throughput when running on a uniprocessor, because some threads might be able to run while others are blocked.</p>
<p>A thread consists of the information necessary to represent an execution context within a process:</p>
<ul>
<li><strong>Thread ID</strong>: identifies the thread within a process</li>
<li>Set of register values</li>
<li>Stack</li>
<li>Scheduling priority and policy,</li>
<li>Signal mask</li>
<li>An errno variable (<a href="../ch1/#error-handling">Section 1.7</a>)</li>
<li>Thread-specific data (<a href="ch12.md#thread-specific-data">Section 12.6</a>).</li>
</ul>
<p>Everything within a process is sharable among the threads in a process:</p>
<ul>
<li>Text of the executable program</li>
<li>The program’s global and heap memory</li>
<li>Stacks</li>
<li>File descriptors.</li>
</ul>
<p>The threads interfaces of this chapter are from POSIX.1-2001, known as <strong>pthreads</strong> for "POSIX threads". The feature test macro for POSIX threads is <code>_POSIX_THREADS</code>. Applications can either use this in an <code>#ifdef</code> test to determine at compile time whether threads are supported or call <code>sysconf</code> with the <code>_SC_THREADS</code> constant to determine this at runtime. [p384]</p>
<h3 id="thread-identification">Thread Identification</h3>
<p>Unlike the process ID, which is unique in the system, the thread ID has significance only within the context of the process to which it belongs.</p>
<p>A thread ID is represented by the <code>pthread_t</code> data type. Implementations are allowed to use a structure to represent the <code>pthread_t</code> data type, so portable implementations can’t treat them as integers (process ID's <code>pid_t</code> data type is a non-negative integer). The <code>pthread_equal</code> function (below) must be used to compare two thread IDs. A consequence of allowing the <code>pthread_t</code> data type to be a structure is that there is no portable way to print its value. Linux 3.2.0 uses an unsigned long integer for the <code>pthread_t</code> data type. FreeBSD 8.0 and Mac OS X 10.6.8 use a pointer to the <code>pthread</code> structure for the <code>pthread_t</code> data type.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">int</span> <span class="nf">pthread_equal</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="kt">pthread_t</span> <span class="n">tid2</span><span class="p">);</span>

<span class="cm">/* Returns: nonzero if equal, 0 otherwise */</span>
</pre></div>


<p>A thread can obtain its own thread ID by calling the pthread_self function.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">pthread_t</span> <span class="nf">pthread_self</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="nl">Returns</span><span class="p">:</span> <span class="n">the</span> <span class="kr">thread</span> <span class="n">ID</span> <span class="n">of</span> <span class="n">the</span> <span class="n">calling</span> <span class="kr">thread</span>
</pre></div>


<p>This function can be used with <code>pthread_equal</code> when a thread needs to identify data structures that are tagged with its thread ID. For example, a single master thread places new jobs on a work queue. A pool of three worker threads removes jobs from the queue. Instead of allowing each thread to process whichever job is at the head of the queue, the master thread controls job assignment by placing the ID of the thread that should process the job in each job structure. Each worker thread then removes only jobs that are tagged with its own thread ID. This situation is illustrated below:</p>
<p><a href="../figure_11.1.png" title="Figure 11.1 Work queue example"><img alt="Figure 11.1 Work queue example" src="../figure_11.1.png" /></a></p>
<h3 id="thread-creation">Thread Creation</h3>
<p>The traditional UNIX process model (one thread of control per process) is conceptually the same as a threads-based model whereby each process is made up of only one thread. As the program runs, its behavior should be indistinguishable from the traditional process, until it creates more threads of control. [p385] Additional threads can be created by calling the <code>pthread_create</code> function:</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">tidp</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">attr</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_rtn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, error number on failure */</span>
</pre></div>


<ul>
<li>The memory location pointed to by <em>tidp</em> is set to the thread ID of the newly created thread when <code>pthread_create</code> returns successfully.</li>
<li>The <em>attr</em> argument is used to customize various thread attributes (detailed in <a href="ch12.md#thread-attributes">Section 12.3</a>). This chapter sets this to <code>NULL</code> to create a thread with the default attributes.</li>
<li>The newly created thread starts running at the address of the <em>start_rtn</em> function.</li>
<li>The <em>arg</em> is a pointer to the single argument passed to the <em>start_rtn</em>. If you need to pass more than one argument to the <code>start_rtn</code> function, then you need to store them in a structure and pass the address of the structure in <em>arg</em>.</li>
</ul>
<p>When a thread is created, there is no guarantee whether the newly created thread or the calling thread. <u>The newly created thread has access to the process address space and inherits the calling thread’s floating-point environment (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fenv.h.html"><code>fenv.h</code></a>) and signal mask; however, the set of pending signals for the thread is cleared.</u></p>
<p>The following example creates one thread and prints the process and thread IDs of the new thread and the initial thread:</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/threads/threadid.c">threads/threadid.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &quot;apue.h&quot;</span>
<span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">pthread_t</span> <span class="n">ntid</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">printids</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">pid_t</span>       <span class="n">pid</span><span class="p">;</span>
    <span class="kt">pthread_t</span>   <span class="n">tid</span><span class="p">;</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
    <span class="n">tid</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s pid %lu tid %lu (0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pid</span><span class="p">,</span>
      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">thr_fn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printids</span><span class="p">(</span><span class="s">&quot;new thread: &quot;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">err</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thr_fn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t create thread&quot;</span><span class="p">);</span>
    <span class="n">printids</span><span class="p">(</span><span class="s">&quot;main thread:&quot;</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This example handles the races between the main thread and the new thread as follows:</p>
<ul>
<li>First is the need to sleep in the main thread. Without sleep, the main thread might exit, thereby terminating the entire process before the new thread
gets a chance to run. This behavior is dependent on the operating system’s threads implementation and scheduling algorithms</li>
<li>Second, the new thread obtains its thread ID by calling <code>pthread_self</code> instead of reading it out of shared memory or receiving it as an argument to its thread-start routine. If the new thread runs before the main thread returns from calling <code>pthread_create</code>, then the new thread will see the uninitialized contents of <em>ntid</em> instead of the thread ID. [p387-388]</li>
</ul>
<h3 id="thread-termination">Thread Termination</h3>
<p>If any thread within a process calls <code>exit</code>, <code>_Exit</code>, or <code>_exit</code>, then the entire process terminates. Similarly, when the default action is to terminate the process, a signal sent to a thread will terminate the entire process.</p>
<p>A single thread can exit in three ways, without terminating the entire process:</p>
<ol>
<li>The thread can simply return from the start routine. The return value is the thread’s exit code.</li>
<li>The thread can be canceled by another thread in the same process.</li>
<li>The thread can call <code>pthread_exit</code>.</li>
</ol>
<h4 id="the-pthread_exit-and-pthread_join-functions">The <code>pthread_exit</code> and <code>pthread_join</code> functions</h4>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rval_ptr</span><span class="p">);</span>
</pre></div>


<p>The <em>rval_ptr</em> argument is a typeless pointer is available to other threads in the process by calling the <code>pthread_join</code> function.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">rval_ptr</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, error number on failure */</span>
</pre></div>


<p>The thread that calls <code>pthread_join</code> will block until the specified thread calls <code>pthread_exit</code>, returns from its start routine, or is canceled. If the thread simply returned from its start routine, <em>rval_ptr</em> will contain the return code. If the thread was canceled, the memory location specified by <em>rval_ptr</em> is set to <code>PTHREAD_CANCELED</code>.</p>
<p><u>By calling <code>pthread_join</code>, we automatically place the thread with which we’re joining in the detached state so that its resources can be recovered.  If the thread was already in the detached state, <code>pthread_join</code> can fail, returning <code>EINVAL</code>.</u></p>
<p>If we’re not interested in a thread’s return value, we can set <em>rval_ptr</em> to <code>NULL</code>.</p>
<p>The following example shows how to fetch the exit code from a thread that has terminated:</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/threads/exitstatus.c">threads/exitstatus.c</a></small></p>
<p>[p389-390]</p>
<p>The typeless pointer passed to <code>pthread_create</code> and <code>pthread_exit</code> can be used to pass the address of a structure containing more complex information.</p>
<p>If the structure was allocated on the caller’s stack, the memory contents might have changed by the time the structure is used. If a thread allocates a structure on its stack and passes a pointer to this structure to <code>pthread_exit</code>, then the stack might be destroyed and its memory reused for something else by the time the caller of <code>pthread_join</code> tries to use it.</p>
<p>The following example shows the problem with using an automatic variable (allocated on the stack) as the argument to <code>pthread_exit</code>:</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/threads/badexit2.c">threads/badexit2.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &quot;apue.h&quot;</span>
<span class="cp">#include &lt;pthread.h&gt;</span>

<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">printfoo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">foo</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  structure at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  foo.a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  foo.b = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  foo.c = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  foo.d = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">thr_fn1</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">foo</span>  <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

    <span class="n">printfoo</span><span class="p">(</span><span class="s">&quot;thread 1:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span>
    <span class="n">pthread_exit</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">thr_fn2</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread 2: ID is %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pthread_self</span><span class="p">());</span>
    <span class="n">pthread_exit</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>         <span class="n">err</span><span class="p">;</span>
    <span class="kt">pthread_t</span>   <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">foo</span>  <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thr_fn1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t create thread 1&quot;</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t join with thread 1&quot;</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;parent starting second thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thr_fn2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t create thread 2&quot;</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">printfoo</span><span class="p">(</span><span class="s">&quot;parent:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>When we run this program on Linux, we get:</p>
<div class="codehilite"><pre><span class="go">$ ./a.out</span>
<span class="go">thread 1:</span>
<span class="go">structure at 0x7f2c83682ed0</span>
<span class="go">foo.a = 1</span>
<span class="go">foo.b = 2</span>
<span class="go">foo.c = 3</span>
<span class="go">foo.d = 4</span>
<span class="go">parent starting second thread</span>
<span class="go">thread 2: ID is 139829159933696</span>
<span class="go">parent:</span>
<span class="go">structure at 0x7f2c83682ed0</span>
<span class="go">foo.a = -2090321472</span>
<span class="go">foo.b = 32556</span>
<span class="go">foo.c = 1</span>
<span class="go">foo.d = 0</span>
</pre></div>


<p>The contents of the structure (allocated on the stack of thread <em>tid1</em>) have changed by the time the main thread can access the structure. Note how the stack of the second thread (<em>tid2</em>) has overwritten the first thread’s stack. To solve this problem, we can either use a global structure or allocate the structure using <code>malloc</code>.</p>
<h4 id="the-pthread_cancel-function">The <code>pthread_cancel</code> function</h4>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">int</span> <span class="nf">pthread_cancel</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="n">tid</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, error number on failure */</span>
</pre></div>


<ul>
<li>By default, <code>pthread_cancel</code> will cause the thread specified by <em>tid</em> to behave as if it had called <code>pthread_exit</code> with an argument of <code>PTHREAD_CANCELED</code>, though a thread can ignore or otherwise control how it is canceled.</li>
<li><code>pthread_cancel</code> doesn’t wait for the thread to terminate; it merely makes the request.</li>
</ul>
<h4 id="the-pthread_cleanup_push-and-pthread_cleanup_pop-functions">The <code>pthread_cleanup_push</code> and <code>pthread_cleanup_pop</code> functions</h4>
<p>A thread can arrange for functions to be called when it exits, similar to the way that the <code>atexit</code> function (<a href="../ch7/#atexit-function">Section 7.3</a>). The functions are known as <strong>thread cleanup handlers</strong>. More than one cleanup handler can be established for a thread. The handlers are recorded in a stack, which means that they are executed in the reverse order from that with which they were registered.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">void</span> <span class="nf">pthread_cleanup_push</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rtn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">pthread_cleanup_pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">execute</span><span class="p">);</span>
</pre></div>


<p>The <code>pthread_cleanup_push</code> function schedules the cleanup function, <em>rtn</em>, to be called with the single argument, <em>arg</em>, when the thread performs one of the following actions:</p>
<ul>
<li>Makes a call to <code>pthread_exit</code></li>
<li>Responds to a cancellation request</li>
<li>Makes a call to <code>pthread_cleanup_pop</code> with a nonzero execute argument</li>
</ul>
<p>If the <em>execute</em> argument is set to zero, the cleanup function is not called.</p>
<p><code>pthread_cleanup_pop</code> removes the cleanup handler established by the last call to <code>pthread_cleanup_push</code>.</p>
<p>Because they can be implemented as macros, they must be used in matched pairs within the same scope in a thread. The macro definition of <code>pthread_cleanup_push</code> can include a <code>{</code> character, in which case the matching <code>}</code> character is in the <code>pthread_cleanup_pop</code> definition.</p>
<p>The following example shows how to use thread cleanup handlers. We need to match calls to <code>pthread_cleanup_pop</code> with the calls to <code>pthread_cleanup_push</code>; otherwise, the program might not compile. [p394]</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/threads/cleanup.c">threads/cleanup.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include &quot;apue.h&quot;</span>
<span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">void</span>
<span class="nf">cleanup</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cleanup: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">thr_fn1</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread 1 start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="n">cleanup</span><span class="p">,</span> <span class="s">&quot;thread 1 first handler&quot;</span><span class="p">);</span>
    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="n">cleanup</span><span class="p">,</span> <span class="s">&quot;thread 1 second handler&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread 1 push complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">thr_fn2</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread 2 start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="n">cleanup</span><span class="p">,</span> <span class="s">&quot;thread 2 first handler&quot;</span><span class="p">);</span>
    <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="n">cleanup</span><span class="p">,</span> <span class="s">&quot;thread 2 second handler&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread 2 push complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="n">pthread_exit</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">pthread_exit</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>         <span class="n">err</span><span class="p">;</span>
    <span class="kt">pthread_t</span>   <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
    <span class="kt">void</span>        <span class="o">*</span><span class="n">tret</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thr_fn1</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t create thread 1&quot;</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thr_fn2</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t create thread 2&quot;</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tret</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t join with thread 1&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread 1 exit code %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tret</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tret</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_exit</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">&quot;can&#39;t join with thread 2&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread 2 exit code %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tret</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Running the program  on Linux gives us:</p>
<div class="codehilite"><pre><span class="go">$ ./a.out</span>
<span class="go">thread 1 start</span>
<span class="go">thread 1 push complete</span>
<span class="go">thread 2 start</span>
<span class="go">thread 2 push complete</span>
<span class="go">cleanup: thread 2 second handler</span>
<span class="go">cleanup: thread 2 first handler</span>
<span class="go">thread 1 exit code 1</span>
<span class="go">thread 2 exit code 2</span>
</pre></div>


<p>Note that if the thread terminates by returning from its start routine, its cleanup handlers are not called. [p396]</p>
<p>The table below summarize similarities between the thread functions and the process functions.</p>
<table>
<thead>
<tr>
<th>Process primitive</th>
<th>Thread primitive</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fork</code></td>
<td><code>pthread_create</code></td>
<td>create a new flow of control</td>
</tr>
<tr>
<td><code>exit</code></td>
<td><code>pthread_exit</code></td>
<td>exit from an existing flow of control</td>
</tr>
<tr>
<td><code>waitpid</code></td>
<td><code>pthread_join</code></td>
<td>get exit status from flow of control</td>
</tr>
<tr>
<td><code>atexit</code></td>
<td><code>pthread_cleanup_push</code></td>
<td>register function to be called at exit from flow of control</td>
</tr>
<tr>
<td><code>getpid</code></td>
<td><code>pthread_self</code></td>
<td>get ID for flow of control</td>
</tr>
<tr>
<td><code>abort</code></td>
<td><code>pthread_cancel</code></td>
<td>request abnormal termination of flow of control</td>
</tr>
</tbody>
</table>
<h4 id="the-pthread_detach-function">The <code>pthread_detach</code> function</h4>
<p>By default, a thread’s termination status is retained until we call <code>pthread_join</code> for that thread. A thread’s underlying storage can be reclaimed immediately on termination if the thread has been detached. After a thread is detached, we can’t use the <code>pthread_join</code> function to wait for its termination status, because calling <code>pthread_join</code> for a detached thread results in undefined behavior. We can detach a thread by calling <code>pthread_detach</code>.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">int</span> <span class="nf">pthread_detach</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="n">tid</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, error number on failure */</span>
</pre></div>


<p>We can create a thread that is already in the detached state by modifying the thread attributes we pass to <code>pthread_create</code>. This is detailed in the next chapter.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>