<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch15/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 15. Interprocess Communication - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../ch10/">Chapter 10. Signals</a>
                        </li>
                    
                        <li >
                            <a href="../ch11/">Chapter 11. Threads</a>
                        </li>
                    
                        <li >
                            <a href="../ch12/">Chapter 12. Thread Control</a>
                        </li>
                    
                        <li >
                            <a href="../ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                    
                        <li >
                            <a href="../ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 15. Interprocess Communication</a>
                        </li>
                    
                        <li >
                            <a href="../ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LSP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lsp/ch9/">Chapter 9. Memory Management</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TLPI <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tlpi/ch6/">Chapter 6. Processes</a>
                        </li>
                    
                        <li >
                            <a href="../../tlpi/ch7/">Chapter 7. Memory Allocation</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../clrs/">CLRS</a>
                        </li>
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../asm/">x86 assembly</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/apue/ch15.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-15-interprocess-communication">Chapter 15. Interprocess Communication</a></li>
        
    
        <li class="main "><a href="#pipes">Pipes</a></li>
        
    
        <li class="main "><a href="#popen-and-pclose-functions">popen and pclose Functions</a></li>
        
    
        <li class="main "><a href="#coprocesses">Coprocesses</a></li>
        
    
        <li class="main "><a href="#fifos">FIFOs</a></li>
        
            <li><a href="#using-fifos-to-duplicate-output-streams">Using FIFOs to Duplicate Output Streams</a></li>
        
            <li><a href="#clientserver-communication-using-a-fifo">Client–Server Communication Using a FIFO</a></li>
        
    
        <li class="main "><a href="#xsi-ipc">XSI IPC</a></li>
        
            <li><a href="#identifiers-and-keys">Identifiers and Keys</a></li>
        
            <li><a href="#permission-structure">Permission Structure</a></li>
        
            <li><a href="#configuration-limits">Configuration Limits</a></li>
        
            <li><a href="#advantages-and-disadvantages">Advantages and Disadvantages</a></li>
        
    
        <li class="main "><a href="#message-queues">Message Queues</a></li>
        
    
        <li class="main "><a href="#semaphores">Semaphores</a></li>
        
            <li><a href="#timing-comparison-of-semaphores-record-locking-and-mutexes">Timing Comparison of Semaphores, Record Locking, and Mutexes</a></li>
        
    
        <li class="main "><a href="#shared-memory">Shared Memory</a></li>
        
    
        <li class="main "><a href="#posix-semaphores">POSIX Semaphores</a></li>
        
    
        <li class="main "><a href="#clientserver-properties">Client–Server Properties</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-15-interprocess-communication"><strong>Chapter 15. Interprocess Communication</strong></h3>
<p>This chapter discusses other techniques for processes to communicate with one another: interprocess communication (IPC).</p>
<p>The figure below summarizes the various forms of IPC that are supported by the four implementations discussed in this text.</p>
<p><a href="../figure_15.1.png" title="Figure 15.1 Summary of UNIX System IPC"><img alt="Figure 15.1 Summary of UNIX System IPC" src="../figure_15.1.png" /></a></p>
<ul>
<li>The "SUS" column allows an implementation to support full-duplex pipes, but requires only half-duplex pipes.</li>
<li>"(full)" shows implementations that support half-duplex pipes by using full-duplex pipes.</li>
<li>The bullet means that basic functionality is supported.</li>
<li>"UDS" means that the feature of full-duplex pipes can be provided through UNIX domain sockets</li>
</ul>
<p>[p533-534]</p>
<p>The first ten forms of IPC in the figure above are usually restricted to IPC between processes on the same host. The final two rows: sockets and STREAMS, are the only two forms that are generally supported for IPC between processes on different hosts.</p>
<p>This chapter dicusses classical IPC: pipes, FIFOs, message queues, semaphores, and shared memory.</p>
<h3 id="pipes">Pipes</h3>
<p>Pipes are the oldest form of UNIX System IPC and are provided by all UNIX systems. Pipes have two limitations:</p>
<ol>
<li>Historically, they have been half duplex (data flows in only one direction).  Some systems now provide full-duplex pipes, but for maximum portability, we should never assume that this is the case.</li>
<li>Pipes can be used only between processes that have a common ancestor. Normally, a pipe is created by a process, that process calls <code>fork</code>, and the pipe is used between the parent and the child.</li>
</ol>
<p>FIFOs (Section 15.5) get around the second limitation, and that UNIX domain sockets (Section 17.2) get around both limitations.</p>
<p>Despite these limitations, half-duplex pipes are still the most commonly used form of IPC. Every time you type a sequence of commands in a pipeline for the shell to execute, the shell creates a separate process for each command and links the standard output of one process to the standard input of the next using a pipe.</p>
<p>A pipe is created by calling the <code>pipe</code> function.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<p>Two file descriptors are returned through the <em>fd</em> argument: <em>fd[0]</em> is open for reading, and <em>fd[1]</em> is open for writing. The output of <em>fd[1]</em> is the input for <em>fd[0]</em>.</p>
<p>POSIX.1 allows for implementations to support full-duplex pipes. For these implementations, <em>fd[0]</em> and <em>fd[1]</em> are open for both reading and writing.</p>
<p>Two ways to picture a half-duplex pipe are shown in the figure below. The left half of the figure shows the two ends of the pipe connected in a single process. The right half of the figure emphasizes that the data in the pipe flows through the kernel.</p>
<p><a href="../figure_15.2.png" title="Figure 15.2 Two ways to view a half-duplex pipe"><img alt="Figure 15.2 Two ways to view a half-duplex pipe" src="../figure_15.2.png" /></a></p>
<p>The <code>fstat</code> function returns a file type of FIFO for the file descriptor of either end of a pipe. We can test for a pipe with the <code>S_ISFIFO</code> macro.</p>
<p>POSIX.1 states that the <code>st_size</code> member of the stat structure is undefined for pipes. But when the <code>fstat</code> function is applied to the file descriptor for the read end of the pipe, many systems store in <code>st_size</code> the number of bytes available for reading in the pipe, which is nonportable.</p>
<p>A pipe in a single process is next to useless. Normally, the process that calls pipe then calls <code>fork</code>, creating an IPC channel from the parent to the child, or vice versa. The following figure shows this scenario:</p>
<p><a href="../figure_15.3.png" title="Figure 15.3 Half-duplex pipe after a fork"><img alt="Figure 15.3 Half-duplex pipe after a fork" src="../figure_15.3.png" /></a></p>
<p>What happens after the <code>fork</code> depends on which direction of data flow we want. For a pipe from the parent to the child, the parent closes the read end of the pipe (<em>fd[0]</em>), and the child closes the write end (<em>fd[1]</em>). The following figure shows the resulting arrangement of descriptors.</p>
<p><a href="../figure_15.4.png" title="Figure 15.4 Pipe from parent to child"><img alt="Figure 15.4 Pipe from parent to child" src="../figure_15.4.png" /></a></p>
<p>For a pipe from the child to the parent, the parent closes fd[1], and the child closes fd[0].</p>
<p>When one end of a pipe is closed, two rules apply:</p>
<ol>
<li>If we <code>read</code> from a pipe whose write end has been closed, <code>read</code> returns 0 to
indicate an end of file after all the data has been read.<ul>
<li>Technically, we should say that this end of file is not generated until there are no more writers for the pipe.</li>
<li>It’s possible to duplicate a pipe descriptor so that multiple processes have the pipe open for writing.</li>
<li>Normally, there is a single reader and a single writer for a pipe. (The FIFOs in the next section dicusses that there are multiple writers for a single FIFO.)</li>
</ul>
</li>
<li>If we <code>write</code> to a pipe whose read end has been closed, the signal <code>SIGPIPE</code> is generated. If we either ignore the signal or catch it and return from the signal handler, <code>write</code> returns −1 with <code>errno</code> set to <code>EPIPE</code>.</li>
</ol>
<p>When we’re writing to a pipe (or FIFO), the constant <code>PIPE_BUF</code> specifies the kernel’s pipe buffer size. A write of <code>PIPE_BUF</code> bytes or less will not be interleaved with the writes from other processes to the same pipe (or FIFO). But if multiple processes are writing to a pipe (or FIFO), and if we write more than <code>PIPE_BUF</code> bytes, the data might be interleaved with the data from the other writers. We can determine the value of <code>PIPE_BUF</code> by using <code>pathconf</code> or <code>fpathconf</code>.</p>
<p>Example</p>
<p>[p537-541]</p>
<h3 id="popen-and-pclose-functions"><code>popen</code> and <code>pclose</code> Functions</h3>
<p>The standard I/O library has historically provided the <code>popen</code> and <code>pclose</code> functions. These two functions handle all the dirty work that we’ve been doing ourselves: creating a pipe, forking a child, closing the unused ends of the pipe, executing a shell to run the command, and waiting for the command to terminate.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">FILE</span> <span class="o">*</span><span class="nf">popen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdstring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Returns: file pointer if OK, NULL on error */</span>

<span class="kt">int</span> <span class="nf">pclose</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>

<span class="cm">/* Returns: termination status of cmdstring, or −1 on error */</span>
</pre></div>


<p>The function <code>popen</code> does a <code>fork</code> and <code>exec</code> to execute the <em>cmdstring</em> and returns a standard I/O file pointer. If <em>type</em> is "r", the file pointer is connected to the standard output of <em>cmdstring</em>, as shown in the figure below:</p>
<p><a href="../figure_15.9.png" title="Figure 15.9 Result of fp = popen(cmdstring, r)"><img alt="Figure 15.9 Result of fp = popen(cmdstring, &quot;r&quot;)" src="../figure_15.9.png" /></a></p>
<p>If type is "w", the file pointer is connected to the standard input of <em>cmdstring</em>, as shown in the figure below:</p>
<p><a href="../figure_15.10.png" title="Figure 15.10 Result of fp = popen(cmdstring, w)"><img alt="Figure 15.10 Result of fp = popen(cmdstring, &quot;w&quot;)" src="../figure_15.10.png" /></a></p>
<p>The <code>pclose</code> function closes the standard I/O stream, waits for the command to terminate, and returns the termination status of the shell. (The termination status is described in <a href="../ch8/#exit-status-vs-termination-status">Section 8.6</a>. The <code>system</code> function, described in <a href="../ch8/#system-function">Section 8.13</a>, also returns the termination status.) If the shell cannot be executed, the termination status returned by <code>pclose</code> is as if the shell had executed <code>exit(127)</code>.</p>
<p>The cmdstring is executed by the Bourne shell, as in:</p>
<div class="codehilite"><pre>sh -c cmdstring
</pre></div>


<p>This means that the shell expands any of its special characters in <em>cmdstring</em>. This allows us to say, for example,</p>
<div class="codehilite"><pre><span class="n">fp</span> <span class="o">=</span> <span class="n">popen</span><span class="p">(</span><span class="s">&quot;ls *.c&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span class="n">fp</span> <span class="o">=</span> <span class="n">popen</span><span class="p">(</span><span class="s">&quot;cmd 2&gt;&amp;1&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
</pre></div>


<p>Example</p>
<p>[p542-548]</p>
<h3 id="coprocesses">Coprocesses</h3>
<p>A UNIX system filter is a program that reads from standard input and writes to standard output. Filters are normally connected linearly in shell pipelines. A filter becomes a <strong>coprocess</strong> when the same program generates the filter’s input and reads the filter’s output.</p>
<p>The Korn shell provides coprocesses. The Bourne shell, the Bourne-again shell, and the C shell don’t provide a way to connect processes together as coprocesses. A coprocess normally runs in the background from a shell, and its standard input and standard output are connected to another program using a pipe.  Although the shell syntax required to initiate a coprocess and connect its input and output to other processes is quite contorted, coprocesses are also useful from a C program.</p>
<p>Whereas <code>popen</code> gives us a one-way pipe to the standard input or from the standard output of another process, with a coprocess we have two one-way pipes to the other process: one to its standard input and one from its standard output. We want to write to its standard input, let it operate on the data, and then read from its standard output.</p>
<p>Example</p>
<p>For example, the process creates two pipes: one is the standard input of the coprocess and the other is the standard output of the coprocess. The figure below shows this arrangement:</p>
<p><a href="../figure_15.16.png" title="Figure 15.16 Driving a coprocess by writing its standard input and reading its standard output"><img alt="Figure 15.16 Driving a coprocess by writing its standard input and reading its standard output" src="../figure_15.16.png" /></a></p>
<p>[p549-552]</p>
<h3 id="fifos">FIFOs</h3>
<p>FIFOs are sometimes called named pipes. Unnamed pipes can be used only between related processes when a common ancestor has created the pipe. With FIFOs, however, unrelated processes can exchange data.</p>
<p>A FIFO is a type of file (<a href="../ch4/#file-types">Chapter 4</a>). One of the encodings of the <code>st_mode</code> member of the stat structure indicates that a file is a FIFO. We can test for this with the <code>S_ISFIFO</code> macro. Creating a FIFO is similar to creating a file; the <em>pathname</em> for a FIFO exists in the file system.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;sys/stat.h&gt;</span>

<span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">mkfifoat</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/* Both return: 0 if OK, −1 on error */</span>
</pre></div>


<p>The specification of the <em>mode</em> argument is the same as for the <code>open</code> function. The rules for the user and group ownership of the new FIFO are the same as we described in <a href="../ch4/#ownership-of-new-files-and-directories">Section 4.6</a>.  The <code>mkfifoat</code> function is similar to the mkfifo function, except that it can be used to create a FIFO in a location relative to the directory represented by by the <em>fd</em> file descriptor argument. Like the other *at functions, there are three cases:</p>
<ol>
<li>If the <em>path</em> parameter specifies an absolute pathname, then the <em>fd</em> parameter is ignored and the <code>mkfifoat</code> function behaves like the <code>mkfifo</code> function.</li>
<li>If the <em>path</em> parameter specifies a relative pathname and the <em>fd</em> parameter is a valid file descriptor for an open directory, the pathname is evaluated relative to this directory.</li>
<li>If the <em>path</em> parameter specifies a relative pathname and the <em>fd</em> parameter has the special value <code>AT_FDCWD</code>, the pathname is evaluated starting in the current working directory, and <code>mkfifoat</code> behaves like <code>mkfifo</code>.</li>
</ol>
<p>Once we have used <code>mkfifo</code> or <code>mkfifoat</code> to create a FIFO, we open it using <code>open</code>. The normal file I/O functions (e.g., <code>close</code>, <code>read</code>, <code>write</code>, <code>unlink</code>) all work with FIFOs.</p>
<p>Applications can create FIFOs with the <code>mknod</code> and <code>mknodat</code> functions. Because POSIX.1 originally didn’t include <code>mknod</code>, the <code>mkfifo</code> function was invented specifically for POSIX.1.  The <code>mknod</code> and <code>mknodat</code> functions are included in the XSI option in POSIX.1.  POSIX.1 also includes support for the <code>mkfifo(1)</code> command. All four platforms discussed in this text provide this command. As a result, we can create a FIFO using a shell command and then access it with the normal shell I/O redirection.</p>
<p>When we open a FIFO, the nonblocking flag (<code>O_NONBLOCK</code>) affects what happens:</p>
<ul>
<li>In the normal case (without <code>O_NONBLOCK</code>), an open for read-only blocks until some other process opens the FIFO for writing. Similarly, an open for writeonly blocks until some other process opens the FIFO for reading.</li>
<li>If <code>O_NONBLOCK</code> is specified, an <code>open</code> for read-only returns immediately. But an open for write-only returns −1 with <code>errno</code> set to <code>ENXIO</code> if no process has the FIFO open for reading.</li>
</ul>
<p>As with a pipe, if we <code>write</code> to a FIFO that no process has open for reading, the signal <code>SIGPIPE</code> is generated. When the last writer for a FIFO closes the FIFO, an end of file is generated for the reader of the FIFO.</p>
<p>It is common to have multiple writers for a given FIFO. This means that we have to worry about atomic writes if we don’t want the writes from multiple processes to be interleaved. As with pipes, the constant <code>PIPE_BUF</code> specifies the maximum amount of data that can be written atomically to a FIFO.</p>
<p>There are two uses for FIFOs.</p>
<ol>
<li>FIFOs are used by shell commands to pass data from one shell pipeline to another without creating intermediate temporary files.</li>
<li>FIFOs are used as rendezvous points in client–server applications to pass data between the clients and the servers.</li>
</ol>
<h4 id="using-fifos-to-duplicate-output-streams">Using FIFOs to Duplicate Output Streams</h4>
<p>FIFOs can be used to duplicate an output stream in a series of shell commands. This prevents writing the data to an intermediate disk file (similar to using pipes to avoid intermediate disk files). But whereas pipes can be used only for linear connections between processes, a FIFO has a name, so it can be used for nonlinear connections.</p>
<p>Consider a procedure that needs to process a filtered input stream twice. The figure below shows this arrangement.</p>
<p><a href="../figure_15.20.png" title="Figure 15.20 Procedure that processes a filtered input stream twice"><img alt="Figure 15.20 Procedure that processes a filtered input stream twice" src="../figure_15.20.png" /></a></p>
<p>With a FIFO and the UNIX program <code>tee(1)</code>, we can accomplish this procedure without using a temporary file. (The <code>tee</code> program copies its standard input to both its standard output and the file named on its command line.)</p>
<div class="codehilite"><pre>mkfifo fifo1
prog3 &lt; fifo1 <span class="p">&amp;</span>
prog1 &lt; infile <span class="p">|</span> tee fifo1 <span class="p">|</span> prog2
</pre></div>


<p>We create the FIFO and then start <code>prog3</code> in the background, reading from the FIFO. We then start <code>prog1</code> and use <code>tee</code> to send its input to both the FIFO and <code>prog2</code>. The following figure shows the process arrangement.</p>
<p><a href="../figure_15.21.png" title="Figure 15.21 Using a FIFO and tee to send a stream to two different processes"><img alt="Figure 15.21 Using a FIFO and tee to send a stream to two different processes" src="../figure_15.21.png" /></a></p>
<h4 id="clientserver-communication-using-a-fifo">Client–Server Communication Using a FIFO</h4>
<p>Another use for FIFOs is to send data between a client and a server. If we have a server that is contacted by numerous clients, each client can write its request to a well-known FIFO that the server creates. "well-known" means that the pathname of the FIFO is known to all the clients that need to contact the server.</p>
<p><a href="../figure_15.22.png" title="Figure 15.22 Clients sending requests to a server using a FIFO"><img alt="Figure 15.22 Clients sending requests to a server using a FIFO" src="../figure_15.22.png" /></a></p>
<p><u>Since there are multiple writers for the FIFO, the requests sent by the clients to the server need to be less than <code>PIPE_BUF</code> bytes in size. This prevents any interleaving of the client writes.</u></p>
<p>The problem in using FIFOs for this type of client–server communication is how to send replies back from the server to each client. A single FIFO can’t be used, as the clients would never know when to read their response versus responses for other clients. One solution is for each client to send its process ID with the request. The server then creates a unique FIFO for each client, using a pathname based on the client’s process ID. For example, the server can create a FIFO with the name <code>/tmp/serv1.XXXXX</code>, where <code>XXXXX</code> is replaced with the client’s process ID. This arrangement is shown the figure below.</p>
<p>This arrangement works, although it is impossible for the server to tell whether a client crashes. A client crash leaves the client-specific FIFO in the file system. The server also must catch <code>SIGPIPE</code>, since it’s possible for a client to send a request and terminate before reading the response, leaving the client-specific FIFO with one writer (the server) and no reader.</p>
<p><a href="../figure_15.23.png" title="Figure 15.23 Client–server communication using FIFOs"><img alt="Figure 15.23 Client–server communication using FIFOs" src="../figure_15.23.png" /></a></p>
<p>With the arrangement shown in the figure above, if the server opens its well-known FIFO read-only (since it only reads from it) each time the number of clients goes from 1 to 0, the server will read an end of file on the FIFO. To prevent the server from having to handle this case, a common trick is just to have the server open its well-known FIFO for read–write.</p>
<h3 id="xsi-ipc">XSI IPC</h3>
<p>The three types of IPC that we call XSI IPC: message queues, semaphores, and shared memory, have many similarities. This section covers these similar features; in the following sections, we look at the specific functions for each of the three IPC types.</p>
<h4 id="identifiers-and-keys">Identifiers and Keys</h4>
<p>Each IPC structure (message queue, semaphore, or shared memory segment) in the kernel is referred to by a non-negative integer identifier. To send a message to or fetch a message from a message queue, for example, all we need know is the identifier for the queue. Unlike file descriptors, IPC identifiers are not small integers. Indeed, when a given IPC structure is created and then removed, the identifier associated with that structure continually increases until it reaches the maximum positive value for an integer, and then wraps around to 0.</p>
<p>The identifier is an internal name for an IPC object. Cooperating processes need an external naming scheme to be able to rendezvous using the same IPC object. For this purpose, an IPC object is associated with a <em>key</em> that acts as an external name.</p>
<p>Whenever an IPC structure is being created (by calling <code>msgget</code>, <code>semget</code>, or <code>shmget</code>), a key must be specified. The data type of this key is the primitive system data type <code>key_t</code>, which is often defined as a long integer in the header <code>&lt;sys/types.h&gt;</code>.  This key is converted into an identifier by the kernel.</p>
<p>[p557-560]</p>
<h4 id="permission-structure">Permission Structure</h4>
<h4 id="configuration-limits">Configuration Limits</h4>
<h4 id="advantages-and-disadvantages">Advantages and Disadvantages</h4>
<h3 id="message-queues">Message Queues</h3>
<p>A message queue is a linked list of messages stored within the kernel and identified by a message queue identifier. The message queue is called a <em>queue</em> and its identifier is called a <em>queue ID</em>.</p>
<p>[p561-565]</p>
<h3 id="semaphores">Semaphores</h3>
<p>A semaphore isn’t a form of IPC similar to the others described (pipes, FIFOs, and message queues). A semaphore is a counter used to provide access to a shared data object for multiple processes.</p>
<p>The Single UNIX Specification includes an alternative set of semaphore interfaces that were originally part of its real-time extensions. These interfaces are discussed in <a href="#posix-semaphores">Section 15.10</a>.</p>
<p>To obtain a shared resource, a process needs to do the following:</p>
<ol>
<li>Test the semaphore that controls the resource.</li>
<li>If the value of the semaphore is positive, the process can use the resource. In this case, the process decrements the semaphore value by 1, indicating that it has used one unit of the resource.</li>
<li>Otherwise, if the value of the semaphore is 0, the process goes to sleep until the semaphore value is greater than 0. When the process wakes up, it returns to step 1.</li>
</ol>
<p>When a process is done with a shared resource that is controlled by a semaphore, the semaphore value is incremented by 1. If any other processes are asleep, waiting for the semaphore, they are awakened.</p>
<p><u>To implement semaphores correctly, the test of a semaphore’s value and the decrementing of this value must be an atomic operation. For this reason, semaphores are normally implemented inside the kernel.</u></p>
<p>A common form of semaphore is called a <strong>binary semaphore</strong>. It controls a single resource, and its value is initialized to 1. In general, however, a semaphore can be initialized to any positive value, with the value indicating how many units of the shared resource are available for sharing.</p>
<p>[p566-570]</p>
<h4 id="timing-comparison-of-semaphores-record-locking-and-mutexes">Timing Comparison of Semaphores, Record Locking, and Mutexes</h4>
<p>If we are sharing a single resource among multiple processes, we can use one of three
techniques to coordinate access:</p>
<ul>
<li>A semaphore</li>
<li>Record locking</li>
<li>A mutex that is mapped into the address spaces of both processes</li>
</ul>
<p>It’s interesting to compare the timing differences between the three techniques:</p>
<ul>
<li>
<p><strong>Semaphore</strong>. With a semaphore, we create a semaphore set consisting of a single member and initialize the semaphore’s value to 1.</p>
<ul>
<li>To allocate the resource, we call semop with a <code>sem_op</code> of −1;</li>
<li>To release the resource, we perform a <code>sem_op</code> of +1.</li>
</ul>
<p>We also specify <code>SEM_UNDO</code> with each operation, to handle the case of a process that terminates without releasing its resource.</p>
</li>
<li>
<p><strong>Record locking</strong>. With record locking, we create an empty file and use the first byte of the file (which need not exist) as the lock byte.</p>
<ul>
<li>To allocate the resource, we obtain a write lock on the byte;</li>
<li>To release it, we unlock the byte.</li>
</ul>
<p>The record locking properties guarantee that if a process terminates while holding a lock, the kernel automatically releases the lock.</p>
</li>
<li>
<p><strong>Mutex</strong>. To use a mutex, we need both processes to map the same file into their address spaces and initialize a mutex at the same offset in the file using the <code>PTHREAD_PROCESS_SHARED</code> mutex attribute.</p>
<ul>
<li>To allocate the resource, we lock the mutex;</li>
<li>To release the resource, we unlock the mutex.</li>
</ul>
<p>If a process terminates without releasing the mutex, recovery is difficult unless we use a robust mutex (<code>pthread_mutex_consistent</code> function discussed in Section 12.4.1).</p>
</li>
</ul>
<p>The following table shows the time required to perform these three locking techniques on Linux. In each case, the resource was allocated and then released 1,000,000 times. This was done simultaneously by three different processes. The times are the totals in seconds for all three processes.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>User</th>
<th>System</th>
<th>Clock</th>
</tr>
</thead>
<tbody>
<tr>
<td>semaphores with undo</td>
<td>0.50</td>
<td>6.08</td>
<td>7.55</td>
</tr>
<tr>
<td>advisory record locking</td>
<td>0.51</td>
<td>9.06</td>
<td>4.38</td>
</tr>
<tr>
<td>mutex in shared memory</td>
<td>0.21</td>
<td>0.40</td>
<td>0.25</td>
</tr>
</tbody>
</table>
<p>On Linux, record locking is faster than semaphores, but mutexes in shared memory outperform both semaphores and record locking. If we’re locking a single resource and don’t need all the fancy features of XSI semaphores, record locking is preferred over semaphores. The reasons are that it is much simpler to use, it is faster (on this platform), and the system takes care of any lingering locks when a process terminates.  Even though using a mutex in shared memory is the fastest option on this platform, we still prefer to use record locking, unless performance is the primary concern. There are two reasons for this. First, recovery from process termination is more difficult using a mutex in memory shared among multiple processes. Second, the process-shared mutex attribute isn’t universally supported yet. In older versions of the Single UNIX Specification, it was optional. Although it is still optional in SUSv4, it is now required by all XSI-conforming implementations. Of the four platforms covered in this text, only Linux 3.2.0 and Solaris 10 currently support the
process-shared mutex attribute.</p>
<h3 id="shared-memory">Shared Memory</h3>
<h3 id="posix-semaphores">POSIX Semaphores</h3>
<h3 id="clientserver-properties">Client–Server Properties</h3>
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<p>p537 on pipes.</p>
<blockquote>
<p>When we’re writing to a pipe (or FIFO), the constant <code>PIPE_BUF</code> specifies the kernel’s pipe buffer size. A write of <code>PIPE_BUF</code> bytes or less will not be interleaved with the writes from other processes to the same pipe (or FIFO). But if multiple processes are writing to a pipe (or FIFO), and if we write more than <code>PIPE_BUF</code> bytes, the data might be interleaved with the data from the other writers.</p>
</blockquote>
<p>What does "interleaved" mean here?</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>