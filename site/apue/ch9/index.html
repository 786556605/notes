<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch9/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 9. Process Relationships - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 9. Process Relationships</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="https://github.com/shichao-an/notes">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-9-process-relationships">Chapter 9. Process Relationships</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#terminal-logins">Terminal Logins</a></li>
        
            <li><a href="#bsd-terminal-logins">BSD Terminal Logins</a></li>
        
            <li><a href="#mac-os-x-terminal-logins">Mac OS X Terminal Logins</a></li>
        
            <li><a href="#linux-terminal-logins">Linux Terminal Logins</a></li>
        
            <li><a href="#solaris-terminal-logins">Solaris Terminal Logins</a></li>
        
    
        <li class="main "><a href="#network-logins">Network Logins</a></li>
        
            <li><a href="#bsd-network-logins">BSD Network Logins</a></li>
        
            <li><a href="#mac-os-x-network-logins">Mac OS X Network Logins</a></li>
        
            <li><a href="#linux-network-logins">Linux Network Logins</a></li>
        
            <li><a href="#solaris-network-logins">Solaris Network Logins</a></li>
        
    
        <li class="main "><a href="#process-groups">Process Groups</a></li>
        
            <li><a href="#process-group-lifetime">Process group lifetime</a></li>
        
            <li><a href="#setpgid-function">setpgid function</a></li>
        
    
        <li class="main "><a href="#sessions">Sessions</a></li>
        
            <li><a href="#the-setsid-function">The setsid function</a></li>
        
            <li><a href="#ensuring-the-successful-call-of-setsid">Ensuring the successful call of setsid</a></li>
        
            <li><a href="#session-leader-and-session-id">Session Leader and Session ID</a></li>
        
            <li><a href="#the-getsid-function">The getsid function</a></li>
        
    
        <li class="main "><a href="#controlling-terminal">Controlling Terminal</a></li>
        
            <li><a href="#mechanisms-of-allocating-a-controlling-terminal">Mechanisms of allocating a controlling terminal</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-9-process-relationships"><strong>Chapter 9. Process Relationships</strong></h3>
<h3 id="introduction">Introduction</h3>
<p>Every process has a parent process (the initial kernel-level process is usually its own parent). The parent is notified when the child terminates, and the parent can obtain the child’s exit status.</p>
<p>This chapter details process groups and the concept of session introduced by POSIX.1, as well as relationship between the login shell that is invoked when a user logs in and all the processes that are started from the login shell.</p>
<p>The concept of UNIX system signal mechanism in <a href="../../apue/ch10/">Chapter 10</a> is needed.</p>
<h3 id="terminal-logins">Terminal Logins</h3>
<p>In early UNIX systems, the terminals (dumb terminals that are hard-wired connected to the host) were either local (directly connected) or remote (connected through a modem). These logins came through a terminal device driver in the kernel. [p285]</p>
<p>As bitmapped graphical terminals became available, windowing systems were developed to provide users with new ways to interact with host computers.  Applications were developed to create "terminal windows" to emulate character-based terminals, allowing users to interact with hosts in familiar ways (i.e., via the shell command line).</p>
<p>Today, some platforms allow you to start a windowing system after logging in, whereas other platforms automatically start the windowing system for you. In the latter case, you might still have to log in, depending on how the windowing system is configured (some windowing systems can be configured to log you in automatically).</p>
<p>The procedure that we now describe is used to log in to a UNIX system using a terminal. The procedure is similar regardless of the type of terminal we use. It could be a:</p>
<ul>
<li>character-based terminal,</li>
<li>a graphical terminal emulating a simple character-based terminal,</li>
<li>or a graphical terminal running a windowing system.</li>
</ul>
<h4 id="bsd-terminal-logins">BSD Terminal Logins</h4>
<p>The file <code>/etc/ttys</code> (created by the system administrator) has one line per terminal device. Each line specifies the name of the device and other parameters (e.g. baud rate) that are passed to the <code>getty</code> program.</p>
<p>After the system is bootstrapped, the kernel creates the <code>init</code> process (PID 1) which brings the system up in multiuser mode. The <code>init</code> process reads the file <code>/etc/ttys</code> and, for every terminal device that allows a login, does a <code>fork</code> followed by an <code>exec</code> of the program <code>getty</code>.</p>
<p><a href="../figure_9.2.png" title="Figure 9.2 State of processes after login has been invoked"><img alt="Figure 9.2 State of processes after login has been invoked" src="../figure_9.2.png" /></a></p>
<p>All the processes shown in the figure above have a real user ID of 0 and an effective user ID of 0 (they all have superuser privileges). All the processes other than the original <code>init</code> process have a parent process ID of 1.</p>
<ul>
<li>The <code>init</code> process <code>exec</code>s the <code>getty</code> program with an empty environment.</li>
<li><code>getty</code> calls <code>open</code> to open terminal device for reading and writing. File descriptors 0, 1, and 2 are set to the device.</li>
<li>Then, <code>getty</code> outputs something like <code>login:</code> and waits for us to enter our user name. <code>getty</code> can detect special characters to change the terminal's speed (baud rate). [p287]</li>
<li>
<p>When we enter our user name, <code>getty</code>’s job is complete, and it then invokes the <code>login</code> program, similar to:</p>
<pre><code>execle("/bin/login", "login", "-p", username, (char *)0, envp);
</code></pre>
</li>
<li>
<p>Though <code>init</code> invokes <code>getty</code> with an empty environment, <code>getty</code> creates an environment for <code>login</code> (the <code>envp</code> argument) with the name of the terminal (something like <code>TERM=foo</code>, where the type of terminal <code>foo</code> is taken from the <code>gettytab</code> file) and any environment strings that are specified in the <code>gettytab</code>. The <code>-p</code> flag to <code>login</code> tells it to preserve the environment that it is passed and to add to that environment, not replace it.</p>
</li>
<li><code>login</code> does the following things:<ul>
<li>It calls <code>getpwnam</code> to fetch our password file entry.</li>
<li>It calls <code>getpass(3)</code> to display the prompt <code>Password:</code> and read our password (with echoing disabled).</li>
<li>It calls <code>crypt(3)</code> to encrypt the password that we entered and compares the encrypted result to the <code>pw_passwd</code> field from our shadow password file entry.</li>
<li>If the login attempt fails because of an invalid password (after a few tries), <code>login</code> calls <code>exit</code> with an argument of 1. This termination will be noticed by the parent (<code>init</code>), and it will do another <code>fork</code> followed by an <code>exec</code> of <code>getty</code>, starting the procedure over again for this terminal.</li>
</ul>
</li>
</ul>
<p>This is the traditional authentication procedure used on UNIX systems. Modern UNIX systems have evolved to support multiple authentication procedures. FreeBSD, Linux, Mac OS X, and Solaris all support a more flexible scheme known as PAM (<a href="https://en.wikipedia.org/wiki/Pluggable_authentication_module">Pluggable Authentication Modules</a>). PAM allows an administrator to configure the authentication methods to be used to access services that are written to use the PAM library. [p288]</p>
<p>If we log in correctly, <code>login</code> will:</p>
<ul>
<li>Change to our home directory (<code>chdir</code>)</li>
<li>Change the ownership of our terminal device (<code>chown</code>) so we own it</li>
<li>Change the access permissions for our terminal device so we have permission to read from and write to it</li>
<li>Set our group IDs by calling <code>setgid</code> and <code>initgroups</code></li>
<li>Initialize the environment with all the information that login has:<ul>
<li>our home directory (<code>HOME</code>),</li>
<li>shell (<code>SHELL</code>),</li>
<li>user name (<code>USER</code> and <code>LOGNAME</code>),</li>
<li>and a default path (<code>PATH</code>).</li>
</ul>
</li>
<li>
<p>Change to our user ID (<code>setuid</code>) and invoke our login shell, as in</p>
<pre><code>execl("/bin/sh", "-sh", (char *)0);
</code></pre>
<p>The minus sign as the first character of <code>argv[0]</code> is a flag to all the shells that indicates they are being invoked as a <strong>login shell</strong>. The shells can look at this character and modify their start-up accordingly.</p>
</li>
</ul>
<p>The <code>login</code> can optionally print the <a href="https://en.wikipedia.org/wiki/Motd_(Unix)">message-of-the-day</a> file, check for new mail, and performs other tasks.</p>
<p>Since it is called by a superuser process, <code>setuid</code> changes all three user IDs: the real user ID, effective user ID, and saved set-user-ID. The call to <code>setgid</code> that was done earlier by <code>login</code> has the same effect on all three group IDs.</p>
<p>At this point, our login shell is running. Its parent process ID is the original <code>init</code> process (process ID 1), so when our login shell terminates, <code>init</code> is sent a <code>SIGCHLD</code> signal and it starts the whole procedure over again for this terminal. File descriptors 0, 1, and 2 for our login shell are set to the terminal device. See the figure below:</p>
<p><a href="../figure_9.3.png" title="Figure 9.3 Arrangement of processes after everything is set for a terminal login"><img alt="Figure 9.3 Arrangement of processes after everything is set for a terminal login" src="../figure_9.3.png" /></a></p>
<p>Our login shell now reads its start-up files (<code>.profile</code> for the Bourne shell and Korn shell; <code>.bash_profile</code>, <code>.bash_login</code>, or <code>.profile</code> for the GNU Bourne-again shell; and <code>.cshrc</code> and <code>.login</code> for the C shell). These start-up files usually change some of the environment variables and add many other variables to the environment. For example, most users set their own <code>PATH</code> and often prompt for the actual terminal type (<code>TERM</code>). When the start-up files are done, we finally get the shell’s prompt and can enter commands.</p>
<h4 id="mac-os-x-terminal-logins">Mac OS X Terminal Logins</h4>
<p>On Mac OS X, the terminal login process follows essentially the same steps as in the BSD login process (since Mac OS X is based in part on FreeBSD) with the following differences:</p>
<ul>
<li>The work of <code>init</code> is performed by <code>launchd</code>.</li>
<li>We are presented with a graphical-based login screen from the start.</li>
</ul>
<h4 id="linux-terminal-logins">Linux Terminal Logins</h4>
<p>The Linux login procedure is very similar to the BSD procedure. The login command is derived from 4.3BSD. The main difference is in terminal configuration.</p>
<p>Some Linux distributions ship with a version of the <code>init</code> program that uses administrative files patterned after System V’s <code>init</code> file formats. where <code>/etc/inittab</code> specifies the terminal devices for which <code>init</code> should start a <code>getty</code> process. Other Linux distributions, such as Ubuntu, ship with a version of init that is known as "<a href="https://en.wikipedia.org/wiki/Upstart">Upstart</a>". It uses configuration files named <code>*.conf</code> that are
stored in the <code>/etc/init</code> directory. For example, the specifications for running <code>getty</code> on <code>/dev/tty1</code> might be found in the file <code>/etc/init/tty1.conf</code>.</p>
<p>Depending on the version of <code>getty</code> in use, the terminal characteristics are specified either on the command line (as with <code>agetty</code>) or in the file <code>/etc/gettydefs</code> (as with <code>mgetty</code>).</p>
<h4 id="solaris-terminal-logins">Solaris Terminal Logins</h4>
<p>[p290]</p>
<h3 id="network-logins">Network Logins</h3>
<p>The main difference between a serial terminal login and a network login is that the connection between the terminal and the computer isn’t point-to-point. In this case, <code>login</code> is simply a service available, just like any other network service, such as FTP or SMTP.</p>
<p>With the terminal logins, <code>init</code> knows which terminal devices are enabled for logins and spawns a <code>getty</code> process for each device. In the case of network logins, however, all the logins come through the kernel’s network interface drivers (e.g., the Ethernet driver), and we don’t know ahead of time how many of these will occur. Instead of having a process waiting for each possible login, we now have to wait for a network connection request to arrive.</p>
<p>To allow the same software to process logins over both terminal logins and network logins, a software driver called a <strong>pseudo terminal</strong> (detailed in <a href="../../apue/ch19/">Chapter 19</a>) is used to emulate the behavior of a serial terminal and map terminal operations to network operations, and vice versa.</p>
<h4 id="bsd-network-logins">BSD Network Logins</h4>
<p>In BSD, the <code>inetd</code> process, sometimes called the <em>Internet superserver</em>, waits for most network connections.</p>
<p>As part of the system start-up, <code>init</code> invokes a shell that executes the shell script <code>/etc/rc</code>, which starts <code>inetd</code> along with other daemons. Once the shell script terminates, the parent process of <code>inetd</code> becomes <code>init</code>; <code>inetd</code> waits for TCP/IP connection requests to arrive at the host. When a connection request arrives for it to handle, <code>inetd</code> does a <code>fork</code> and <code>exec</code> of the appropriate program.</p>
<p>Assume a TCP connection request arrives for the TELNET server (a remote login application). The remote user initiates the login by starting the TELNET client:</p>
<pre><code class="sh">telnet hostname
</code></pre>

<p>The client opens a TCP connection to <em>hostname</em> and the user who started the client program is now logged in to the server’s host. The figure below shows the sequence of processes involved in executing the TELNET server, called <code>telnetd</code>:</p>
<p><a href="../figure_9.4.png" title="Figure 9.4 Sequence of processes involved in executing TELNET server"><img alt="Figure 9.4 Sequence of processes involved in executing TELNET server" src="../figure_9.4.png" /></a></p>
<p>Then, <u>the <code>telnetd</code> process then opens a pseudo terminal device and splits into two processes using <code>fork</code>,</u> which do the following:</p>
<ul>
<li>The parent (<code>telnetd</code>) handles the communication across the network connection.</li>
<li>The child <code>exec</code>s the <code>login</code> program.</li>
<li>The parent and the child are connected through the pseudo terminal. Before doing the <code>exec</code>, the child sets up file descriptors 0, 1, and 2 to the pseudo terminal.</li>
<li>If we log in correctly, login performs the same steps described in <a href="#bsd-terminal-logins">Section 9.2</a>: it changes to our home directory and sets our group IDs, user ID, and our initial environment. Then <code>login</code> replaces itself with our login shell by calling <code>exec</code>.</li>
</ul>
<p><a href="../figure_9.5.png" title="Figure 9.5 Arrangement of processes after everything is set for a network login"><img alt="Figure 9.5 Arrangement of processes after everything is set for a network login" src="../figure_9.5.png" /></a></p>
<p>Whether we log in through a terminal (<a href="../figure_9.3.png">Figure 9.3</a>) or a network (<a href="../figure_9.5.png">Figure 9.5</a>), we have a login shell with its standard input, standard output, and standard error connected to either a terminal device or a pseudo terminal device.</p>
<p>In the coming sections, we'll see that the login shell is the start of a POSIX.1 session, and that the terminal or pseudo terminal is the controlling terminal for the session.</p>
<h4 id="mac-os-x-network-logins">Mac OS X Network Logins</h4>
<p>The network login on Mac OS X is identical to that on BSD, except that the <code>telnet</code> daemon is run from <code>launchd</code>. By default, the <code>telnet</code> daemon is disabled on Mac OS X (although it can be enabled with the <code>launchctl(1)</code> command). The preferred way to perform a network login on Mac OS X is with <code>ssh</code>, the secure shell command.</p>
<h4 id="linux-network-logins">Linux Network Logins</h4>
<p>Network logins under Linux are the same as under BSD, except that some distributions use an alternative <code>inetd</code> process called the extended Internet services daemon, <code>xinetd</code>. The <code>xinetd</code> process provides a finer level of control over services it starts compared to <code>inetd</code>.</p>
<h4 id="solaris-network-logins">Solaris Network Logins</h4>
<p>[p293]</p>
<h3 id="process-groups">Process Groups</h3>
<p>In addition to having a process ID, each process belongs to a <strong>process group</strong>.</p>
<ul>
<li>A process group is a collection of one or more processes (usually associated with the same job) that can receive signals from the same terminal.</li>
<li>Each process group has a unique process group ID. Process group IDs are similar to process IDs: they are positive integers and can be stored in a <code>pid_t</code> data type.</li>
</ul>
<p>The function <code>getpgrp</code> returns the process group ID of the calling process. The <code>getpgid</code> function took a <em>pid</em> argument and returned the process group for that process.</p>
<ul>
<li><a href="https://gist.github.com/shichao-an/08bcc3cf9a23ca95c00a">apue_getpgrp.h</a></li>
</ul>
<script src="https://gist.github.com/shichao-an/08bcc3cf9a23ca95c00a.js"></script>

<p>For <code>getpgid</code>, if <em>pid</em> is 0, the process group ID of the calling process is returned. Thus, </p>
<pre><code class="c">getpgid(0);
</code></pre>

<p>is equivalent to:</p>
<pre><code class="c">getpgrp();
</code></pre>

<p>Each process group can have a <strong>process group leader</strong>, whose process group ID equals to its process ID.</p>
<h4 id="process-group-lifetime">Process group lifetime</h4>
<p>The process group life time is the period of time that begins when the group is created and ends when the last remaining process leaves the group. It is possible for a process group leader to create a process group, create processes in the group, and then terminate. The process group still exists, as long as at least one process is in the group, regardless of whether the group leader terminates. The last remaining process in the process group can either terminate or enter some other process group.</p>
<h4 id="setpgid-function"><code>setpgid</code> function</h4>
<p>A process can join an existing process group or creates a new process group by calling <code>setpgid</code>.</p>
<ul>
<li><a href="https://gist.github.com/shichao-an/0b1832544be00d3a9490">apue_setpgid.h</a></li>
</ul>
<script src="https://gist.github.com/shichao-an/0b1832544be00d3a9490.js"></script>

<p>The <code>setpgid</code> function sets the process group ID of the process whose process ID equals <em>pid</em> to <em>pgid</em>.</p>
<p>Arguments:</p>
<ul>
<li>If <em>pid</em> == <em>pgid</em>, the process specified by <em>pid</em> becomes a process group leader.</li>
<li>If <em>pid</em> == 0, the process ID of the caller is used.</li>
<li>If <em>pgid</em> == 0, then the specified <em>pid</em> is used as the process group ID.</li>
</ul>
<p>Rules:</p>
<ul>
<li>A process can set the process group ID of only itself or any of its children.</li>
<li>A process cannot change the process group ID of one of its children after that child has called one of the <code>exec</code> functions.</li>
</ul>
<h5 id="job-control-shells">Job-control shells</h5>
<p>In most job-control shells, this function is called after a <code>fork</code> to have the parent set the process group ID of the child, and to have the child set its own process group ID. <u>One of these calls is redundant, but by doing both, we are guaranteed that the child is placed into its own process group before either process assumes that this has happened.  If we didn’t do this, we would have a race condition, since the child’s process group membership would depend on which process executes first.</u> (See <a href="##doubts-and-solutions">Doubts and Solutions</a> for details) [p294]</p>
<h5 id="process-groups-and-signals">Process groups and signals</h5>
<p>We can send a signal to either a single process (identified by its process ID) or a process group (identified by its process group ID). Similarly, the <code>waitpid</code> function lets us wait for either a single process or one process from a specified process group.</p>
<h3 id="sessions">Sessions</h3>
<p>A session is a collection of one or more process groups.</p>
<p><a href="../figure_9.6.png" title="Figure 9.6 Arrangement of processes into process groups and sessions"><img alt="Figure 9.6 Arrangement of processes into process groups and sessions" src="../figure_9.6_600.png" /></a></p>
<p>The processes in a process group are usually placed there by a shell pipeline. The arrangement in the figure above is generated by the shell commands of the form:</p>
<pre><code class="sh">proc1 | proc2 &amp;
proc3 | proc4 | proc5
</code></pre>

<h4 id="the-setsid-function">The <code>setsid</code> function</h4>
<p>A process establishes a new session by calling the <code>setsid</code> function.</p>
<ul>
<li><a href="https://gist.github.com/shichao-an/48edc52023515e0df704">apue_setsid.h</a></li>
</ul>
<script src="https://gist.github.com/shichao-an/48edc52023515e0df704.js"></script>

<p>If the calling process is not a process group leader, this function creates a new session. Three things happen:</p>
<ol>
<li>The process becomes the <strong>session leader</strong> of this new session. (A session leader is the process that creates a session.) The process is the only process in this new session</li>
<li>The process becomes the process group leader of a new process group. The new process group ID is the process ID of the calling process.</li>
<li>The process has no controlling terminal. If the process had a controlling terminal before calling <code>setsid</code>, that association is broken.</li>
</ol>
<p>This function returns an error if the caller is already a process group leader.</p>
<h4 id="ensuring-the-successful-call-of-setsid">Ensuring the successful call of <code>setsid</code></h4>
<p>Since the <code>setsid</code> function returns an error if the caller is a process group leader, to ensure this is not the case, the usual practice is to call <code>fork</code> and have the parent terminate and the child continue. It is guaranteed that the child is not a process group leader, because the process group ID of the parent is inherited by the child, but the child gets a new process ID. Hence, it is impossible for the child’s process ID to equal its inherited process group ID.</p>
<h4 id="session-leader-and-session-id">Session Leader and Session ID</h4>
<p>The Single UNIX Specification talks only about a "session leader"; there is no "session ID" similar to a process ID or a process group ID. A session leader is a single process that has a unique process ID, so we could talk about a session ID that is the process ID of the session leader. This concept of a session ID was introduced in SVR4.</p>
<h4 id="the-getsid-function">The <code>getsid</code> function</h4>
<p>The <code>getsid</code> function returns the process group ID of a process’s session leader.</p>
<ul>
<li><a href="https://gist.github.com/shichao-an/745eaee552865545e529">apue_getsid.h</a></li>
</ul>
<script src="https://gist.github.com/shichao-an/745eaee552865545e529.js"></script>

<p>If <em>pid</em> is 0, <code>getsid</code> returns the process group ID of the calling process’s session leader. For security reasons, some implementations may restrict the calling process from obtaining the process group ID of the session leader if <em>pid</em> doesn’t belong to the same session as the caller.</p>
<h3 id="controlling-terminal">Controlling Terminal</h3>
<p>Sessions and process groups have a few other characteristics.</p>
<ul>
<li>A session can have a single <strong>controlling terminal</strong>. This is usually the terminal device (in the case of a <a href="##terminal-logins">terminal login</a>) or pseudo terminal device (in the case of a <a href="#network-logins">network login</a>) on which we log in.</li>
<li>The session leader that establishes the connection to the controlling terminal is called the <strong>controlling process</strong>.</li>
<li>The process groups within a session can be divided into a single <strong>foreground process group</strong> and one or more <strong>background process groups</strong>.</li>
<li>If a session has a controlling terminal, it has a single foreground process group and all other process groups in the session are background process groups.</li>
<li>Whenever we press the terminal’s interrupt key (often DELETE or Control-C), the interrupt signal is sent to all processes in the foreground process group.</li>
<li>Whenever we press the terminal’s quit key (often Control-backslash), the quit signal is sent to all processes in the foreground process group.</li>
<li>If a modem (or network) disconnect is detected by the terminal interface, the hang-up signal is sent to the controlling process (the session leader).</li>
</ul>
<p>These characteristics are shown in the figure below:</p>
<p><a href="../figure_9.7.png" title="Figure 9.7 Process groups and sessions showing controlling terminal"><img alt="Figure 9.7 Process groups and sessions showing controlling terminal" src="../figure_9.7_600.png" /></a></p>
<p>Usually, the controlling terminal is established automatically when we log in.</p>
<h4 id="mechanisms-of-allocating-a-controlling-terminal">Mechanisms of allocating a controlling terminal</h4>
<h5 id="system-v">System V</h5>
<p>Systems derived from UNIX System V allocate the controlling terminal for a session when the session leader opens the first terminal device that is not already associated with a session, as long as the call to <code>open</code> does not specify the <code>O_NOCTTY</code> flag.</p>
<h5 id="bsd">BSD</h5>
<p>BSD-based systems allocate the controlling terminal for a session when the session leader calls <code>ioctl</code> with a request argument of <code>TIOCSCTTY</code> (the third argument is a null pointer). The session cannot already have a controlling terminal for this call to succeed. Normally, this call to <code>ioctl</code> follows a call to <code>setsid</code>, which guarantees that the process is a session leader without a controlling terminal.</p>
<p>Note that although Mac OS X 10.6.8 is derived from BSD, it behaves like System V when allocating a controlling terminal.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>FreeBSD 8.0</th>
<th>Linux 3.2.0</th>
<th>Mac OS X 10.6.8</th>
<th>Solaris 10</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>open</code> without <code>O_NOCTTY</code></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td><code>TIOCSCTTY</code> <code>ioctl</code> command</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>When a program wants to talk to the controlling terminal, regardless of whether the standard input or standard output is redirected, it can <code>open</code> the file <code>/dev/tty</code>. This special file is a synonym within the kernel for the controlling terminal. If the program doesn’t have a controlling terminal, the <code>open</code> of this device will fail.</p>
<p>The classic example is the <code>getpass(3)</code> function, which reads a password (with terminal echoing turned off, of course). [p298]</p>
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<p>p294 on <code>fork</code>'s race condition concerning <code>setpgid</code></p>
<blockquote>
<p>In most job-control shells, this function is called after a <code>fork</code> to have the parent set the process group ID of the child, and to have the child set its own process group ID. One of these calls is redundant, but by doing both, we are guaranteed that the child is placed into its own process group before either process assumes that this has happened.  If we didn’t do this, we would have a race condition, since the child’s process group membership would depend on which process executes first.</p>
</blockquote>
<p>Solution:</p>
<p>The shell (parent) wants and ensures the process to be in the right process group at any time before either of the child and parent continues execution.</p>
<ul>
<li><a href="http://stackoverflow.com/a/6026564/1751342">Stackoverflow</a></li>
<li><a href="http://www.gnu.org/software/libc/manual/html_node/Launching-Jobs.html#Launching-Jobs">Launching Jobs</a> in The GNU C Library</li>
</ul>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>