<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/lkd/ch12/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 12. Memory Management - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                        <li >
                            <a href="../ch5/">Chapter 5. System Calls</a>
                        </li>
                    
                        <li >
                            <a href="../ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                    
                        <li >
                            <a href="../ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 12. Memory Management</a>
                        </li>
                    
                        <li >
                            <a href="../ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../clrs/">CLRS</a>
                        </li>
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../asm/">x86 assembly</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/lkd/ch12.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-12-memory-management">Chapter 12. Memory Management</a></li>
        
    
        <li class="main "><a href="#page">Page</a></li>
        
    
        <li class="main "><a href="#zones">Zones</a></li>
        
    
        <li class="main "><a href="#getting-pages">Getting Pages</a></li>
        
            <li><a href="#getting-zeroed-pages">Getting Zeroed Pages</a></li>
        
            <li><a href="#freeing-pages">Freeing Pages</a></li>
        
    
        <li class="main "><a href="#kmalloc">kmalloc()</a></li>
        
            <li><a href="#gfp_mask-flags">gfp_mask Flags</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-12-memory-management"><strong>Chapter 12. Memory Management</strong></h3>
<p>Unlike user-space, the kernel is not always afforded the capability to easily allocate memory. This chapter discusses how the kernel handles memory and the methods used to obtain memory inside the kernel.</p>
<h3 id="page">Page</h3>
<p>To kernel, physical pages are the basic unit of memory management. Although the processor’s smallest addressable unit is a byte or a word, the <a href="https://en.wikipedia.org/wiki/Memory_management_unit">memory management unit</a> (MMU, the hardware that manages memory and performs virtual to physical address translations) typically deals in pages. Therefore, the MMU maintains the system’s page tables with page-sized granularity. In terms of virtual memory, pages are the smallest unit.</p>
<p>Each architecture defines its own page size. Many architectures even support multiple page sizes.</p>
<ul>
<li>Most 32-bit architectures have 4KB pages;</li>
<li>Most 64-bit architectures have 8KB pages.</li>
</ul>
<p>This implies that on a machine with 4KB pages and 1GB of memory, physical memory is divided into 262,144 distinct pages.</p>
<p>The kernel represents every physical page on the system with a <code>struct page</code> structure.  This structure is defined in <code>&lt;linux/mm_types.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mm_types.h">include/linux/mm_types.h</a>). The following is a simplified the definition (two confusing unions are removed):</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mm_types.h#L34">include/linux/mm_types.h#L34</a></small></p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">page</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">atomic_t</span> <span class="n">_count</span><span class="p">;</span>
    <span class="kt">atomic_t</span> <span class="n">_mapcount</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
    <span class="kt">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">virtual</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<ul>
<li>The <code>flags</code> field stores the status of the page, such as whether the page is dirty or whether it is locked in memory. Bit flags represent the various values, so at least 32 different flags are simultaneously available. The flag values are defined in <code>&lt;linux/page-flags.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/page-flags.h">include/linux/page-flags.h</a>).</li>
<li>The <code>_count</code> field stores the usage count of the page: how many references there are to this page.<ul>
<li>If <code>_count</code>'s value is negative one (-1) indicates that no one is using the page, and it becomes available for use in a new allocation.</li>
<li>Kernel code should not check this field directly but instead use the function <code>page_count()</code>, which takes a page structure as its sole parameter. <code>page_count()</code> returns zero to indicate free and a positive nonzero integer when the page is in use.</li>
<li>A page may be used by the page cache (in which case the <code>mapping</code> field points to the <code>address_space</code> object associated with this page), as private data (pointed at by <code>private</code>), or as a mapping in a process’s page table.</li>
</ul>
</li>
<li>The <code>virtual</code> field is the page’s virtual address. Normally, this is simply the address of the page in virtual memory.<ul>
<li>Some memory (called high memory) is not permanently mapped in the kernel’s address space. In that case, this field is <code>NULL</code>, and the page must be dynamically mapped if needed.</li>
</ul>
</li>
</ul>
<p>The <code>page</code> structure is associated with physical pages, not virtual pages; what the structure describes is transient at best. Even if the data contained in the page continues to exist, it might not always be associated with the same <code>page</code> structure because of swapping and so on. <u>The kernel uses this data structure to describe the associated physical page. The data structure’s goal is to describe physical memory, not the data contained therein.</u></p>
<p>The kernel uses this structure to keep track of all the pages in the system, because the kernel needs to know whether a page is free (whether the page is not allocated). If a page is not free, the kernel needs to know who owns the page. Possible owners include (but not limited to):</p>
<ul>
<li>User-space processes,</li>
<li>Dynamically allocated kernel data,</li>
<li>Static kernel code,</li>
<li>Page cache.</li>
</ul>
<p>Since an instance of this structure is allocated for each physical page in the system. How bad (or good) the space consumption is from all these pages?  Assume <code>struct page</code> consumes 40 bytes of memory, the system has 8KB physical pages, and the system has 4GB of physical memory. In that case, there are about 524,288 pages and page structures on the system. The page structures consume 20MB: perhaps a surprisingly large number in absolute terms, but only a small fraction of a percent relative to the system’s 4GB. This is not too high a cost for managing all the system’s physical pages.</p>
<h3 id="zones">Zones</h3>
<p>The kernel cannot treat all pages as identical due to hardware limitations. Some pages, because of their physical address in memory, cannot be used for certain tasks. Thus, the kernel divides pages into different <em>zones</em>. The kernel uses the zones to group pages of similar properties.</p>
<p>Linux has to deal with two shortcomings of hardware with respect to memory addressing:</p>
<ul>
<li>Some hardware devices can perform <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> (direct memory access) to only certain memory addresses.</li>
<li>Some architectures can physically addressing larger amounts of memory than they can virtually address. Consequently, some memory is not permanently mapped into the kernel address space.</li>
</ul>
<p>Due to these contraints, Linux has four primary memory zones:</p>
<ul>
<li><code>ZONE_DMA</code>. This zone contains pages that can undergo DMA.</li>
<li><code>ZONE_DMA32</code>. Like ZOME_DMA, this zone contains pages that can undergo DMA. Unlike <code>ZONE_DMA</code>, these pages are accessible only by 32-bit devices. On some architectures, this zone is a larger subset of memory.</li>
<li><code>ZONE_NORMAL</code>. This zone contains normal, regularly mapped, pages.</li>
<li><code>ZONE_HIGHMEM</code>. This zone contains "high memory", which are pages not permanently mapped into the kernel’s address space.</li>
</ul>
<p>These zones are defined in <code>&lt;linux/mmzone.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mmzone.h">include/linux/mmzone.h</a>)</p>
<p>The layout of the memory zones is architecture-dependent. For example:</p>
<ul>
<li>Some architectures can perform DMA into any memory address. In those architectures, <code>ZONE_DMA</code> is empty and <code>ZONE_NORMAL</code> is used for allocations regardless of their use.</li>
<li>On the x86 architecture, <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a> devices cannot perform DMA into the full 32-bit address space1 because ISA devices can access only the first 16MB of physical memory. Consequently, <code>ZONE_DMA</code> on x86 consists of all memory in the range 0MB–16MB.</li>
</ul>
<p><code>ZONE_HIGHMEM</code> works similarly. On 32-bit x86 systems, <code>ZONE_HIGHMEM</code> is all memory above the physical 896MB mark. On other architectures, <code>ZONE_HIGHMEM</code> is empty because all memory is directly mapped. The memory contained in <code>ZONE_HIGHMEM</code> is called <strong>high memory</strong>. The rest of the system’s memory is called <strong>low memory</strong>.</p>
<p><code>ZONE_NORMAL</code> is the remainder after the previous two zones claim their requisite shares. On x86, <code>ZONE_NORMAL</code> is all physical memory from 16MB to 896MB. On other architectures, <code>ZONE_NORMAL</code> is all available memory.</p>
<p>The following table is a listing of each zone and its consumed pages on x86-32.</p>
<table>
<thead>
<tr>
<th>Zone</th>
<th>Description</th>
<th>Physical Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ZONE_DMA</code></td>
<td>DMA-able pages</td>
<td>&lt; 16MB</td>
</tr>
<tr>
<td><code>ZONE_NORMAL</code></td>
<td>Normally addressable pages</td>
<td>16–896MB</td>
</tr>
<tr>
<td><code>ZONE_HIGHMEM</code></td>
<td>Dynamically mapped pages</td>
<td>&gt; 896MB</td>
</tr>
</tbody>
</table>
<p>Linux partitions pages into zones to have a pooling in place to satisfy allocations as needed. For example, with a <code>ZONE_DMA</code> pool, the kernel has the capability to satisfy memory allocations needed for DMA. If such memory is needed, the kernel can simply pull the required number of pages from <code>ZONE_DMA</code>. The zones do not have any physical relevance but are simply logical groupings used by the kernel to keep track of pages.</p>
<p>Although some allocations may require pages from a particular zone, other allocations may pull from multiple zones. For example:</p>
<ul>
<li>An allocation for DMA-able memory must originate from <code>ZONE_DMA</code></li>
<li>A normal allocation can come from <code>ZONE_DMA</code> or <code>ZONE_NORMAL</code> but not both; allocations cannot cross zone boundaries. The kernel prefers to satisfy normal allocations from the normal zone to save the pages in <code>ZONE_DMA</code> for allocations that need it. [p234]</li>
</ul>
<p>Not all architectures define all zones. For example, a 64-bit architecture such as Intel’s x86-64 can fully map and handle 64-bits of memory.Thus, x86-64 has no <code>ZONE_HIGHMEM</code> and all physical memory is contained within <code>ZONE_DMA</code> and <code>ZONE_NORMAL</code>.</p>
<p>Each zone is represented by struct zone, which is defined in <code>&lt;linux/mmzone.h&gt;</code>:</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/mmzone.h#L280">include/linux/mmzone.h#L280</a></small></p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">zone</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">watermark</span><span class="p">[</span><span class="n">NR_WMARK</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lowmem_reserve</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">per_cpu_pageset</span> <span class="n">pageset</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
    <span class="kt">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">free_area</span> <span class="n">free_area</span><span class="p">[</span><span class="n">MAX_ORDER</span><span class="p">]</span>
    <span class="kt">spinlock_t</span> <span class="n">lru_lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zone_lru</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_saved_scan</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">lru</span><span class="p">[</span><span class="n">NR_LRU_LISTS</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">zone_reclaim_stat</span> <span class="n">reclaim_stat</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_scanned</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">atomic_long_t</span> <span class="n">vm_stat</span><span class="p">[</span><span class="n">NR_VM_ZONE_STAT_ITEMS</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">prev_priority</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inactive_ratio</span><span class="p">;</span>
    <span class="kt">wait_queue_head_t</span> <span class="o">*</span><span class="n">wait_table</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_hash_nr_entries</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_bits</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">zone_pgdat</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_start_pfn</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spanned_pages</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">present_pages</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<ul>
<li>The <code>lock</code> field is a spin lock that protects the structure from concurrent access. It protects just the structure and not all the pages that reside in the zone. A specific lock does not protect individual pages, although parts of the kernel may lock the data that happens to reside in said pages.</li>
<li>The <code>watermark</code> array holds the minimum, low, and high watermarks for this zone. The kernel uses watermarks to set benchmarks for suitable per-zone memory consumption. [p235]</li>
<li>The <code>name</code> field is a NULL-terminated string representing the name of this zone. The kernel initializes this value during boot in <a href="https://github.com/shichao-an/linux/blob/v2.6.34/mm/page_alloc.c">mm/page_alloc.c</a>, and the three zones are given the names DMA, Normal, and HighMem.</li>
</ul>
<h3 id="getting-pages">Getting Pages</h3>
<p>This section discusses the interfaces the kernel implements to enable you to allocate and free memory within the kernel.</p>
<p>The kernel provides one low-level mechanism for requesting memory, along with several interfaces to access it. All these interfaces allocate memory with page-sized granularity and are declared in <code>&lt;linux/gfp.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/gfp.h">include/linux/gfp.h</a>). The core function is:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="kt">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
</pre></div>


<p>This allocates 2<sup>order</sup> (<code>1 &lt;&lt; order</code>) contiguous physical pages and returns a pointer to the first page’s <code>page</code> structure; on error it returns <code>NULL</code>.</p>
<p>You can convert a given page to its logical address with the function:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span> <span class="n">page_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
</pre></div>


<p>This returns a pointer to the logical address where the given physical page currently resides.</p>
<p>If you have no need for the actual <code>struct page</code>, you can call:</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="kt">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
</pre></div>


<p>This function works the same as <code>alloc_pages()</code>, except that it directly returns the logical address of the first requested page. Because the pages are contiguous, the other pages simply follow from the first.</p>
<p>If you need only one page, two functions are implemented as wrappers to save you a bit of typing:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">alloc_page</span><span class="p">(</span><span class="kt">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="kt">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
</pre></div>


<p>These functions work the same but pass zero for the order (2<sup>0</sup> = one page).</p>
<h4 id="getting-zeroed-pages">Getting Zeroed Pages</h4>
<p>If you need the returned page filled with zeros, use the function:</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gfp_mask</span><span class="p">)</span>
</pre></div>


<p>This function works the same as <code>__get_free_page()</code>, except that the allocated page is then zero-filled (every bit of every byte is unset). This is useful for pages given to userspace because the random garbage in an allocated page is not so random; it might contain sensitive data. All data must be zeroed or otherwise cleaned before it is returned to userspace to ensure system security is not compromised.</p>
<p>The following table is a listing of all the low-level page allocation methods.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alloc_page(gfp_mask)</code></td>
<td>Allocates a single page and returns a pointer to its first page’s <code>page</code> structure</td>
</tr>
<tr>
<td><code>alloc_pages(gfp_mask, order)</code></td>
<td>Allocates 2<sup>order</sup> pages and returns a pointer to the first page’s <code>page</code> structure</td>
</tr>
<tr>
<td><code>__get_free_page(gfp_mask)</code></td>
<td>Allocates a single page and returns a pointer to its logical address</td>
</tr>
<tr>
<td><code>__get_free_pages(gfp_mask, order)</code></td>
<td>Allocates 2<sup>order</sup> pages and returns a pointer to the first page’s logical address</td>
</tr>
<tr>
<td><code>get_zeroed_page(gfp_mask)</code></td>
<td>Allocates a single page, zero its contents and returns a pointer to its logical address</td>
</tr>
</tbody>
</table>
<h4 id="freeing-pages">Freeing Pages</h4>
<p>A family of functions enables you to free allocated pages when you no longer need them:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">__free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">free_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">free_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
</pre></div>


<p>Be careful to free only pages you allocate. Passing the wrong <code>struct page</code> or address, or the incorrect order, can result in corruption. [p237]</p>
<p>For example, we want to allocate eight pages:</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
<span class="n">page</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* insufficient memory: you must handle this error! */</span>
    <span class="k">return</span> <span class="err">–</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* &#39;page&#39; is now the address of the first of eight contiguous pages ... */</span>
</pre></div>


<p>Free the eight pages, after we are done using them:</p>
<div class="codehilite"><pre><span class="n">free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">* our pages are now freed and we should no</span>
<span class="cm">* longer access the address stored in &#39;page&#39;</span>
<span class="cm">*/</span>
</pre></div>


<p>The <code>GFP_KERNEL</code> parameter is an example of a <code>gfp_mask</code> flag (discussed shortly).</p>
<p>A kernel allocation can fail, and your code must check for and handle such errors after the call to <code>__get_free_pages()</code>. <u>It therefore often makes sense to allocate your memory at the start of the routine to make handling the error easier.</u> [p237]</p>
<p>These low-level page functions are useful when you need page-sized chunks of physically contiguous pages, especially if you need exactly a single page or two. For more general byte-sized allocations, the kernel provides <code>kmalloc()</code>.</p>
<h3 id="kmalloc"><code>kmalloc()</code></h3>
<p>The <code>kmalloc()</code> function is similar to user-space’s <code>malloc()</code>, with the exception of the additional flags parameter. The <code>kmalloc()</code> function is a simple interface for obtaining kernel memory in byte-sized chunks. If you need whole pages, the previously discussed interfaces might be a better choice. For most kernel allocations, <code>kmalloc()</code> is the preferred interface.</p>
<p>The function is declared in <code>&lt;linux/slab.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab.h">include/linux/slab.h</a>):</p>
<p><small><a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/slab_def.h#L128">include/linux/slab_def.h#L128</a></small></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span> <span class="n">kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
</pre></div>


<p>The <code>kmalloc()</code> function returns a pointer to a region of memory that is at least <code>size</code> bytes in length. It may allocate more than you asked, although you have no way of knowing how much more. Because the kernel allocator is page-based, some allocations may be rounded up to fit within the available memory. The kernel never returns less memory than requested. If the kernel is unable to find at least the requested amount, the allocation fails and the function returns <code>NULL</code>. The region of memory allocated is physically contiguous. Kernel allocations always succeed, unless an insufficient amount of memory is available. Thus, you must check for <code>NULL</code> after all calls to <code>kmalloc()</code> and handle the error appropriately.</p>
<p>For example:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">dog</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dog</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
    <span class="cm">/* handle error ... */</span>
</pre></div>


<p>If the <code>kmalloc()</code> call succeeds, <code>p</code> now points to a block of memory that is at least the requested size.The <code>GFP_KERNEL</code> flag specifies the behavior of the memory allocator while trying to obtain the memory to return to the caller of <code>kmalloc()</code>.</p>
<h4 id="gfp_mask-flags"><code>gfp_mask</code> Flags</h4>
<p>Flags are represented by the <code>gfp_t</code> type, which is defined in <code>&lt;linux/types.h&gt;</code> (<a href="https://github.com/shichao-an/linux/blob/v2.6.34/include/linux/types.h#L179">include/linux/types.h#L179</a>) as an <code>unsigned int</code>. <em>gfp</em> stands for <code>__get_free_pages()</code> (discussed earlier).</p>
<p>The flags are broken up into three categories:</p>
<ul>
<li><strong>Action modifiers</strong> specify how the kernel is supposed to allocate the requested memory. In certain situations, only certain methods can be employed to allocate memory. For example, interrupt handlers must instruct the kernel not to sleep (because interrupt handlers cannot reschedule) in the course of allocating memory.</li>
</ul>
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<p>p235 on zones:</p>
<blockquote>
<p>A specific lock does not protect individual pages, although parts of the kernel may lock the data that happens to reside in said pages.</p>
</blockquote>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>