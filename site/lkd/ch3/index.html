<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/lkd/ch3/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 3. Process Management - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 3. Process Management</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="https://github.com/shichao-an/notes">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-3-process-management">Chapter 3. Process Management</a></li>
        
    
        <li class="main "><a href="#the-process">The Process</a></li>
        
            <li><a href="#threads-of-execution">Threads of execution</a></li>
        
            <li><a href="#virtualized-processor-and-virtual-memory">Virtualized processor and virtual memory</a></li>
        
            <li><a href="#life-of-a-process">Life of a process</a></li>
        
            <li><a href="#fork-exec-exit-and-wait">fork, exec, exit and wait</a></li>
        
    
        <li class="main "><a href="#process-descriptor-and-the-task-structure">Process Descriptor and the Task Structure</a></li>
        
            <li><a href="#allocating-the-process-descriptor">Allocating the Process Descriptor</a></li>
        
            <li><a href="#storing-the-process-descriptor">Storing the Process Descriptor</a></li>
        
            <li><a href="#process-state">Process State</a></li>
        
            <li><a href="#manipulating-the-current-process-state">Manipulating the Current Process State</a></li>
        
            <li><a href="#process-context">Process Context</a></li>
        
            <li><a href="#the-process-family-tree">The Process Family Tree</a></li>
        
    
        <li class="main "><a href="#process-creation">Process Creation</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h3 id="chapter-3-process-management"><strong>Chapter 3. Process Management</strong></h3>
<p>This chapter introduces the concept of the <strong>process</strong>. The process management is a crucial part of any operating system kernel, including Linux. </p>
<h3 id="the-process">The Process</h3>
<p>A process is a program (object code stored on some media) in the midst of execution.</p>
<p>Besides the executing program code (<em>text section</em> in Unix), processes also include a set of resources:</p>
<ul>
<li>Open files </li>
<li>Pending signals</li>
<li>Internal kernel data</li>
<li>Processor state</li>
<li>Memory address space with one or more memory mappings</li>
<li><strong>Thread(s) of execution</strong></li>
<li>Data section containing global variables</li>
</ul>
<h4 id="threads-of-execution">Threads of execution</h4>
<p>Threads of execution, often shortened to <strong>threads</strong>,  are the objects of activity within the process.</p>
<p>Each thread includes:</p>
<ul>
<li>Program counter</li>
<li>Process stack</li>
<li>Set of processor registers</li>
</ul>
<p>The kernel schedules individual threads, not processes. <u>Linux does not differentiate between threads and processes. To Linux, a thread is just a special kind of process.</u></p>
<h4 id="virtualized-processor-and-virtual-memory">Virtualized processor and virtual memory</h4>
<p>On modern operating systems, processes provide two virtualizations: a <strong>virtualized processor</strong> and <strong>virtual memory</strong>.</p>
<ul>
<li>The virtual processor gives the process the illusion that it alone monopolizes the system, despite possibly sharing the processor among hundreds of other processes. See <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>.</li>
<li>Virtual memory lets the process allocate and manage memory as if it alone owned all the memory in the system. See <a href="../../lkd/ch12/">Chapter 12. Memory Management</a></li>
</ul>
<p><u>Threads share the virtual memory abstraction</u>, whereas each receives its own virtualized processor.</p>
<h4 id="life-of-a-process">Life of a process</h4>
<p>A process is an active program and related resources:</p>
<ul>
<li>Two or more processes can exist that are executing the <em>same</em> program.</li>
<li>Two or more processes can exist that share various resources, such as open files or an address space.</li>
</ul>
<h4 id="fork-exec-exit-and-wait">fork, exec, exit and wait</h4>
<p>In Linux, the <code>fork()</code> system call creates a new process by duplicating an existing one.</p>
<ul>
<li>The process that calls <code>fork()</code> is the parent, whereas the new process is the child.</li>
<li>The parent resumes execution and the child starts execution at the same place: where the call to <code>fork()</code> returns.</li>
<li>The <code>fork()</code> system call <u>returns from the kernel twice: once in the parent process and again in the newborn child.</u></li>
</ul>
<p>The <code>exec()</code> family of function calls creates a new address space and loads a new program into the newborn child immediately after a fork. In contemporary Linux kernels, <u><code>fork()</code> is actually implemented via the <code>clone()</code> system call</u>, which is discussed in a following section.  </p>
<p>The <code>exit()</code> system call terminates the process and frees all its resources. A parent process can inquire about the status of a terminated child via the <code>wait4()</code> system call. A process can wait for the termination of a specific process. <u>When a process exits, it is placed into a special zombie state that represents terminated processes until the parent calls <code>wait()</code> or <code>waitpid()</code>.</u> The kernel implements the <code>wait4()</code> system call. Linux systems, via the C library, typically provide the <code>wait()</code>, <code>waitpid()</code>, <code>wait3()</code>, and <code>wait4()</code> functions.</p>
<h3 id="process-descriptor-and-the-task-structure">Process Descriptor and the Task Structure</h3>
<p>Another name for a process is a <strong>task</strong>. The Linux kernel internally refers to processes as tasks. In this book, the terms are used interchangeably, though <u>"task" generally refers to a process from the kernel’s point of view.</u></p>
<p>The kernel stores the list of processes in a circular doubly linked list called the <strong>task list</strong>.</p>
<p>A <strong>process descriptor</strong> of the type <code>struct task_struct</code> (defined in <code>&lt;linux/sched.h&gt;</code>) is an element in the task list. It contains all the information about a specific process.</p>
<p>The <code>task_struct</code> is a relatively large data structure, at around 1.7 kilobytes on a 32-bit machine. The process descriptor contains the data that describes the executing program: open files, the process’s address space, pending signals, the process’s state, etc. See the figure below.</p>
<p><a href="../figure_3.1.png" title="Figure 3.1 The process descriptor and task list."><img alt="Figure 3.1 The process descriptor and task list." src="../figure_3.1.png" /></a></p>
<h4 id="allocating-the-process-descriptor">Allocating the Process Descriptor</h4>
<p>The <code>task_struct</code> structure is allocated via the <strong>slab allocator</strong> to provide object reuse and cache coloring (see <a href="../../lkd/ch12/">Chapter 12</a>). The structure <code>struct thread_info</code> lives at the bottom of the stack (for stacks that grow down) and at the top of the stack (for stacks that grow up)</p>
<p><a href="../figure_3.2.png" title="Figure 3.2 The process descriptor and kernel stack."><img alt="Figure 3.2 The process descriptor and kernel stack." src="../figure_3.2.png" /></a></p>
<p><a href="http://www.crashcourse.ca/wiki/index.php/Updates_to_LKD3#Figure_3.2_.28p._26.29">Errata</a>: "struct thread_struct" should read "struct thread_info"</p>
<p>The <code>thread_info</code> structure is defined on x86 in <code>&lt;asm/thread_info.h&gt;</code> (see below code). Each task’s <code>thread_info</code> structure is allocated at the end of its stack.The task element of the structure is a pointer to the task’s actual <code>task_struct</code>:</p>
<ul>
<li><a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/arch/x86/include/asm/thread_info.h#L26">arch/x86/include/asm/thread_info.h</a></li>
</ul>
<pre><code class="c">struct thread_info {
    struct task_struct *task;
    struct exec_domain *exec_domain;
    __u32 flags;
    __u32 status;
    __u32 cpu;
    int preempt_count;
    mm_segment_t addr_limit;
    struct restart_block restart_block;
    void *sysenter_return;
    int uaccess_err;
};
</code></pre>

<h4 id="storing-the-process-descriptor">Storing the Process Descriptor</h4>
<p>The <strong>process identification</strong> (PID) is numerical value, represented by the <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque type</a> <code>pid_t</code> (typically <code>int</code>), for the system to identify processes. The default maximum value is only 32,768 (that of a <code>short int</code>), although the value optionally can be increased as high as four million (this is controlled in <code>&lt;linux/threads.h&gt;</code>). The kernel stores this value as <code>pid</code> inside each process descriptor. [p26]</p>
<p>Large servers may require many more than 32,768 (maximum value) processes. <u>The lower the value, the sooner the values will wrap around, destroying the useful notion that higher values indicate later-run processes than lower values.</u> The administrator may increase the maximum value via <code>/proc/sys/kernel/pid_max</code>.</p>
<p>Inside the kernel, tasks are typically referenced directly by a pointer to their <code>task_struct</code> structure. In fact, most kernel code that deals with processes works directly with <code>struct task_struct</code>. Consequently, it is useful to be able to quickly look up the process descriptor of the currently executing task, which is done via the <code>current</code> macro. This macro must be independently implemented by each architecture:</p>
<ul>
<li>Some architectures save a pointer to the <code>task_struct</code> structure of the currently running process in a register, enabling for efficient access. </li>
<li>Other architectures, such as x86 (which has few registers to waste), make use of the fact that struct <code>thread_info</code> is stored on the kernel stack to calculate the location of <code>thread_info</code> and subsequently the <code>task_struct</code>.</li>
</ul>
<h5 id="the-current_thread_info-function">The <code>current_thread_info()</code> function</h5>
<p>On x86, <code>current</code> is calculated by masking out the 13 least-significant bits of the stack pointer to obtain the <code>thread_info</code> structure. This is done by the <code>current_thread_info()</code> function (<a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/arch/x86/include/asm/thread_info.h#L184">arch/x86/include/asm/thread_info.h#L184</a>). The assembly is shown here:</p>
<pre><code class="nasm">movl $-8192, %eax
andl %esp, %eax
</code></pre>

<p>This assumes that the stack size is 8KB. When 4KB stacks are enabled, 4096 is used in lieu of 8192.</p>
<p><code>current</code> dereferences the task member of <code>thread_info</code> to return the <code>task_struct</code>:</p>
<ul>
<li><a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/include/asm-generic/current.h">include/asm-generic/current.h</a></li>
</ul>
<pre><code class="c">current_thread_info()-&gt;task;
</code></pre>

<h4 id="process-state">Process State</h4>
<p>The <code>state</code> field of the process descriptor describes the current condition of the process.</p>
<p><a href="../figure_3.3.png" title="Figure 3.3 Flow chart of process states."><img alt="Figure 3.3 Flow chart of process states." src="../figure_3.3_600.png" /></a></p>
<p>Each process on the system is in exactly one of five different states. This value is represented by one of five flags:</p>
<ul>
<li><code>TASK_RUNNING</code>: The process is runnable; it is either currently running or on a runqueue waiting to run. This is the only possible state for a process executing in user-space; it can also apply to a process in kernel-space that is actively running.</li>
<li><code>TASK_INTERRUPTIBLE</code>: The process is sleeping (blocked), waiting for some condition to exist. The process also awakes prematurely and becomes runnable if it receives a signal.</li>
<li><code>TASK_UNINTERRUPTIBLE</code>: This state is identical to <code>TASK_INTERRUPTIBLE</code> except that it does not wake up and become runnable if it receives a signal. This is used in situations where the process must wait without interruption or when the event is expected to occur quite quickly. Because the task does not respond to signals in this state, <code>TASK_UNINTERRUPTIBLE</code> is less often used than <code>TASK_INTERRUPTIBLE</code>.</li>
<li><code>__TASK_TRACED</code>: The process is being traced by another process, such as a debugger, via <strong>ptrace</strong>.</li>
<li><code>__TASK_STOPPED</code>: Process execution has stopped; the task is not running nor is it eligible to run. This occurs if the task receives the <code>SIGSTOP</code>, <code>SIGTSTP</code>, <code>SIGTTIN</code>, or <code>SIGTTOU</code> signal or if it receives any signal while it is being debugged.</li>
</ul>
<h4 id="manipulating-the-current-process-state">Manipulating the Current Process State</h4>
<p>Kernel code often needs to change a process’s state. The preferred mechanism is using:</p>
<pre><code class="c">set_task_state(task, state); /* set task ‘task’ to state ‘state’ */
</code></pre>

<p>This function sets the given task to the given state. If applicable, it also provides a memory barrier to force ordering on other processors (only needed on SMP systems). Otherwise, it is equivalent to:</p>
<pre><code class="c">task-&gt;state = state;
</code></pre>

<p>The method <code>set_current_state(state)</code> is synonymous to <code>set_task_state(current, state)</code>. See <code>&lt;linux/sched.h&gt;</code> for the implementation of these and related functions.</p>
<ul>
<li><a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/include/linux/sched.h#L226">include/linux/sched.h#L226</a></li>
</ul>
<h4 id="process-context">Process Context</h4>
<p>The program code is read in from an <strong>executable file</strong> and executed within the program’s address space.</p>
<ul>
<li><strong>User-space</strong>: Normal program execution occurs in user-space.</li>
<li><strong>Kernel-space</strong>: When a program executes a system call or triggers an exception, it enters kernel-space. At this point, the kernel is said to be "executing on behalf of the process" and is in <strong>process context</strong>. When in process context, the <code>current</code> macro is valid.<ul>
<li>Other than process context there is <strong>interrupt context</strong> (discussed in <a href="../../lkd/ch7/">Chapter 7</a>. In interrupt context, the system is not running on behalf of a process but is executing an interrupt handler. No process is tied to interrupt handlers.</li>
</ul>
</li>
</ul>
<p>Upon exiting the kernel, the process resumes execution in user-space, unless a higher-priority process has become runnable in the interim, in which case the scheduler is invoked to select the higher priority process.</p>
<p>A process can begin executing in kernel-space only through one of the following well-defined interfaces:</p>
<ul>
<li>System calls</li>
<li>Exception handlers</li>
</ul>
<h4 id="the-process-family-tree">The Process Family Tree</h4>
<p>All processes are descendants of the <code>init</code> process (PID 1). The kernel starts init in the last step of the boot process. The init process reads the system <strong>initscripts</strong> and executes more programs, eventually completing the boot process.</p>
<ul>
<li>Every process on the system has exactly one <strong>parent</strong>.</li>
<li>Every process has zero or more <strong>children</strong>.</li>
<li>Processes that are all direct children of the same parent are called <strong>siblings</strong>.</li>
</ul>
<hr />
<p>[UTLK p87-88]</p>
<p>The pointers (<code>next</code> and <code>prev</code>) in a <code>list_head</code> field store the addresses of other <code>list_head</code> fields rather than the addresses of the whole data structures in which the <code>list_head</code> structure is included. See figure below: </p>
<p><a href="../../utlk/figure_3-3.png" title="Figure 3-3. Doubly linked lists built with list_head data structures"><img alt="Figure 3-3. Doubly linked lists built with list_head data structures" src="../../utlk/figure_3-3_600.png" /></a></p>
<ul>
<li><a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/include/linux/list.h">include/linux/list.h</a></li>
</ul>
<hr />
<p>The relationship between processes is stored in the process descriptor.</p>
<p>Each <code>task_struct</code> (<a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/include/linux/sched.h#L1170">include/linux/sched.h#L1170</a>) has:</p>
<ul>
<li><code>parent</code>: pointer to the parent's <code>task_struct</code></li>
<li><code>children</code>: list of children (<code>struct list_head</code>)</li>
</ul>
<p>To obtain the process descriptor of a given process's parent:</p>
<pre><code class="c">struct task_struct *my_parent = current-&gt;parent;
</code></pre>

<p>To iterate over a process’s children:</p>
<pre><code class="c">struct task_struct *task;
struct list_head *list;

list_for_each(list, &amp;current-&gt;children) {
    task = list_entry(list, struct task_struct, sibling);
    /* task now points to one of current’s children */
}
</code></pre>

<ul>
<li><code>list_for_each</code>: <a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/include/linux/list.h#L367">include/linux/list.h#L367</a></li>
</ul>
<p>The <code>init</code> task’s process descriptor is statically allocated as <code>init_task</code>. The following code will always succeed:</p>
<pre><code class="c">struct task_struct *task;

for (task = current; task != &amp;init_task; task = task-&gt;parent)
;
/* task now points to init */
</code></pre>

<p>You can follow the process hierarchy from any one process in the system to any other.  Oftentimes, it is desirable simply to iterate over all processes in the system. This is easy because the task list is a circular, doubly linked list.</p>
<p>To obtain the next task in the list, given any valid task, use:</p>
<pre><code class="c">list_entry(task-&gt;tasks.next, struct task_struct, tasks)
</code></pre>

<p>To obtain the previous task works the same way:</p>
<pre><code class="c">list_entry(task-&gt;tasks.prev, struct task_struct, tasks)
</code></pre>

<ul>
<li><code>list_entry</code>: <a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/include/linux/list.h#L348">include/linux/list.h</a></li>
</ul>
<p>These two routines are provided by the macros <code>next_task(task)</code> and <code>prev_task(task)</code>. (See <a href="">Doubts and Solutions</a>)</p>
<p>The macro <code>for_each_process(task)</code> iterates over the entire task list. On each iteration, task points to the next task in the list:</p>
<pre><code class="c">struct task_struct *task;

for_each_process(task) {
    /* this pointlessly prints the name and PID of each task */
    printk(“%s[%d]\n”, task-&gt;comm, task-&gt;pid);
}
</code></pre>

<ul>
<li><code>for_each_process</code>: <a href="https://github.com/shichao-an/linux-2.6.34.7/blob/master/include/linux/sched.h#L2139">include/linux/sched.h#L2139</a></li>
</ul>
<p>It is expensive to iterate over every task in a system with many processes; code should have good reason (and no alternative) before doing so.</p>
<h3 id="process-creation">Process Creation</h3>
<p>Most operating systems implement a <strong>spawn</strong> mechanism to create a new process in a new address space, read in an executable, and begin executing it. Unix separates these steps into two distinct functions: <code>fork()</code> and <code>exec()</code>.</p>
<ul>
<li><code>fork()</code>: creates a child process that is a copy of the current task. It differs from the parent only in its PID, its PPID (parent’s PID), and certain resources and statistics (e.g. pending signals) which are not inherited</li>
</ul>
<hr />
<h3 id="doubts-and-solutions">Doubts and Solutions</h3>
<h4 id="verbatim">Verbatim</h4>
<blockquote>
<p>These two routines are provided by the macros <code>next_task(task)</code> and <code>prev_task(task)</code>, respectively.</p>
</blockquote>
<p>I didn't find any relevant appearance for <code>prev_task</code> macro in the <a href="https://github.com/shichao-an/linux-2.6.34.7">Linux 2.6.34.7 source code</a>.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
    </body>
</html>