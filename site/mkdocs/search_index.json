{
    "docs": [
        {
            "location": "/", 
            "text": "Shichao's Notes\n\n\nThis site documents reading and learning notes of the following books and materials.\n\n\n\n  \n\n    \n\n      (function() {\n        var cx = '000491777875727507539:_gc3mx7cstg';\n        var gcse = document.createElement('script');\n        gcse.type = 'text/javascript';\n        gcse.async = true;\n        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +\n            '//cse.google.com/cse.js?cx=' + cx;\n        var s = document.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(gcse, s);\n      })();\n    \n\n    \n\n  \n\n\n\n\n\nReading Notes\n\n\nEach chapter is organized as a single page; the included sections are noted with major concepts, along with personal doubts (with possible solutions figured out afterwards) and summary.\n\n\nAdvanced Programming in the UNIX Environment, 3rd Edition\n\n\nby W. Richard Stevens and Stephen A. Rago\n\n\n\n\nUNIX System Overview\n\n\nUNIX Standardization and Implementations\n\n\nFile I/O\n\n\nFiles and Directories\n\n\nStandard I/O Library\n\n\nSystem Data Files and Information\n\n\nProcess Environment\n\n\nProcess Control\n\n\nProcess Relationships\n\n\nSignals\n\n\n\n\nUnderstanding the Linux Kernel, Third Edition\n\n\nby Daniel P. Bovet and Marco Cesati\n\n\n\n\nIntroduction\n\n\nMemory Addressing\n\n\n\n\nLinux Kernel Development (3rd Edition)\n\n\nby Robert Love\n\n\n\n\nIntroduction to the Linux Kernel\n\n\nGetting Started with the Kernel\n\n\nProcess Management\n\n\nProcess Scheduling\n\n\n\n\nUnix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)\n\n\nby W. Richard Stevens and Bill Fenner\n\n\n\n\nIntroduction\n\n\nThe Transport Layer: TCP, UDP, and SCTP\n\n\nSockets Introduction\n\n\nElementary TCP Sockets\n\n\nTCP Client/Server Example\n\n\n\n\nTCP/IP Illustrated, Volume 1: The Protocols (2nd Edition)\n\n\nby Kevin R. Fall and W. Richard Stevens\n\n\n\n\nIntroduction\n\n\nThe Internet Address Architecture\n\n\n\n\nCCENT/CCNA ICND1 640-822 Official Cert Guide, Third Edition\n\n\n\n\nNetworking Fundamentals\n\n\n\n\nCCNA ICND2 Official Exam Certification Guide, Second Edition\n\n\n\n\nLAN Switching\n\n\n\n\nHacking: The Art of Exploitation, 2nd Edition\n\n\nby Jon Erickson\n\n\n\n\nIntroduction (skipped)\n\n\nProgramming\n\n\n\n\nLearning Notes\n\n\nEach topic is included in a single page and references one or more books and materials.\n\n\nProgramming Languages\n\n\n\n\nGolang\n\n\nBash\n\n\nC\n\n\n\n\nSoftware and Technologies\n\n\n\n\nNginx\n\n\nIptables\n\n\nVim", 
            "title": "Home"
        }, 
        {
            "location": "/apue/ch1/", 
            "text": "Chapter 1. UNIX System Overview\n\n\nThis chapter gives basic Unix system concepts that are familiar to system administrators.\n\n\nSystem Calls and Library Functions\n\n\n\n\nLinux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450\n\n\nEach system call has a function of the same name in the standard C library\n\n\nAn application can either make a system call or call a library routine", 
            "title": "Chapter 1. UNIX System Overview"
        }, 
        {
            "location": "/apue/ch2/", 
            "text": "Chapter 2. UNIX Standardization and Implementations\n\n\nThis chapter discusses Unix standards, specifications and implementations.\n\n\nUNIX Standardization\n\n\n\n\nISO C\n\n\nIEEE POSIX\n\n\nSingle UNIX Specification (SUS): superset of the POSIX.1 standard\n\n\n\n\nLimits\n\n\n\n\nCompile-time limits\n\n\nRuntime limits", 
            "title": "Chapter 2. UNIX Standardization and Implementations"
        }, 
        {
            "location": "/apue/ch3/", 
            "text": "Chapter 3. File I/O\n\n\nThis chapter discusses unbuffered I/O, which are not part of ISO C but are part of POSIX.1 and the Single UNIX Specification.\n\n\nFile Descriptors\n\n\n\n\nAll open files are referred to by file descriptors\n\n\nNon-negative integer\n\n\nRange from 0 to \nOPEN_MAX - 1\n. With FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10, the limit is essentially infinite, bounded by the amount of memory on the system, the size of an integer, and any hard and soft limits configured by the system administrator.\n\n\n\n\nopen\n and \nopenat\n Functions\n\n\n\n\napue_open.h\n\n\n\n\n#include \nfcntl.h\n\n\n\nint\n \nopen\n(\nconst\n \nchar\n \n*\npath\n,\n \nint\n \noflag\n,\n \n...\n \n/* mode_t mode */\n \n);\n\n\nint\n \nopenat\n(\nint\n \nfd\n,\n \nconst\n \nchar\n \n*\npath\n,\n \nint\n \noflag\n,\n \n...\n \n/* mode_t mode */\n \n);\n\n\n\n/* Both return: file descriptor if OK, \u22121 on error */\n\n\n\n\n\n\noflag\n argument is formed by ORing one or more of the following constants from \nfcntl.h\n [p62]:\n\n\nRequired:\n\n\n\n\nO_RDONLY\n\n\nO_WRONLY\n\n\nO_RDWR\n\n\nO_EXEC\n\n\nO_SEARCH\n: Open for search only (applies to directories).\n\n\n\n\nOptional:\n\n\n\n\nO_APPEND\n\n\nO_CLOEXEC\n: Set the \nFD_CLOEXEC\n file descriptor flag\n\n\nO_CREAT\n: Create the file if it doesn\u2019t exist\n\n\nO_DIRECTORY\n: Generate an error if \nO_CREAT\n is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn\u2019t exist is an atomic operation\n\n\nO_EXCL\n\n\nO_NOCTTY\n\n\nO_NOFOLLOW\n\n\nO_NONBLOCK\n\n\nO_SYNC\n: Have each \nwrite\n wait for physical I/O to complete\n\n\nO_TRUNC\n\n\nO_TTY_INIT\n\n\nO_DSYNC\n\n\nO_RSYNC\n\n\n\n\nTOCTTOU\n\n\nopenat\n, for example, provides a way to avoid \ntime-of-check-to-time-of-use\n (TOCTTOU) errors. A program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call (two calls are not atomic).\n\n\nFilename and Pathname Truncation\n\n\nMost modern file systems support a maximum of 255 characters for filenames.\n\n\ncreat\n Function\n\n\n\n\napue_creat.h\n\n\n\n\n#include \nfcntl.h\n\n\n\nint\n \ncreat\n(\nconst\n \nchar\n \n*\npath\n,\n \nmode_t\n \nmode\n);\n\n\n\n/* Returns: file descriptor opened for write-only if OK, \u22121 on error */\n\n\n\n\n\n\nThis function is equivalent to:\n\n\nopen\n(\npath\n,\n \nO_WRONLY\n \n|\n \nO_CREAT\n \n|\n \nO_TRUNC\n,\n \nmode\n);\n\n\n\n\n\n\nWith \ncreat\n, the file is opened only for writing. To read and write a file, use [p66]:\n\n\nopen\n(\npath\n,\n \nO_RDWR\n \n|\n \nO_CREAT\n \n|\n \nO_TRUNC\n,\n \nmode\n);\n\n\n\n\n\n\nclose\n Function\n\n\n\n\napue_close.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \nclose\n(\nint\n \nfd\n);\n\n\n\n/* Returns: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nWhen a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don\u2019t explicitly close open files.\n\n\nlseek\n Function\n\n\nEvery open file has a \"current file offset\", normally a non-negative integer that measures the number of bytes from the beginning of the file.\n\n\n\n\napue_lseek.h\n\n\n\n\n#include \nunistd.h\n\n\n\noff_t\n \nlseek\n(\nint\n \nfd\n,\n \noff_t\n \noffset\n,\n \nint\n \nwhence\n);\n\n\n\n/* Returns: new file offset if OK, \u22121 on error */\n\n\n\n\n\n\nThe \nwhence\n argument can be:\n\n\n\n\nSEEK_SET\n: the file\u2019s offset is set to \noffset\n bytes from the beginning of the file\n\n\nSEEK_CUR\n: the file\u2019s offset is set to its current value plus the \noffset\n. The \noffset\n can be positive or negative.\n\n\nSEEK_END\n: the file\u2019s offset is set to the size of the file plus the \noffset\n. The \noffset\n can be positive or negative.\n\n\n\n\nTo determine the current offset, \nseek zero bytes from the current position\n:\n\n\noff_t\n \ncurrpos\n;\n\n\ncurrpos\n \n=\n \nlseek\n(\nfd\n,\n \n0\n,\n \nSEEK_CUR\n);\n\n\n\n\n\n\nThis technique (above code) can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, \nlseek\n sets \nerrno\n to \nESPIPE\n and returns \u22121.\n\n\n\n\nNegative offsets are possible for certain devices, but for regular files, the offset must be non-negative.\n\n\nlseek\n only records the current file offset within the kernel and does not cause any I/O to take place. This offset is then used by the next read or write operation.\n\n\nHole in a file: file\u2019s offset can be greater than the file\u2019s current size, in which case the next \nwrite\n to the file will extend the file. This creates a hole in the file.\n\n\nBytes in the hole (bytes that have not been writen) are read back as 0.\n\n\nA hole in a file isn\u2019t required to have storage backing it on disk.\n\n\n\n\n\n\n\n\nread\n Function\n\n\n\n\napue_read.h\n\n\n\n\n#include \nunistd.h\n\n\n\nssize_t\n \nread\n(\nint\n \nfd\n,\n \nvoid\n \n*\nbuf\n,\n \nsize_t\n \nnbytes\n);\n\n\n\n/* Returns: number of bytes read, 0 if end of file, \u22121 on error */\n\n\n\n\n\n\n\n\nbuf\n: type \nvoid *\n is used for generic pointers.\n\n\nReturn value is required to be a signed integer (\nssize_t\n) to return a positive byte count, 0 (for end of file), or \u22121 (for an error).\n\n\n\n\nSeveral cases in which the number of bytes actually read is less than the amount requested:\n\n\n\n\nRegular file: if the end of file is reached before the requested number of bytes has been read.\n\n\nTerminal device: up to one line is read at a time\n\n\nNetwork: buffering within the network may cause less than the requested amount to be returned\n\n\nPipe or FIFO: if the pipe contains fewer bytes than requested, \nread\n will return only what is available\n\n\nRecord-oriented device\n\n\nInterrupted by a signal and a partial amount of data has already been read\n\n\n\n\nwrite\n Function\n\n\n\n\napue_write.h\n\n\n\n\n#include \nunistd.h\n\n\n\nssize_t\n \nwrite\n(\nint\n \nfd\n,\n \nconst\n \nvoid\n \n*\nbuf\n,\n \nsize_t\n \nnbytes\n);\n\n\n\n/* Returns: number of bytes written if OK, \u22121 on error */\n\n\n\n\n\n\nThe return value is usually equal to the \nnbytes\n argument; otherwise, an error has occurred.\n\n\nCommon causes for a \nwrite\n error:\n\n\n\n\nFilling up a disk\n\n\nExceeding the file size limit for a given process\n\n\n\n\nFor a regular file, the write operation starts at the file\u2019s current offset. If the \nO_APPEND\n option was specified when the file was opened, the file\u2019s offset is set to the current end of file before each write operation. After a successful write, the file\u2019s offset is incremented by the number of bytes actually written.\n\n\nI/O Efficiency\n\n\n\n\nmycat.c\n\n\n\n\n#include \napue.h\n\n\n\n#define BUFFSIZE 4096\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \nint\n \nn\n;\n\n    \nchar\n \nbuf\n[\nBUFFSIZE\n];\n\n\n    \nwhile\n \n((\nn\n \n=\n \nread\n(\nSTDIN_FILENO\n,\n \nbuf\n,\n \nBUFFSIZE\n))\n \n \n0\n)\n\n    \nif\n \n(\nwrite\n(\nSTDOUT_FILENO\n,\n \nbuf\n,\n \nn\n)\n \n!=\n \nn\n)\n\n        \nerr_sys\n(\nwrite error\n);\n\n\n    \nif\n \n(\nn\n \n \n0\n)\n\n        \nerr_sys\n(\nread error\n);\n\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nCaveats of the above program:\n\n\n\n\nIt reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed.\n\n\nIt doesn\u2019t close the input file or output file. Instead, the program uses the feature of the \nUNIX kernel that closes all open file descriptors in a process when that process terminates.\n\n\nThis example works for both text files and binary files, since there is no difference between the two to the UNIX kernel.\n\n\n\n\nTiming results for reading with different buffer sizes (\nBUFFSIZE\n) on Linux:\n\n\n\n\nThe file was read using the program shown above, with standard output redirected to \n/dev/null\n. The file system used for this test was the Linux ext4 file system with 4,096-byte blocks (the \nst_blksize\n value is 4,096). This accounts for the minimum in the system time occurring at the few timing measurements starting around a \nBUFFSIZE\n of 4,096. Increasing the buffer size beyond this limit has little positive effect.\n\n\nMost file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. The effect of read-ahead can be seen in Figure 3.6, where the elapsed time for buffer sizes as small as 32 bytes is as good as the elapsed time for larger buffer sizes. [p73]\n\n\nFile Sharing\n\n\nThe UNIX System supports the sharing of open files among different processes.\n\n\n\n\nThe kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.\n\n\n\n\nProcess table entry\n: every process has an entry in the process table. Each process table entry has a table of open file descriptors. Associated with each file descriptor are:\n\n\nFile descriptor flags\n (close-on-exec)\n\n\nPointer to a file table entry:\n\n\n\n\n\n\nFile table entry\n: the kernel maintains a file table for all open files. Each file table entry contains:\n\n\nFile status flags\n\n\nCurrent file offset\n\n\nPointer to the v-node table entry for the file\n\n\n\n\n\n\nv-node\n structure: contains information about the type of file and pointers to functions that operate on the file\n\n\nThis information is read from disk when the file is opened, so that all the pertinent information about the file is readily available\n\n\nv-node also contains the \ni-node\n for the file\n\n\nLinux has no v-node. Instead, a generic i-node structure is used. [p75] Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system\u2013independent i-node and a file system\u2013dependent i-node. [p76]\n\n\n\n\n\n\n\n\nFigure 3.7\n shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1).\n\n\nIf two independent processes have the same file open, we could have the arrangement shown in Figure 3.8 (below).\n\n\n\n\nEach process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason \neach process gets its own file table entry is so that each process has its own current offset for the file.\n\n\nSpecific operations\n\n\n\n\nFile offset: After each \nwrite\n is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (the file is extended).\n\n\nO_APPEND\n: If a file is opened with the \nO_APPEND\n flag, a corresponding flag is set in the file status flags of the file table entry. Each time a \nwrite\n is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. Th is forces every \nwrite\n to be appended to the current end of file.\n\n\nlseek\n\n\nIf a file is positioned to its current end of file using \nlseek\n, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. \nThis is not the same as if the file was opened with the \nO_APPEND\n flag.\n\n\nThe \nlseek\n function modifies only the current file offset in the file table entry. No I/O takes place.\n\n\n\n\n\n\n\n\nIt is possible for more than one file descriptor entry to point to the same file table entry:\n\n\n\n\ndup\n\n\nfork\n: the parent and the child share the same file table entry for each open descriptor\n\n\n\n\nFile descriptor flags vs. the file status flags\n\n\n\n\nFile descriptor flags: apply only to a single descriptor in a single process\n\n\nFile status flags: apply to all descriptors in any process that point to the given file table entry\n\n\nfcntl\n is used to fetch and modify both of them\n\n\n\n\nAtomic Operations\n\n\nOlder versions of the UNIX System didn\u2019t support the \nO_APPEND\n option if a single process wants to append to the end of a file. The program would be:\n\n\nif\n \n(\nlseek\n(\nfd\n,\n \n0L\n,\n \n2\n)\n \n \n0\n)\n \n/* position to EOF, 2 means SEEK_END */\n\n    \nerr_sys\n(\nlseek error\n);\n\n\nif\n \n(\nwrite\n(\nfd\n,\n \nbuf\n,\n \n100\n)\n \n!=\n \n100\n)\n \n/* and write */\n\n    \nerr_sys\n(\nwrite error\n);\n\n\n\n\n\n\nThis works fine for a single process, but problems arise if multiple processes (or multiple instances of the same program) use this technique to append to the same file. The problem here is that our logical operation of \"position to the end of file and write\" requires two separate function calls. The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls. The UNIX System provides an atomic way to do this operation if we set the \nO_APPEND\n flag when a file is opened. This causes the kernel to position the file to its current end of file before each \nwrite\n. We no longer have to call lseek before each \nwrite\n.\n\n\npread\n and \npwrite\n Functions\n\n\nThe Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically:\n\n\n\n\napue_pread.h\n\n\n\n\n#include \nunistd.h\n\n\n\nssize_t\n \npread\n(\nint\n \nfd\n,\n \nvoid\n \n*\nbuf\n,\n \nsize_t\n \nnbytes\n,\n \noff_t\n \noffset\n);\n\n\n/* Returns: number of bytes read, 0 if end of file, \u22121 on error */\n\n\n\nssize_t\n \npwrite\n(\nint\n \nfd\n,\n \nconst\n \nvoid\n \n*\nbuf\n,\n \nsize_t\n \nnbytes\n,\n \noff_t\n \noffset\n);\n\n\n/* Returns: number of bytes written if OK, \u22121 on error */\n\n\n\n\n\n\n\n\npread\n: equivalent to calling \nlseek\n followed by a call to \nread\n, with the following exceptions:\n\n\nThere is no way to interrupt the two operations that occur calling \npread\n.\n\n\nThe current file offset is not updated.\n\n\n\n\n\n\npwrite\n:  equivalent to calling lseek followed by a call to write, with similar exceptions to \npread\n.\n\n\n\n\nCreating a File\n\n\nAtomic operation\n\n\nWhen both of \nO_CREAT\n and \nO_EXCL\n options are specified, the \nopen\n will fail if the file already exists. The check for the existence of the file and the creation of the file was performed as an atomic operation.\n\n\nNon-atomic operation\n\n\nIf we didn\u2019t have this atomic operation, we might try:\n\n\nif\n \n((\nfd\n \n=\n \nopen\n(\npath\n,\n \nO_WRONLY\n))\n \n \n0\n)\n \n{\n\n    \nif\n \n(\nerrno\n \n==\n \nENOENT\n)\n \n{\n\n        \nif\n \n((\nfd\n \n=\n \ncreat\n(\npath\n,\n \nmode\n))\n \n \n0\n)\n\n            \nerr_sys\n(\ncreat error\n);\n\n    \n}\n \nelse\n \n{\n\n        \nerr_sys\n(\nopen error\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe problem occurs if the file is created by another process between the \nopen\n and the \ncreat\n. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this \ncreat\n is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem.\n\n\nAtomic operation\n refers to an operation that might be composed of multiple steps. \nIf the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed.\n\n\ndup\n and \ndup2\n Functions\n\n\nAn existing file descriptor is duplicated by either of the following functions:\n\n\n\n\napue_dup.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \ndup\n(\nint\n \nfd\n);\n\n\nint\n \ndup2\n(\nint\n \nfd\n,\n \nint\n \nfd2\n);\n\n\n\n/* Both return: new file descriptor if OK, \u22121 on error */\n\n\n\n\n\n\n\n\ndup\n: return the new file descriptor, which is guaranteed to be the lowest-numbered available file descriptor\n\n\ndup2\n: \nfd2\n argument is the new file descriptor we specifiy.\n\n\nIf \nfd2\n is already open, it is first closed\n\n\nIf \nfd\n equals \nfd2\n, then \ndup2\n returns \nfd2\n without closing it. Otherwise, the \nFD_CLOEXEC\n file descriptor flag is cleared for \nfd2\n, so that \nfd2\n is left open if the process calls \nexec\n.\n\n\n\n\n\n\n\n\nKernel data structures after \ndup(1)\n:\n\n\n\n\nIn the above figure, we assume the process executes:\n\n\nnewfd\n \n=\n \ndup\n(\n1\n);\n\n\n\n\n\n\n\n\nBecause both descriptors point to the same file table entry, they share the same file status flags (e.g. read, write, append) and the same current file offset.\n\n\nEach descriptor has its own set of file descriptor flags\n\n\n\n\nAnother way to duplicate a descriptor is with the \nfcntl\n function:\n\n\ndup\n(\nfd\n);\n\n\n\n\n\n\nis equivalent to\n\n\nfcntl\n(\nfd\n,\n \nF_DUPFD\n,\n \n0\n);\n\n\n\n\n\n\nSimilarly, the call\n\n\ndup2\n(\nfd\n,\n \nfd2\n);\n\n\n\n\n\n\nis equivalent to\n\n\nclose\n(\nfd2\n);\n\n\nfcntl\n(\nfd\n,\n \nF_DUPFD\n,\n \nfd2\n);\n\n\n\n\n\n\nIn this last case (above), the \ndup2\n is not exactly the same as a \nclose\n followed by an \nfcntl\n:\n\n\n\n\ndup2\n is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the \nclose\n and the \nfcntl\n that could modify the file descriptors. The same problem could occur if a different thread changes the file descriptors.\n\n\nThere are some \nerrno\n differences between \ndup2\n and \nfcntl\n.\n\n\n\n\nsync\n, \nfsync\n, and \nfdatasync\n Functions\n\n\nTraditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes.\n\n\n\n\nDelayed write\n: when we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time\n\n\n\n\nThe kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the \nsync\n, \nfsync\n, and \nfdatasync\n functions are provided.\n\n\n\n\napue_fsync.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \nfsync\n(\nint\n \nfd\n);\n\n\nint\n \nfdatasync\n(\nint\n \nfd\n);\n\n\n\n/* Returns: 0 if OK, \u22121 on error */\n\n\n\nvoid\n \nsync\n(\nvoid\n);\n\n\n\n\n\n\n\n\nsync\n: queues all the modified block buffers for writing and returns. It does not wait for the disk writes to take place\n\n\nsync\n is normally called periodically (usually every 30 seconds) from a system daemon, often called \nupdate\n, which guarantees regular flushing of the kernel\u2019s block buffers. The command \nsync(1)\n also calls the \nsync\n function.\n\n\n\n\n\n\nfsync\n: applies to a single file specified by the file descriptor \nfd\n, and waits for the disk writes to complete before returning.\n\n\nfsync\n also updates the file's attributes synchronously\n\n\n\n\n\n\nfdatasync\n: similar to \nfsync\n, but it affects only the data portions of a file.\n\n\n\n\nfcntl\n Function\n\n\nThe \nfcntl\n function can change the properties of a file that is already open.\n\n\n\n\napue_fcntl.h\n\n\n\n\n#include \nfcntl.h\n\n\n\nint\n \nfcntl\n(\nint\n \nfd\n,\n \nint\n \ncmd\n,\n \n...\n \n/* int arg */\n \n);\n\n\n\n/* Returns: depends on cmd if OK (see following), \u22121 on error */\n\n\n\n\n\n\nIn this section, the third argument of \nfcntl\n is always an integer, corresponding to the comment in the function prototype just shown.\n\n\nThe \nfcntl\n function is used for five different purposes:\n\n\n\n\nDuplicate an existing descriptor (\ncmd\n = \nF_DUPFD\n or \nF_DUPFD_CLOEXEC\n)\n\n\nGet/set file descriptor flags (\ncmd\n = \nF_GETFD\n or \nF_SETFD\n)\n\n\nGet/set file status flags (\ncmd\n = \nF_GETFL\n or \nF_SETFL\n)\n\n\nGet/set asynchronous I/O ownership (\ncmd\n = \nF_GETOWN\n or \nF_SETOWN\n)\n\n\nGet/set record locks (\ncmd\n = \nF_GETLK\n, \nF_SETLK\n, or \nF_SETLKW\n)\n\n\n\n\nThe following text discusses both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry.\n\n\n\n\nF_DUPFD\n: Duplicate the file descriptor \nfd\n. The new file descriptor, which is the lowest-numbered descriptor that is not already open and is greater than or equal to the third argument (integer), is returned as the value of the function. The new descriptor has its own set of file descriptor flags with \nFD_CLOEXEC\n cleared.\ncleared.\n\n\nF_DUPFD_CLOEXEC\n: Duplicate the file descriptor and set the \nFD_CLOEXEC\n file descriptor flag associated with the new descriptor.\n\n\nF_GETFD\n: Return the file descriptor flags for \nfd\n. Currently, only one file descriptor flag (\nFD_CLOEXEC\n) is defined.\n\n\nF_SETFD\n: Set the file descriptor flags for \nfd\n. The new flag value is set from the third argument.\n\n\nSome existing programs don\u2019t use constant \nFD_CLOEXEC\n. Instead, these programs set the flag to either 0 (don\u2019t close-on-exec, the default) or 1 (do close-on-exec).\n\n\n\n\n\n\n\n\nF_GETFL\n: Return the file status flags for \nfd\n. The file status flags were described with the \nopen\n function.\n\n\n\n\nThe five access-mode flags (\nO_RDONLY\n, \nO_WRONLY\n, \nO_RDWR\n, \nO_EXEC\n, and \nO_SEARCH\n) are not separate bits that can be tested.\n\n\nO_RDONLY\n, \nO_WRONLY\n, \nO_RDWR\n often have the values 0, 1, and 2, respectively\n\n\nThe five access-mode flags are mutually exclusive: this means a file can have only one of them enabled.\n\n\nWe must first use the \nO_ACCMODE\n mask to obtain the access-mode bits and then compare the result against any of the five values.\n\n\n\n\n\n\n\n\n\n\nFile status flag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nO_RDONLY\n\n\nopen for reading only\n\n\n\n\n\n\nO_WRONLY\n\n\nopen for writing only\n\n\n\n\n\n\nO_RDWR\n\n\nopen for reading and writing\n\n\n\n\n\n\nO_EXEC\n\n\nopen for execute only\n\n\n\n\n\n\nO_SEARCH\n\n\nopen directory for searching only\n\n\n\n\n\n\nO_APPEND\n\n\nappend on each write\n\n\n\n\n\n\nO_NONBLOCK\n\n\nnonblocking mode\n\n\n\n\n\n\nO_SYNC\n\n\nwait for writes to complete (data and attributes)\n\n\n\n\n\n\nO_DSYNC\n\n\nwait for writes to complete (data only)\n\n\n\n\n\n\nO_RSYNC\n\n\nsynchronize reads and writes\n\n\n\n\n\n\nO_FSYNC\n\n\nwait for writes to complete (FreeBSD and Mac OS X only)\n\n\n\n\n\n\nO_ASYNC\n\n\nasynchronous I/O (FreeBSD and Mac OS X only)\n\n\n\n\n\n\n\n\n\n\n\n\nF_SETFL\n: Set the file status flags to the value of the third argument (integer). The only flags that can be changed are:\n\n\n\n\nO_APPEND\n\n\nO_NONBLOCK\n\n\nO_SYNC\n\n\nO_DSYNC\n\n\nO_RSYNC\n\n\nO_FSYNC\n\n\nO_ASYNC\n\n\n\n\n\n\nF_GETOWN\n: Get the process ID or process group ID currently receiving the \nSIGIO\n and \nSIGURG\n signals.\n\n\nF_SETOWN\n: Set the process ID or process group ID to receive the \nSIGIO\n and \nSIGURG\n signals.\n\n\n\n\nThe return value from \nfcntl\n depends on the command. All commands return \u22121 on an error or some other value if OK. The following four commands have special return values:\n\n\n\n\nF_DUPFD\n: returns the new file descriptor\n\n\nF_GETFD\n: returns the file descriptor flags\n\n\nF_GETFL\n: returns the file status flags\n\n\nF_GETOWN\n: returns a positive process ID or a negative process group ID\n\n\n\n\nGetting file flags\n\n\nExample:\n\n\n\n\nfileflags.c\n\n\n\n\n#include \napue.h\n\n\n#include \nfcntl.h\n\n\n\nint\n\n\nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nargv\n[])\n\n\n{\n\n    \nint\n \nval\n;\n\n\n    \nif\n \n(\nargc\n \n!=\n \n2\n)\n\n        \nerr_quit\n(\nusage: a.out \ndescriptor#\n);\n\n    \nif\n \n((\nval\n \n=\n \nfcntl\n(\natoi\n(\nargv\n[\n1\n]),\n \nF_GETFL\n,\n \n0\n))\n \n \n0\n)\n\n        \nerr_sys\n(\nfcntl error for fd %d\n,\n \natoi\n(\nargv\n[\n1\n]));\n\n\n    \nswitch\n \n(\nval\n \n \nO_ACCMODE\n)\n \n{\n\n    \ncase\n \nO_RDONLY\n:\n\n        \nprintf\n(\nread only\n);\n\n        \nbreak\n;\n\n    \ncase\n \nO_WRONLY\n:\n\n        \nprintf\n(\nwrite only\n);\n\n        \nbreak\n;\n\n    \ncase\n \nO_RDWR\n:\n\n        \nprintf\n(\nread write\n);\n\n        \nbreak\n;\n\n    \ndefault\n:\n\n        \nerr_dump\n(\nunknown access mode\n);\n\n    \n}\n\n\n    \nif\n \n(\nval\n \n \nO_APPEND\n)\n\n        \nprintf\n(\n, append\n);\n\n    \nif\n \n(\nval\n \n \nO_NONBLOCK\n)\n\n        \nprintf\n(\n, nonblocking\n);\n\n    \nif\n \n(\nval\n \n \nO_SYNC\n)\n\n        \nprintf\n(\n, synchronous writes\n);\n\n\n\n#if !defined(_POSIX_C_SOURCE) \n defined(O_FSYNC) \n (O_FSYNC != O_SYNC)\n\n    \nif\n \n(\nval\n \n \nO_FSYNC\n)\n\n        \nprintf\n(\n, synchronous writes\n);\n\n\n#endif\n\n\n    \nputchar\n(\n\\n\n);\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nResults:\n\n\n$ \n./a.out \n0\n \n /dev/tty\n\nread \nonly\n\n$ \n./a.out \n1\n \n temp.foo\n\n$ \ncat temp.foo\nwrite only\n\n$ \n./a.out \n2\n 2\ntemp.foo\nwrite only, append\n\n$ \n./a.out \n5\n 5\ntemp.foo\n\nread \nwrite\n\n\n\n\n\nModifying file flags\n\n\nTo modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can\u2019t simply issue an \nF_SETFD\n or an \nF_SETFL\n command, as this could turn off flag bits that were previously set.\n\n\nExample:\n\n\n#include \napue.h\n\n\n#include \nfcntl.h\n\n\n\nvoid\n\n\nset_fl\n(\nint\n \nfd\n,\n \nint\n \nflags\n)\n \n/* flags are file status flags to turn on */\n\n\n{\n\n    \nint\n \nval\n;\n\n    \nif\n \n((\nval\n \n=\n \nfcntl\n(\nfd\n,\n \nF_GETFL\n,\n \n0\n))\n \n \n0\n)\n\n        \nerr_sys\n(\nfcntl F_GETFL error\n);\n\n    \nval\n \n|=\n \nflags\n;\n \n/* turn on flags */\n\n    \nif\n \n(\nfcntl\n(\nfd\n,\n \nF_SETFL\n,\n \nval\n)\n \n \n0\n)\n\n        \nerr_sys\n(\nfcntl F_SETFL error\n);\n\n\n}\n\n\n\n\n\n\nIf we change the middle statement to\n\n\nval\n \n=\n \n\u02dc\nflags\n;\n \n/* turn flags off */\n\n\n\n\n\n\nwe have a function named \nclr_fl\n,  logically ANDs the one\u2019s complement of \nflags\n with the current \nval\n.\n\n\nSynchronous-write flag\n\n\nIf we add the line\n\n\nset_fl\n(\nSTDOUT_FILENO\n,\n \nO_SYNC\n);\n\n\n\n\n\n\nto the beginning of the program shown in \nI/O Efficiency section\n, we\u2019ll turn on the synchronous-write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, \na \nwrite\n only queues the data for writing; the actual disk write operation can take place sometime later.\n A database system is a likely candidate for using \nO_SYNC\n, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure.\n\n\nLinux ext4 timing results using various synchronization mechanisms [p86]\n\n\nMac OS X HFS timing results using various synchronization mechanisms [p87]\n\n\nThe \nabove program\n operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can\u2019t set the \nO_SYNC\n flag when the file is opened, since the shell opened the file. With \nfcntl\n, we can modify the properties of a descriptor, knowing only the descriptor for the open file.\n\n\nioctl\n Function\n\n\n\n\napue_ioctl.h\n\n\n\n\n#include \nunistd.h\n \n/* System V */\n\n\n#include \nsys/ioctl.h\n \n/* BSD and Linux */\n\n\n\nint\n \nioctl\n(\nint\n \nfd\n,\n \nint\n \nrequest\n,\n \n...);\n\n\n\n/* Returns: \u22121 on error, something else if OK */\n\n\n\n\n\n\nThe \nioctl\n function has always been the catchall for I/O operations. Anything that couldn\u2019t be expressed using one of the other functions in this chapter usually ended up being specified with an \nioctl\n. Terminal I/O was the biggest user of this function.\n\n\nFor the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it\u2019s usually a pointer to a variable or a structure.\n\n\nEach device driver can define its own set of \nioctl\n commands. The system, however, provides generic ioctl commands for different classes of devices.\n\n\nWe use the \nioctl\n function in Section 18.12 to fetch and set the size of a terminal\u2019s window, and in Section 19.7 when we access the advanced features of pseudo terminals.\n\n\n/dev/fd\n\n\nNewer systems provide a directory named \n/dev/fd\n whose entries are files named 0, 1, 2, and so on. Opening the file \n/dev/fd/n\n is equivalent to duplicating descriptor \nn\n, assuming that descriptor \nn\n is open. \n/dev/fd\n is not part of POSIX.1.\n\n\nThe following are equivalent:\n\n\nfd\n \n=\n \nopen\n(\n/dev/fd/0\n,\n \nmode\n);\n\n\nfd\n \n=\n \ndup\n(\n0\n);\n\n\n\n\n\n\nMost systems ignore the specified \nmode\n, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. The descriptors 0 and \nfd\n \nshare the same file table entry\n.\n\n\nThe Linux implementation of \n/dev/fd\n is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open \n/dev/fd/0\n, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the \n/dev/fd\n file descriptor.\n\n\nWe can also call \ncreat\n with a \n/dev/fd\n pathname argument as well as specify \nO_CREAT\n in a call to open. This allows a program that calls \ncreat\n to still work if the pathname argument is \n/dev/fd/1\n, for example.\n\n\nSome systems provide the pathnames \n/dev/stdin\n, \n/dev/stdout\n, and \n/dev/stderr\n. These pathnames are equivalent to \n/dev/fd/0\n, \n/dev/fd/1\n, and \n/dev/fd/2\n, respectively.\n\n\nThe main use of the \n/dev/fd\n files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames.\n\n\nThe following are equivalent:\n\n\nfilter file2 \n|\n cat file1 - file3 \n|\n lpr\nfilter file2 \n|\n cat file1 /dev/fd/0 file3 \n|\n lpr", 
            "title": "Chapter 3. File I/O"
        }, 
        {
            "location": "/apue/ch4/", 
            "text": "Chapter 4. Files and Directories\n\n\nThis chapter centers on I/O for regular files.\n\n\nrestrict\n keyword\n\n\nAdded in C99, \nrestrict\n keyword is used to tell the compiler which pointer references can be optimized, by indicating that the object to which the pointer refers is accessed in the function only via that pointer. [p26]\n\n\nstat\n, \nfstat\n, \nfstatat\n, and \nlstat\n Functions\n\n\n\n\napue_stat.h\n\n\n\n\n#include \nsys/stat.h\n\n\n\nint\n \nstat\n(\nconst\n \nchar\n \n*\nrestrict\n \npathname\n,\n \nstruct\n \nstat\n \n*\nrestrict\n \nbuf\n);\n\n\nint\n \nfstat\n(\nint\n \nfd\n,\n \nstruct\n \nstat\n \n*\nbuf\n);\n\n\nint\n \nlstat\n(\nconst\n \nchar\n \n*\nrestrict\n \npathname\n,\n \nstruct\n \nstat\n \n*\nrestrict\n \nbuf\n);\n\n\nint\n \nfstatat\n(\nint\n \nfd\n,\n \nconst\n \nchar\n \n*\nrestrict\n \npathname\n,\n \nstruct\n \nstat\n \n*\nrestrict\n \nbuf\n,\n \nint\n \nflag\n);\n\n\n\n/* All four return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\n\n\nstat\n: returns a structure of information about the named file\n\n\nfstat\n: returns a structure of information about the given file descriptor\n\n\nlstat\n: similar to \nstat\n, returns information about the symbolic link, not the file referenced by the symbolic link\n\n\nfstatat\n:  return the file statistics for a pathname relative to an open directory represented by the fd argument; the flag argument controls whether symbolic links are followed\n\n\n\n\nThe \nbuf\n argument is a pointer to a \nstructure\n that we must supply. The functions fill in the structure.\n\n\nstruct\n \nstat\n \n{\n\n    \nmode_t\n    \nst_mode\n;\n\n    \nino_t\n    \nst_ino\n;\n\n    \ndev_t\n    \nst_dev\n;\n\n    \ndev_t\n    \nst_rdev\n;\n\n    \nnlink_t\n    \nst_nlink\n;\n\n    \nuid_t\n    \nst_uid\n;\n\n    \ngid_t\n    \nst_gid\n;\n\n    \noff_t\n    \nst_size\n;\n\n    \nstruct\n \ntimespec\n    \nst_atim\n;\n\n    \nstruct\n \ntimespec\n    \nst_mtim\n;\n\n    \nstruct\n \ntimespec\n    \nst_ctim\n;\n\n    \nblksize_t\n    \nst_blksize\n;\n\n    \nblkcnt_t\n    \nst_blocks\n;\n\n\n};\n\n\n\n\n\n\ntimespec\n structure\n\n\nThe \ntimespec\n structure type defines time in terms of seconds and nanoseconds. It includes at least the following fields:\n\n\ntime_t\n \ntv_sec\n;\n\n\nlong\n \ntv_nsec\n;\n\n\n\n\n\n\nFile Types\n\n\n\n\nRegular file. All binary executable files conform to a format that allows the kernel to identify where to load a program\u2019s text and data.\n\n\nDirectory file. A file that contains the names of other files and pointers to information on these files. Any process that has read permission for a directory file can read the contents of the directory, but only the kernel can write directly to a directory file.\n\n\nBlock special file\n\n\nCharacter special file\n\n\nFIFO\n\n\nSocket\n\n\nSymbolic link\n\n\n\n\nThis program prints the type of file for each command-line argument.\n\n\n\n\nfiletype.c\n\n\n\n\nSet-User-ID and Set-Group-ID\n\n\nFile Access Permissions\n\n\n\n\nWhenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including the current directory, if it is implied. Read permission for a directory and execute permission for a directory mean different things. Read permission lets us read the directory, obtaining a list of all the filenames in the directory. Execute permission lets us pass through the directory when it is a component of a pathname that we are trying to access. [p100]\n\n\nWe cannot create a new file in a directory unless we have write permission and execute permission in the directory.\n\n\n\n\nOwnership of New Files and Directories\n\n\n\n\nThe user ID of a new file is set to the effective user ID of the process\n\n\nThe group ID of a new file can be the effective group ID of the process; or group ID of the directory in which the file is being created.\n\n\n\n\nFreeBSD 8.0 and Mac OS X 10.6.8 always copy the new file\u2019s group ID from the directory.\n\n\naccess\n and \nfaccessat\n Functions\n\n\n\n\napue_access.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \naccess\n(\nconst\n \nchar\n \n*\npathname\n,\n \nint\n \nmode\n);\n\n\nint\n \nfaccessat\n(\nint\n \nfd\n,\n \nconst\n \nchar\n \n*\npathname\n,\n \nint\n \nmode\n,\n \nint\n \nflag\n);\n\n\n\n/* Both return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nThese functions test accessibility based on the real user and group IDs.\n\n\nThe \nflag\n argument can be used to change the behavior of \nfaccessat\n. If the \nAT_EACCESS\n flag is set, the access checks are made using the effective user and group IDs.\n\n\n\n\naccess.c\n\n\n\n\numask\n Function\n\n\nThe Single UNIX Specification requires that the \numask\n command support a symbolic mode of operation. Unlike the octal format, the symbolic format specifies which permissions are to be allowed instead of which ones are to be denied.\n\n\n$ \numask\n  \n# first print the current file mode creation mask\n\n002\n\n$ \numask\n -S  \n# print the symbolic form\n\n\nu\n=\nrwx,g\n=\nrwx,o\n=\nrx\n\n$ \numask \n027\n  \n# print the symbolic form\n\n\n$ \numask\n -S  \n# print the symbolic form\n\n\nu\n=\nrwx,g\n=\nrx,o\n=\n\n\n\n\n\n\nchmod\n, \nfchmod\n, and \nfchmodat\n Functions\n\n\n\n\napue_chmod.h\n\n\n\n\n#include \nsys/stat.h\n\n\n\nint\n \nchmod\n(\nconst\n \nchar\n \n*\npathname\n,\n \nmode_t\n \nmode\n);\n\n\nint\n \nfchmod\n(\nint\n \nfd\n,\n \nmode_t\n \nmode\n);\n\n\nint\n \nfchmodat\n(\nint\n \nfd\n,\n \nconst\n \nchar\n \n*\npathname\n,\n \nmode_t\n \nmode\n,\n \nint\n \nflag\n);\n\n\n\n/* All three return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nchmod\n automatically clears the following permission bits under the following conditions:\n\n\n\n\nSetting sticky bit on a regular file without superuser privileges (Solaris)\n\n\nIf the group ID of the new file does not equal either the effective group ID of the process or one of the process\u2019s supplementary group IDs and if the process does not have superuser privileges, then the set-group-ID bit is automatically turned off. On FreeBSD 8.0, Linux 3.2.0 and Mac OS X 10.6.8, if a process that does not have superuser privileges writes to a file, the set-user-ID and set-group-ID bits are automatically turned off.\n\n\n\n\nSticky Bit\n\n\nSticky Bit (\nS_ISVTX\n), or saved-text bit in the later versions of the UNIX System.\n\n\n\n\nOn file: only on a minority of systems\n\n\nOn directory: \n/tmp\n and \n/var/tmp\n\n\n\n\nchown\n, \nfchown\n, \nfchownat\n, and \nlchown\n Functions\n\n\n\n\napue_chown.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \nchown\n(\nconst\n \nchar\n \n*\npathname\n,\n \nuid_t\n \nowner\n,\n \ngid_t\n \ngroup\n);\n\n\nint\n \nfchown\n(\nint\n \nfd\n,\n \nuid_t\n \nowner\n,\n \ngid_t\n \ngroup\n);\n\n\nint\n \nfchownat\n(\nint\n \nfd\n,\n \nconst\n \nchar\n \n*\npathname\n,\n \nuid_t\n \nowner\n,\n \ngid_t\n \ngroup\n,\n \nint\n \nflag\n);\n\n\nint\n \nlchown\n(\nconst\n \nchar\n \n*\npathname\n,\n \nuid_t\n \nowner\n,\n \ngid_t\n \ngroup\n);\n\n\n\n/* All four return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\n\n\nlchown\n and \nfchownat\n (with the \nAT_SYMLINK_NOFOLLOW\n flag set) change the owners of the symbolic link itself.\n\n\nfchown\n operates on a open file, it can\u2019t be used to change the ownership of a symbolic link.\n\n\n\n\nOnly the superuser can change the ownership of a file (FreeBSD 8.0, Linux 3.2.0, and Mac OS X 10.6.8)\n\n\nWhen \n_POSIX_CHOWN_RESTRICTED\n is in effect, a non-superuser can\u2019t change the user ID of your files; A nonsuperuser can change the group ID of files that he owns, but only to groups that he belongs to.\n\n\nFile Size\n\n\nThe \nst_size\n member of the stat structure contains the size of the file in bytes. This field is meaningful only for regular files, directories, and symbolic links.\n\n\nFreeBSD 8.0, Mac OS X 10.6.8, and Solaris 10 also define the file size for a pipe as the number of bytes that are available for reading from the pipe.\n\n\n\n\nFor a regular file, a file size of 0 is allowed. We\u2019ll get an end-of-file indication on the first read of the file.\n\n\nFor a directory, the file size is usually a multiple of a number, such as 16 or 512.\n\n\nFor a symbolic link, the file size is the number of bytes in the filename.\n\n\n\n\nMost contemporary UNIX systems provide two fields:\n\n\n\n\nst_blksize\n: preferred block size for I/O for the file\n\n\nst_blocks\n: actual number of 512-byte blocks that are allocated\n\n\n\n\nBe aware that different versions of the UNIX System use units other than 512-byte blocks for \nst_blocks\n. Use of this value is \nnonportable\n.\n\n\nHoles in a File\n\n\n$ \nls -l core\n-rw-r--r-- \n1\n sar \n8483248\n Nov \n18\n 12:18 core\n\n$ \ndu -s core\n\n272\n core\n\n\n\n\n\nFile Truncation\n\n\n\n\n\n\n\napue_truncate.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \ntruncate\n(\nconst\n \nchar\n \n*\npathname\n,\n \noff_t\n \nlength\n);\n\n\nint\n \nftruncate\n(\nint\n \nfd\n,\n \noff_t\n \nlength\n);\n\n\n\n/* Both return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nThese two functions truncate an existing file to \nlength\n bytes. If the previous size of the file was greater than \nlength\n, the data beyond \nlength\n is no longer accessible. Otherwise, if the previous size was less than \nlength\n, the file size will increase and the data between the old end of file and the new end of file will read as 0 (a hole is probably created in the file).\n\n\nFile Systems\n\n\nMost UNIX file systems support \ncase-sensitive\n filenames. On Mac OS X, however, the HFS file system is \ncase-preserving\n with \ncase-insensitive\n comparisons.\n\n\n\n\n\n\nEvery i-node has a link count that contains the number of directory entries that point to it. Only when the link count (\nst_nlink\n) goes to 0 can the file be deleted.\n\n\nWith a symbolic link (file type \nS_IFLNK\n), the actual contents of the file (the data blocks) store the name of the file that the symbolic link points to.\n\n\nThe i-node contains all the information about the file: the file type, the file\u2019s access permission bits, the size of the file, pointers to the file\u2019s data blocks, and so on.\n\n\nOnly two items are stored in the directory entry: the filename and the i-node number. The data type for the i-node number is \nino_t\n.\n\n\n\n\nlink\n, \nlinkat\n, \nunlink\n, \nunlinkat\n, and \nremove\n Functions\n\n\n\n\napue_link.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \nlink\n(\nconst\n \nchar\n \n*\nexistingpath\n,\n \nconst\n \nchar\n \n*\nnewpath\n);\n\n\nint\n \nlinkat\n(\nint\n \nefd\n,\n \nconst\n \nchar\n \n*\nexistingpath\n,\n \nint\n \nnfd\n,\n \nconst\n \nchar\n \n*\nnewpath\n,\n\n           \nint\n \nflag\n);\n\n\n\n/* Both return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nWhen a file is closed, the kernel first checks the count of the number of processes that have the file open. If this count has reached 0, the kernel then checks the link count; if it is 0, the file\u2019s contents are deleted.\n\n\nWhen the \nAT_REMOVEDIR\n flag is set, then the \nunlinkat\n function can be used to remove a directory, similar to using \nrmdir\n.\n\n\n\n\napue_remove.h\n\n\n\n\n#include \nstdio.h\n\n\n\nint\n \nremove\n(\nconst\n \nchar\n \n*\npathname\n);\n\n\n\n/* Returns: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nrename\n and \nrenameat\n Functions\n\n\n\n\napue_rename.h\n\n\n\n\n#include \nstdio.h\n\n\n\nint\n \nrename\n(\nconst\n \nchar\n \n*\noldname\n,\n \nconst\n \nchar\n \n*\nnewname\n);\n\n\nint\n \nrenameat\n(\nint\n \noldfd\n,\n \nconst\n \nchar\n \n*\noldname\n,\n \nint\n \nnewfd\n,\n \nconst\n \nchar\n \n*\nnewname\n);\n\n\n\n/* Both return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nSymbolic Links\n\n\nIt is possible to introduce loops into the file system by using symbolic links. Most functions that look up a pathname return an \nerrno\n of \nELOOP\n when this occurs.\n\n\nOn Linux, the \nftw\n and \nnftw\n functions record all directories seen and avoid processing a directory more than once, so they don\u2019t display this behavior.\n\n\n\n\nls -l\n\n\n\n\nls -F\n\n\n\n\n\n\napue_symlink.h\n\n\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \nsymlink\n(\nconst\n \nchar\n \n*\nactualpath\n,\n \nconst\n \nchar\n \n*\nsympath\n);\n\n\nint\n \nsymlinkat\n(\nconst\n \nchar\n \n*\nactualpath\n,\n \nint\n \nfd\n,\n \nconst\n \nchar\n \n*\nsympath\n);\n\n\n\n/* Both return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nBecause the open function follows a symbolic link, we need a way to open the link itself and read the name in the link.\n\n\n\n\napue_readlink.h\n\n\n\n\n#include \nunistd.h\n\n\n\nssize_t\n \nreadlink\n(\nconst\n \nchar\n \n*\nrestrict\n \npathname\n,\n \nchar\n \n*\nrestrict\n \nbuf\n,\n\n                 \nsize_t\n \nbufsize\n);\n\n\n\nssize_t\n \nreadlinkat\n(\nint\n \nfd\n,\n \nconst\n \nchar\n \n*\nrestrict\n \npathname\n,\n\n                   \nchar\n \n*\nrestrict\n \nbuf\n,\n \nsize_t\n \nbufsize\n);\n\n\n\n/* Both return: number of bytes read if OK, \u22121 on error */\n\n\n\n\n\n\nThese functions combine the actions of \nopen\n, \nread\n, and \nclose\n.\n\n\nFile Times\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\nExample\n\n\nls(1) option\n\n\n\n\n\n\n\n\n\n\nst_atim\n\n\nlast-access time of file data\n\n\nread\n\n\n-u\n\n\n\n\n\n\nst_mtim\n\n\nlast-modification time of file data\n\n\nwrite\n\n\ndefault\n\n\n\n\n\n\nst_ctim\n\n\nlast-change time of i-node status\n\n\nchmod\n, \nchown\n\n\n-c\n\n\n\n\n\n\n\n\nThe system does not maintain the last-access time for an i-node. The functions \naccess\n and \nstat\n don\u2019t change any of the three times.\n\n\nfutimens\n, \nutimensat\n, and \nutimes\n Functions\n\n\n\n\napue_futimens.h\n\n\n\n\n#include \nsys/stat.h\n\n\n\nint\n \nfutimens\n(\nint\n \nfd\n,\n \nconst\n \nstruct\n \ntimespec\n \ntimes\n[\n2\n]);\n\n\nint\n \nutimensat\n(\nint\n \nfd\n,\n \nconst\n \nchar\n \n*\npath\n,\n \nconst\n \nstruct\n \ntimespec\n \ntimes\n[\n2\n],\n \nint\n \nflag\n);\n\n\n\n/* Both return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nIn both functions, the first element of the times array argument contains the \naccess time\n, and the second element contains the \nmodification time\n.\n\n\n\n\napue_utimes\n\n\n\n\n#include \nsys/time.h\n\n\n\nint\n \nutimes\n(\nconst\n \nchar\n \n*\npathname\n,\n \nconst\n \nstruct\n \ntimeval\n \ntimes\n[\n2\n]);\n\n\n\n/* Returns: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nWe are unable to specify a value for the \nchanged-status time\n, \nst_ctim\n (the time the i-node was last changed), as this field is automatically updated when the \nutime\n function is called.\n\n\nmkdir\n, \nmkdirat\n, and \nrmdir\n Functions\n\n\n\n\napue_rmdir.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \nrmdir\n(\nconst\n \nchar\n \n*\npathname\n);\n\n\n\n/* Returns: 0 if OK, \u22121 on error */\n\n\n\n\n\n\nFor a directory, we normally want at least one of the execute bits enabled, to allow access to filenames within the directory.\n\n\nSolaris 10 and Linux 3.2.0 also have the new directory inherit the set-group-ID bit from the parent directory. Files created in the new directory will then inherit the group ID of that directory. With Linux, the file system implementation determines whether this behavior is supported. For example, the ext2, ext3, and ext4 file systems allow this behavior to be controlled by an option to the mount(1) command.\n\n\nReading Directories\n\n\n\n\napue_opendir.h\n\n\n\n\n#include \ndirent.h\n\n\n\nDIR\n \n*\nopendir\n(\nconst\n \nchar\n \n*\npathname\n);\n\n\nDIR\n \n*\nfdopendir\n(\nint\n \nfd\n);\n\n\n/* Both return: pointer if OK, NULL on error */\n\n\n\nstruct\n \ndirent\n \n*\nreaddir\n(\nDIR\n \n*\ndp\n);\n\n\n/* Returns: pointer if OK, NULL at end of directory or error */\n\n\n\nvoid\n \nrewinddir\n(\nDIR\n \n*\ndp\n);\n\n\nint\n \nclosedir\n(\nDIR\n \n*\ndp\n);\n\n\n/* Returns: 0 if OK, \u22121 on error */\n\n\n\nlong\n \ntelldir\n(\nDIR\n \n*\ndp\n);\n\n\n/* Returns: current location in directory associated with dp */\n\n\n\nvoid\n \nseekdir\n(\nDIR\n \n*\ndp\n,\n \nlong\n \nloc\n);\n\n\n\n\n\n\nThe \ndirent\n structure defined in \n is implementation dependent, with at least the following two members:\n\n\n    \nino_t\n  \nd_ino\n;\n                 \n/* i-node number */\n\n    \nchar\n   \nd_name\n[];\n              \n/* null-terminated filename */\n\n\n\n\n\n\nThe \nDIR\n structure is an internal structure used by these seven functions to maintain information about the directory being read. The purpose of the DIR structure is similar to that of the \nFILE\n structure maintained by the standard I/O library,\n\n\n\n\nftw8.c\n\n\n\n\nchdir\n, \nfchdir\n, and \ngetcwd\n Functions\n\n\n\n\napue_chdir.h\n\n\n\n\n#include \nunistd.h\n\n\n\nint\n \nchdir\n(\nconst\n \nchar\n \n*\npathname\n);\n\n\nint\n \nfchdir\n(\nint\n \nfd\n);\n\n\n\n/* Both return: 0 if OK, \u22121 on error */\n\n\n\n\n\n\n\n\napue_getcwd.h\n\n\n\n\n#include \nunistd.h\n\n\n\nchar\n \n*\ngetcwd\n(\nchar\n \n*\nbuf\n,\n \nsize_t\n \nsize\n);\n\n\n\n/* Returns: buf if OK, NULL on error */\n\n\n\n\n\n\nDevice Special Files\n\n\n\n\nEvery file system is known by its \nmajor\n and \nminor\n device numbers, which are encoded in the primitive system data type \ndev_t\n.\n\n\nWe can usually access the major and minor device numbers through two macros defined by most implementations: \nmajor\n and \nminor\n.\n\n\n\n\nOn Linux 3.2.0, \ndev_t\n is a 64-bit integer, only 12 bits are used for the major number and 20 bits are used for the minor number. Linux defines these macros in \nsys/sysmacros.h\n, which is included by \nsys/types.h\n.\n\n\nThe \nst_dev\n value for every filename on a system is the device number of the file system containing that filename and its corresponding i-node.\n\n\nOnly character special files and block special files have an \nst_rdev\n value. This value contains the device number for the actual device.\n\n\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nSection 4.21 on \nrmdir\n [p130]:\n\n\n\n\nIf the link count of the directory becomes 0 with this call, and if no other process has the directory open, then the space occupied by the directory is freed. If one or more processes have the directory open when the link count reaches 0, the last link is removed and the dot and dot-dot entries are removed before this function returns. Additionally, no new files can be created in the directory.\n\n\n\n\nDoes \"link count\" here mean number of entries (except dot and dot-dot)? Otherwise, this contradicts  \"any leaf directory (a directory that does not contain any other directories) always has a link count of 2\" in section 4.14 on page 115.", 
            "title": "Chapter 4. Files and Directories"
        }, 
        {
            "location": "/apue/ch5/", 
            "text": "Chapter 5. Standard I/O Library\n\n\nThe standard I/O library handles such details as buffer allocation and performing I/O in optimal-sized chunks.\n\n\nStreams and \nFILE\n Objects\n\n\nStandard I/O file streams can be used with both \nsingle-byte\n and \nmultibyte\n (\"wide\") character sets. A stream\u2019s orientation determines whether the characters that are read and written are single byte or multibyte. \n\n\n\n\nThis book deals only with \nbyte-oriented\n (single byte) streams.\n\n\nThis book refers to a pointer to a \nFILE\n object, the type \nFILE *\n, as a \nfile pointer\n.\n\n\n\n\nStandard Input, Standard Output, and Standard Error\n\n\nThree streams are predefined and automatically available to a process. They refer to file descriptors \nSTDIN_FILENO\n, \nSTDOUT_FILENO\n, and \nSTDERR_FILENO\n (defined in \nunistd.h\n) [p9]. These three standard I/O streams are referenced through the predefined file pointers \nstdin\n, \nstdout\n,and \nstderr\n(defined in \nstdio.h\n).\n\n\nBuffering\n\n\n\n\nFully buffered\n\n\nLine buffered\n\n\nUnbuffered\n\n\n\n\nMost implementations default to the following types of buffering:\n\n\n\n\nStandard error is always unbuffered.\n\n\nAll other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.\n\n\n\n\n\n\n\n\n\nsetbuf\n: \nbuf\n must point to a buffer of length \nBUFSIZ\n, a constant defined in \nstdio.h\n\n\nsetvbuf\n: type of buffering is specified with \n_IOFBF\n, \n_IOLBF\n, \n_IONBF\n.\n\n\n\n\nThe GNU C librarys use the value from the \nst_blksize\n member of the \nstat\n structure to determine the optimal standard I/O buffer size.\n\n\nThe \nfflush\n function causes any unwritten data for the stream to be passed to the kernel. If \nfp\n is \nNULL\n, \nfflush\n causes all output streams to be flushed.\n\n\nOpening a Stream\n\n\n\n\n\n\n\nfdopen\n function is often used with descriptors returned by the functions that create pipes and network communication channels, because these special types of files cannot be opened with the \nfopen\n function.\n\n\n\n\ntype\n argument has 15 values as specifed by ISO C:\n\n\n\n\n\n\n\n\ntype\n\n\nDescription\n\n\nopen\n(2) Flags\n\n\n\n\n\n\n\n\n\n\nr\n, \nrb\n\n\nopen for reading\n\n\nO_RDONLY\n\n\n\n\n\n\nw\n, \nwb\n\n\ntruncate to 0 length or create for writing\n\n\nO_WRONLY\nO_CREAT\nO_TRUNC\n\n\n\n\n\n\na\n, \nab\n\n\nappend; open for writing at end of file, or create for writing\n\n\nO_WRONLY\nO_CREAT\nO_APPEND\n\n\n\n\n\n\nr+\n, \nr+b\n, \nrb+\n\n\nopen for reading and writing\n\n\nO_RDWR\n\n\n\n\n\n\nw+\n, \nw+b\n, \nwb+\n\n\ntruncate to 0 length or create for reading and writing\n\n\nO_RDWR\nO_CREAT\nO_TRUNC\n\n\n\n\n\n\na+\n, \na+b\n, \nab+\n\n\nopen or create for reading and writing at end of file\n\n\nO_RDWR\nO_CREAT\nO_APPEND\n\n\n\n\n\n\n\n\nCharacter \nb\n allows the standard I/O system to differentiate between a text file and a binary file. The UNIX kernel doesn\u2019t differentiate between these types of files, thus character \nb\n has no effect.\n\n\n\n\nWrite\n: The \nfdopen\n function cannot truncate any file it opens for writing\n\n\nAppend\n: each write will take place at the then current end of file. If multiple processes open the same file with the standard I/O append mode, the data from each process will be correctly written to the file\n\n\nRead and write\n (\n+\n sign in type): Output cannot be directly followed by input without an intervening \nfflush\n, \nfseek\n, \nfsetpos\n, or \nrewind\n. Input cannot be directly followed by output without an intervening \nfseek\n, \nfsetpos\n, or \nrewind\n, or an input operation that encounters an end of file.\n\n\n\n\n\n\n\nAn open stream is closed by calling \nfclose\n:\n\n\n\n\nAny buffered output data is flushed before the file is closed\n\n\nAny input data that may be buffered is discarded\n\n\n\n\nWhen a process terminates normally, either by calling the exit function directly or by returning from the main function, all standard I/O streams with unwritten buffered data are flushed and all open standard I/O streams are closed.\n\n\nReading and Writing a Stream\n\n\nUnformatted I/O:\n\n\n\n\nCharacter-at-a-time I/O\n\n\nLine-at-a-time I/O: \nfgets\n and \nfputs\n. Each line is terminated with a newline character.\n\n\nDirect I/O (binary I/O, object-at-a-time I/O, record-oriented I/O, or structure-oriented I/O): \nfread\n and \nfwrite\n. For each I/O operation, we read or write some number of objects, where each object is of a specified size\n\n\n\n\nInput Functions\n\n\n\n\n\n\n\nThe function \ngetchar\n is defined to be equivalent to \ngetc(stdin)\n. \n\n\ngetc\n can be implemented as a macro, whereas \nfgetc\n cannot be implemented as a macro.\n\n\nThese three functions return the next character as an \nunsigned char\n converted to an \nint\n. Thus, all possible character values can be returned, along with an indication that either an error occurred or the end of file has been encountered. The constant EOF in \nstdio.h\n is required to be a negative value. Its value is often \u22121.\n\n\n\n\nThese functions return the same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call either \nferror\n or \nfeof\n:\n\n\n\n\n\nIn most implementations, two flags are maintained for each stream in the \nFILE\n object:\n\n\n\n\nAn error flag\n\n\nAn end-of-file flag\n\n\n\n\nBoth flags are cleared by calling \nclearerr\n.\n\n\nPushback\n\n\nAfter reading from a stream, we can push back characters by calling \nungetc\n.\n\n\n\n\n\n\n\nThe characters that are pushed back are returned by subsequent reads on the stream in reverse order of their pushing.\n\n\nThe character that is pushed back does not have to be the same character that was read.\n\n\nWhen characters are pushed back with \nungetc\n, they are not written back to the underlying file or device. Instead, they are kept incore in the standard I/O library\u2019s buffer for the stream. EOF cannot be pushed back.\n\n\nUsed for peeking characters.\n\n\n\n\nOutput Functions\n\n\n\n\n\n\n\nputchar(c)\n is equivalent to \nputc(c, stdout)\n\n\nputc\n can be implemented as a macro, whereas \nfputc\n cannot be implemented as a macro.\n\n\n\n\nLine-at-a-Time I/O\n\n\n\n\n\n\n\ngets\n function reads from standard input, whereas \nfgets\n reads from the specified stream.\n\n\nfgets\n: reads \nn - 1\n characters (including the newline) or partial line if longer than \nn - 1\n into the buffer, then the buffer is (always) null terminated.\n\n\ngets\n: should never be used. Without specifying buffer size, this may cause buffer to overflow if the line is longer than the buffer, writing over whatever happens to follow the buffer in memory. \ngets\n is marked as an obsolescent interface in SUSv4 and has been omitted from the latest version of the ISO C standard\n\n\n\n\n\n\n\n\n\nfputs\n: writes the null-terminated string to the specified stream without writing the null byte\n\n\nputs\n: writes the null-terminated string to the standard output without writing the null byte, and then writes a newline character to the standard output. \nputs\n should be avoided being used to prevent having to remember whether it appends a newline.\n\n\n\n\nStandard I/O Efficiency\n\n\n\n\n\n\n\n\nFunction\n\n\nUser CPU (seconds)\n\n\nSystem CPU (seconds)\n\n\nClock time (seconds)\n\n\nBytes of program text\n\n\n\n\n\n\n\n\n\n\nbest time from Figure 3.6\n\n\n0.05\n\n\n0.29\n\n\n3.18\n\n\n\n\n\n\n\n\nfgets\n, \nfputs\n\n\n2.27\n\n\n0.30\n\n\n3.49\n\n\n143\n\n\n\n\n\n\ngetc\n, \nputc\n\n\n8.45\n\n\n0.29\n\n\n10.33\n\n\n114\n\n\n\n\n\n\nfgetc\n, \nfputc\n\n\n8.16\n\n\n0.40\n\n\n10.18\n\n\n114\n\n\n\n\n\n\nsingle byte time from Figure 3.6\n\n\n134.61\n\n\n249.94\n\n\n394.95\n\n\n\n\n\n\n\n\n\n\n\n\nOne advantage of using the standard I/O routines is that we don\u2019t have to worry about buffering or choosing the optimal I/O size.\n\n\nUsually, \ngetc\n and \nputc\n are implemented as macros, but in the GNU C library implementation the macro simply expands to a function call.\n\n\nThe line-at-a-time functions are implemented using \nmemccpy(3)\n. Often, the memccpy function is implemented in assembly language instead of C, for efficiency.\n\n\n\n\nBinary I/O\n\n\nIf doing binary I/O, we often want to read or write an entire structure at a time. There are problems with the previous functions:\n\n\n\n\ngetc\n, \nputc\n: we have to loop through the entire structure one byte a time\n\n\nfputs\n: stops writing when it hits a null byte\n\n\nfgets\n: won't work correctly on input if any data bytes are null or newlines\n\n\n\n\n\n\n\nThese functions have two common uses:\n\n\nRead or write a binary array (e.g write elements 2 through 5 of a floating-point array):\n\n\nfloat\n   \ndata\n[\n10\n];\n\n\n\nif\n \n(\nfwrite\n(\ndata\n[\n2\n],\n \nsizeof\n(\nfloat\n),\n \n4\n,\n \nfp\n)\n \n!=\n \n4\n)\n\n    \nerr_sys\n(\nfwrite error\n);\n\n\n\n\n\n\nRead or write a structure:\n\n\nstruct\n \n{\n\n    \nshort\n  \ncount\n;\n\n    \nlong\n   \ntotal\n;\n\n    \nchar\n   \nname\n[\nNAMESIZE\n];\n\n\n}\n \nitem\n;\n\n\n\nif\n \n(\nfwrite\n(\nitem\n,\n \nsizeof\n(\nitem\n),\n \n1\n,\n \nfp\n)\n \n!=\n \n1\n)\n\n    \nerr_sys\n(\nfwrite error\n);\n\n\n\n\n\n\n\n\nfread\n: return value can be less than \nnobj\n if an error occurs or if the end of file is encountered\n\n\nfwrite\n: if the return value is less than the requested \nnobj\n, an error has occurred\n\n\n\n\nThese two functions won't work on different systems (sometimes even on the same system):\n\n\n\n\nThe offset of a member within a structure can differ between compilers and systems because of different \nalignment requirements\n. Even on a single system, the binary layout of a structure can differ, depending on compiler options. [p157]\n\n\nThe binary formats used to store multibyte integers and floating-point values differ among machine architectures\n\n\n\n\nPositioning a Stream\n\n\n\n\n\n\n\nftell\n: return file's position indicator (bytes from the beginning of the file)\n\n\nfseek\n:\n\n\nBinary file: \nwhence\n can be \nSEEK_SET\n, \nSEEK_CUR\n, and \nSEEK_END\n\n\nText file: \nwhence\n has to be \nSEEK_SET\n; \noffset\n can only be 0 (rewind the file to its beginning) or a value that was returned by \nftell\n for that file.\n\n\n\n\n\n\nrewind\n: set the stream to the beginning of the file\n\n\n\n\n\n\n\n\n\n\nFormatted I/O\n\n\nFormatted Output\n\n\n\n\n\n\n\nsprintf\n: automatically appends a null byte at the end of the array, but this null byte is not included in the return value. \nsprintf\n is possible to overflow the buffer.\n\n\nsnprintf\n: returns the number of characters that would have been written to the buffer had it been big enough. If \nsnprintf\n returns a positive value less than the buffer size n, then the output was not truncated.\n\n\n\n\nConversion specification\n\n\n%[flags][fldwidth][precision][lenmodifier]convtype\n\n\n\n\n\n\n\n\n\n\nFlag\n\n\n\n\n\n\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\u2019\n\n\n(apostrophe) format integer with thousands grouping characters\n\n\n\n\n\n\n-\n\n\nleft-justify the output in the field\n\n\n\n\n\n\n+\n\n\nalways display sign of a signed conversion\n\n\n\n\n\n\n(space)\n\n\nprefix by a space if no sign is generated\n\n\n\n\n\n\n#\n\n\nconvert using alternative form (include 0x prefix for hexadecimal format, for example)\n\n\n\n\n\n\n0\n\n\nprefix with leading zeros instead of padding with spaces\n\n\n\n\n\n\n\n\n\n\n\n\nfldwidth\n specifies a minimum field width for the conversion\n\n\n\n\nprecision\n specifies the minimum number of digits to appear for integer conversions, the minimum number of digits to appear to the right of the decimal point for floating-point conversions, or the maximum number of bytes for string conversions\n\n\n\n\nlenmodifier\n pecifies the size of the argument\n\n\n\n\n\n\n\n\nLength modifier\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhh\n\n\nsigned or unsigned \nchar\n\n\n\n\n\n\nh\n\n\nsigned or unsigned \nshort\n\n\n\n\n\n\nl\n\n\nsigned or unsigned \nlong\n or wide character\n\n\n\n\n\n\nll\n\n\nsigned or unsigned \nlong\n \nlong\n\n\n\n\n\n\nj\n\n\nintmax_t\n or \nuintmax_t\n\n\n\n\n\n\nz\n\n\nsize_t\n\n\n\n\n\n\nt\n\n\nptrdiff_t\n\n\n\n\n\n\nL\n\n\nlong double\n\n\n\n\n\n\n\n\n\n\n\n\nconvtype\n is required.\n\n\n\n\n\n\n\n\n\n\n\n\nConversion type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nd\n,\ni\n\n\nsigned decimal\n\n\n\n\n\n\no\n\n\nunsigned octal\n\n\n\n\n\n\nu\n\n\nunsigned decimal\n\n\n\n\n\n\nx\n,\nX\n\n\nunsigned hexadecimal\n\n\n\n\n\n\nf\n,\nF\n\n\ndouble floating-point number\n\n\n\n\n\n\ne\n,\nE\n\n\ndouble floating-point number in exponential format\n\n\n\n\n\n\ng\n,\nG\n\n\ninterpreted as \nf\n, \nF\n, \ne\n, or \nE\n, depending on value converted\n\n\n\n\n\n\na\n,\nA\n\n\ndouble floating-point number in hexadecimal exponential format\n\n\n\n\n\n\nc\n\n\ncharacter (with \nl\n length modifier, wide character)\n\n\n\n\n\n\ns\n\n\nstring (with \nl\n length modifier, wide character string)\n\n\n\n\n\n\np\n\n\npointer to a void\n\n\n\n\n\n\nn\n\n\npointer to a signed integer into which is written the number of characters written so far\n\n\n\n\n\n\n%\n\n\na \n%\n character\n\n\n\n\n\n\nC\n\n\nwide character (XSI option, equivalent to \nlc\n)\n\n\n\n\n\n\nS\n\n\nwide character string (XSI option, equivalent to \nls\n)\n\n\n\n\n\n\n\n\nWith the normal conversion specification, conversions are applied to the arguments in the order they appear after the format argument. An alternative conversion specification syntax allows the arguments to be named explicitly with the sequence \n%n$\n representing the \nn\nth argument.\n\n\nThe following five variants of the printf family are similar to the previous five, but the variable argument list (\n...\n) is replaced with \narg\n.\n\n\n\n\n\nFormatted Output\n\n\n\n\n\nExcept for the conversion specifications and white space, other characters in the format have to match the input. If a character doesn\u2019t match, processing stops, leaving the remainder of the input unread.\n\n\nConversion specification\n\n\n%[*][fldwidth][m][lenmodifier]convtype\n\n\n\n\n\n\n\n\n*\n (leading asterisk) causes the result not stored in an argument\n\n\n\n\nm\n: \nassignment-allocation character\n, used with the \n%c\n, \n%s\n, and \n%[\n to force a memory  buffer to be allocated to hold the converted string. The caller is responsible for freeing the buffer.\n\n\n\n\n\n\nconvtype\n\n\n\n\n\n\n\n\n\n\n\n\nConversion type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nd\n\n\nsigned decimal, base 10\n\n\n\n\n\n\ni\n\n\nsigned decimal, base determined by format of input\n\n\n\n\n\n\no\n\n\nunsigned octal (input optionally signed)\n\n\n\n\n\n\nu\n\n\nunsigned decimal, base 10 (input optionally signed)\n\n\n\n\n\n\nx\n,\nX\n\n\nunsigned hexadecimal (input optionally signed)\n\n\n\n\n\n\na\n,\nA\n,\ne\n,\nE\n,\nf\n,\nF\n,\ng\n,\nG\n\n\nfloating-point number\n\n\n\n\n\n\nc\n\n\ncharacter (with \nl\n length modifier, wide character)\n\n\n\n\n\n\ns\n\n\nstring (with \nl\n length modifier, wide character string)\n\n\n\n\n\n\n[\n\n\nmatches a sequence of listed characters, ending with \n]\n\n\n\n\n\n\n[\u02c6\n\n\nmatches all characters except the ones listed, ending with \n]\n\n\n\n\n\n\np\n\n\npointer to a void\n\n\n\n\n\n\nn\n\n\npointer to a signed integer into which is written the number of characters read so far\n\n\n\n\n\n\n%\n\n\na \n%\n character\n\n\n\n\n\n\nC\n\n\nwide character (XSI option, equivalent to \nlc\n)\n\n\n\n\n\n\nS\n\n\nwide character string (XSI option, equivalent to \nls\n)\n\n\n\n\n\n\n\n\nImplementation Details\n\n\n\n\n\nEach standard I/O stream has an associated file descriptor, and we can obtain the descriptor for a stream by calling \nfileno\n.\n\n\n\n\nFILE\n implementaion in GNU C.\n\n\nbuf.c\n (Figure 5.11): print buffering for various standard I/O streams\n\n\n\n\nResult on OS X 10.10:\n\n\n$ ./buf\nenter any character\n\none line to standard error\nstream = stdin, line buffered, buffer size = 4096\nstream = stdout, line buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n\n$ ./buf \n /etc/group \n std.out 2\n std.err\n$ cat std.out \nenter any character\nstream = stdin, fully buffered, buffer size = 4096\nstream = stdout, fully buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n$ cat std.err \none line to standard error\n\n\n\n\n\nTemporary Files\n\n\n\n\n\n\n\ntmpnam\n: generates a string that is a valid pathname that does not match any existing file. This function generates a different pathname each time it is called, up to \nTMP_MAX\n times. \n\n\nWhen \nptr\n is \nNULL\n: pathname is stored in a static area\n\n\nWhen \nptr\n is not \nNULL\n: it is assumed that it points to an array of at least \nL_tmpnam\n characters. The generated pathname is stored in this array, and \nptr\n is returned as the value of the function.\n\n\n\n\n\n\ntmpfile\n: creates a temporary binary file (type \nwb+\n) that is automatically removed when it is closed or on program termination.\n\n\n\n\n\n\n\n\n\nmkdtemp\n: creates a uniquely named directory\n\n\nmkstemp\n: creates a uniquely named regular file\n\n\ntemplate\n: a pathname whose last six characters are set to \nXXXXXX\n (\n/tmp/dirXXXXXX\n)\n\n\n\n\nUnlike \ntmpfile\n, the temporary file created by \nmkstemp\n is not removed automatically for us.\n\n\nThe \ntmpfile\n and \nmkstemp\n functions should be used instead of \ntmpnam\n. [p169]\n\n\nExample:\n\n\n\n\napue_stdio_mkstemp.c\n: the array variable is allocated on the stacl. For a pointer to a string literal, only the pointer itself resides on the stack; the (constant) string is stored in the read-only segment of the program.\n\n\n\n\nMemory Streams\n\n\nMemory streams\n are standard I/O streams for which there are no underlying files, although they are still accessed with \nFILE\n pointers. All I/O is done by transferring bytes to and from buffers in main memory.\n\n\n\n\n\n\n\nbuf\n: points to the beginning of the user-allocated buffer and the size argument specifies the size of the buffer in bytes. If the buf argument is null, then the fmemopen function allocates a buffer of \nsize\n bytes.\n\n\ntype\n: controls how the stream can be used [p171]\n\n\n\n\nNote:\n\n\n\n\nUnder append mode, the current file position is set to the first null byte in the buffer. If the buffer contains no null bytes, then the current position is set to one byte past the end of the buffer. Under non-append mode, the current position is set to the beginning of the buffer. Thus, memory streams aren\u2019t well suited for storing binary data (which might contain null bytes before the end of the data).\n\n\nIf the \nbuf\n argument is a null pointer, it makes no sense to open the stream for only reading or only writing. Because the buffer is allocated by \nfmemopen\n in this case, there is no way to find the buffer's address\n\n\nA null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call \nfclose\n, \nfflush\n, \nfseek\n, \nfseeko\n, or \nfsetpos\n.\n\n\n\n\nAlternatives to Standard I/O\n\n\nWhen we use the line-at-a-time functions, \nfgets\n and \nfputs\n, the data is usually copied twice: once between the kernel and the standard I/O buffer (when the corresponding read or write is issued) and again between the standard I/O buffer and our line buffer.\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nSection 5.4 on line buffering [p145]\n\n\n\n\nSecond, whenever input is requested through the standard I/O library from either (a) an unbuffered stream or (b) a line-buffered stream (that requires data to be requested from the kernel), all line-buffered output streams are flushed. The reason for the qualifier on (b) is that the requested data may already be in the buffer, which doesn\u2019t require data to be read from the kernel. Obviously, any input from an unbuffered stream, item (a), requires data to be obtained from the kernel.\n\n\n\n\nSection 5.8 Standard I/O Efficiency [p155]\n\n\n\n\nThe version using line-at-a-time I/O is almost twice as fast as the version using character-at-a-time I/O. If the fgets and fputs functions are implemented using getc and putc, then we would expect the timing to be similar to the getc version. Actually, we might expect the line-at-a-time version to take longer, since we would be adding the overhead of 200 million extra function calls to the existing 6 million ones.\n\n\n\n\nSection 5.14 on Memory Stream [p172]\n\n\n\n\nThird, a null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call fclose, fflush, fseek, fseeko, or fsetpos.", 
            "title": "Chapter 5. Standard I/O Library"
        }, 
        {
            "location": "/apue/ch6/", 
            "text": "Chapter 6. System Data Files and Information\n\n\nThis chapter covers portable interfaces to data files, system identification functions and the time and date functions.\n\n\nPassword File\n\n\nThe UNIX System's password file, called the user database by POSIX.1, contains the following fields:\n\n\n\n\nHistorically, the password file has been stored in \n/etc/passwd\n and has been an ASCII file.\n\n\n\n\nroot\n has a user ID of 0 (superuser)\n\n\nThe encrypted password field contains a single character as a placeholder (\nx\n) \n\n\nSome fields can be empty\n\n\nThe shell field contains the user's login shell. The default value for an empty shell field is usually \n/bin/sh\n. Other executable that prevents a user from loggin in to a system:\n\n\n/dev/null\n\n\n/bin/false\n: exits with an unsuccessful (nonzero) status\n\n\n/bin/true\n: exits with a successful (zero) status\n\n\nnologin\n: prints a customizable error message and exits with a nonzero exit status\n\n\n\n\n\n\nnobody\n user name can be used to allow people to log in to a system, but with a user ID (65534) and group ID (65534) that provide no privileges.\n\n\nSome systems that provide the \nfinger(1)\n command support additional information in the comment field\n\n\n\n\nSome systems provide the \nvipw\n command to allow administrators to edit the password file.\n\n\n\n\n\n\n\ngetpwuid\n: used by the \nls(1)\n program to map the numerical user ID contained in an i-node into a user's login name.\n\n\ngetpwnam\n: used by the \nlogin(1)\n program when we enter our login name\n\n\n\n\nBoth functions return a pointer to a passwd structure that the functions fill in. \nThis structure is usually a static variable within the function, so its contents are overwritten each time we call either of these functions.\n\n\n\n\n\n\n\ngetpwent\n: returns the next entry (a pointer to a structure that it has filled in, this structure is overwritten each time we call this function) in the password file.\n\n\nsetpwent\n: rewinds files\n\n\nendpwent\n: closes files\n\n\n\n\nExample:\n\n\n\n\ngetpwnam.c\n\n\n\n\nsetpwent\n at the beginning of this function is self-defense: we ensure that the files are rewound, in case the caller has already opened them by calling getpwent.\n\n\nShadow Passwords\n\n\nSystems store the encrypted password in another file, often called the \nshadow password file\n. Minimally, this file has to contain the user name and the encrypted password.\n\n\n\n\nThe shadow password file should not be readable by the world. Only a few programs need to access encrypted passwords, e.g. \nlogin(1)\n and \npasswd(1)\n, and these programs are often set-user-ID root. With shadow passwords, the regular password file, \n/etc/passwd\n, can be left readable by the world.\n\n\n\n\n\nGroup File\n\n\nThe UNIX System\u2019s group file, called the group database by POSIX.1, contains the following fields:\n\n\n\n\nThe field \ngr_mem\n is an array of pointers to the user names that belong to this group. This array is terminated by a null pointer.\n\n\n\n\n\nLike the password file functions, both of these functions normally return pointers to a static variable, which is overwritten on each call.\n\n\n\n\n\n\n\ngetgrent\n: reads the next entry from the group file, opening the file first, if it\u2019s not already open\n\n\n\n\nSupplementary Group IDs\n\n\nnewgrp(1)\n can be used to change the real group ID to the new group\u2019s ID. We could always go back to our original group (as listed in \n/etc/passwd\n) by executing \nnewgrp\n without any arguments.\n\n\nWith 4.2BSD, the concept of \nsupplementary group IDs\n was introduced. The file access permission checks were modified so that in addition to comparing the the file\u2019s group ID to the process effective group ID, it was also compared to all the supplementary group IDs.\n\n\nThe constant \nNGROUPS_MAX\n specifies the number of supplementary group IDs.\n\n\n\n\n\n\n\ngetgroups\n\n\ngidsetsize\n \n 0: the function fills in the array up to \ngidsetsize\n supplementary group IDs\n\n\ngidsetsize\n = 0: the function returns only the number of supplementary group IDs; \ngrouplist\n is not modified\n\n\n\n\n\n\nsetgroups\n: called by the superuser to set the supplementary group ID list for the calling process\n\n\ninitgroups\n: reads the entire group file with the functions \ngetgrent\n, \nsetgrent\n, and \nendgrent\n and determines the group membership for username.  It then calls setgroups to initialize the supplementary group ID list for the user. It includes \nbasegid\n in the supplementary group ID list; basegid is the group ID from the password file for username. See \nSetting the Group IDs\n\n\n\n\nImplementation Differences\n\n\n[p184-185]\n\n\nOther Data Files\n\n\nNumerous other files are used by UNIX systems in normal day-to-day operation.\n\n\nServices and networks:\n\n\n\n\n/etc/services\n\n\n/etc/protocols\n\n\n/etc/networks\n\n\n\n\nThe general principle is that every data file has at least three functions:\n\n\n\n\nget\n: reads the next record, opening the file\n\n\nset\n: opens the file, if not already open, and rewinds the file\n\n\nend\n: closes the data file\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nData file\n\n\nHeader\n\n\nStructure\n\n\nAdditional keyed lookup functions\n\n\n\n\n\n\n\n\n\n\npasswords\n\n\n/etc/passwd\n\n\npwd.h\n\n\npasswd\n\n\ngetpwnam\n, \ngetpwuid\n\n\n\n\n\n\ngroups\n\n\n/etc/group\n\n\ngrp.h\n\n\ngroup\n\n\ngetgrnam\n, \ngetgrgid\n\n\n\n\n\n\nshadow\n\n\n/etc/shadow\n\n\nshadow.h\n\n\nspwd\n\n\ngetspnam\n\n\n\n\n\n\nhosts\n\n\n/etc/hosts\n\n\nnetdb.h\n\n\nhostent\n\n\ngetnameinfo\n, \ngetaddrinfo\n\n\n\n\n\n\nnetworks\n\n\n/etc/networks\n\n\nnetdb.h\n\n\nnetent\n\n\ngetnetbyname\n, \ngetnetbyaddr\n\n\n\n\n\n\nprotocols\n\n\n/etc/protocols\n\n\nnetdb.h\n\n\nprotoent\n\n\ngetprotobyname\n, \ngetprotobynumber\n\n\n\n\n\n\nservices\n\n\n/etc/services\n\n\nnetdb.h\n\n\nservent\n\n\ngetservbyname\n, \ngetservbyport\n\n\n\n\n\n\n\n\nLogin Accounting\n\n\nTwo data files provided with most UNIX systems:\n\n\n\n\nutmp\n: keeps track of all the users currently logged in\n\n\nwtmp\n: keeps track of all logins and logouts\n\n\n\n\nstruct\n \nutmp\n \n{\n\n    \nchar\n \nut_line\n[\n8\n];\n \n/* tty line: \nttyh0\n, \nttyd0\n, \nttyp0\n, ... */\n\n    \nchar\n \nut_name\n[\n8\n];\n \n/* login name */\n\n    \nlong\n \nut_time\n;\n \n/* seconds since Epoch */\n\n\n};\n\n\n\n\n\n\nOn login, the \nlogin\n program fills one of these structures, and writes it to the \nutmp\n and \nwtmp\n file. On logout, the \ninit\n process erases this entry (fills with null bytes) in \nutmp\n file and appends a new logout entry. This logout entry in the \nwtmp\n file had the \nut_name\n field zeroed out. Special entries were appended to the \nwtmp\n file to indicate when the system was rebooted and right before and after the system\u2019s time and date was changed.\n\n\nThe \nwho(1)\n program read the \nutmp\n file and printed its contents in a readable form\n\n\nSystem Identification\n\n\n\n\n\nstruct\n \nutsname\n \n{\n\n    \nchar\n \nsysname\n[];\n \n/* name of the operating system */\n\n    \nchar\n \nnodename\n[];\n \n/* name of this node */\n\n    \nchar\n \nrelease\n[];\n \n/* current release of operating system */\n\n    \nchar\n \nversion\n[];\n \n/* current version of this release */\n\n    \nchar\n \nmachine\n[];\n \n/* name of hardware type */\n\n\n};\n\n\n\n\n\n\n\n\n\ngethostname\n (now defined as part of POSIX.1) specifies that the maximum host name length is \nHOST_NAME_MAX\n.\n\n\n\n\n\n\n\n\nInterface\n\n\nFreeBSD 8.0\n\n\nLinux 3.2.0\n\n\nMac OS X 10.6.8\n\n\nSolaris 10\n\n\n\n\n\n\n\n\n\n\nuname\n\n\n256\n\n\n65\n\n\n256\n\n\n257\n\n\n\n\n\n\ngethostname\n\n\n256\n\n\n64\n\n\n256\n\n\n256\n\n\n\n\n\n\n\n\nIf the host is connected to a TCP/IP network, the \nhost name is normally the fully qualified domain name of the host.\n\n\nThere is also a \nhostname(1)\n command that can fetch or set the host name. (The host name is set by the superuser using a similar function, \nsethostname\n.) The host name is normally set at bootstrap time from one of the start-up files invoked by \n/etc/rc\n or \ninit\n.\n\n\nTime and Date Routines\n\n\nCalendar times\n: number of seconds (represented in a \ntime_t\n data type) that have passed since the \nEpoch\n: 00:00:00 January 1, 1970, Coordinated Universal Time (UTC). These calendar times represent both the time and the date. The UNIX System has always differed from other operating systems in:\n\n\n\n\nkeeping time in UTC instead of the local time\n\n\nautomatically handling conversions, such as daylight saving time\n\n\nkeeping the time and date as a single quantity\n\n\n\n\nThe \ntime\n function returns the current time and date.\n\n\n\n\n\nThe time value is always returned as the value of the function. If the argument is non-null, the time value is also stored at the location pointed to by \ncalptr\n.\n\n\nThe real-time extensions to POSIX.1 added support for multiple system clocks. A clock is identified by the \nclockid_t\n type. \n\n\n\n\n\n\n\n\nIdentifier\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCLOCK_REALTIME\n\n\n\n\nreal system time\n\n\n\n\n\n\nCLOCK_MONOTONIC\n\n\n_POSIX_MONOTONIC_CLOCK\n\n\nreal system time with no negative jumps\n\n\n\n\n\n\nCLOCK_PROCESS_CPUTIME_ID\n\n\n_POSIX_CPUTIME\n\n\nCPU time for calling process\n\n\n\n\n\n\nCLOCK_THREAD_CPUTIME_ID\n\n\n_POSIX_THREAD_CPUTIME\n\n\nCPU time for calling thread\n\n\n\n\n\n\n\n\n\n\n\n\n\nclock_gettime\n: gets the time of the specified clock. The time is returned in a \ntimespec\n structure\n\n\nclock_getres\n: determines the resolution of a given system clock. It initializes the \ntimespec\n structure pointed to by the \ntsp\n\n\nclock_settime\n: sets the time for a particular clock.\n\n\ngettimeofday\n: now obsolescent. The only legal value for \ntzp\n is \nNULL\n.\n\n\n\n\nOnce we have the integer value that counts the number of seconds since the Epoch, we normally call a function to convert it to a broken-down time structure, and then call another function to generate a human-readable time and date.\n\n\n\n\nThe two functions \nlocaltime\n and \ngmtime\n convert a calendar time into a broken-down time, a \ntm\n structure.\n\n\nstruct\n \ntm\n \n{\n \n/* a broken-down time */\n\n    \nint\n \ntm_sec\n;\n \n/* seconds after the minute: [0 - 60] */\n\n    \nint\n \ntm_min\n;\n \n/* minutes after the hour: [0 - 59] */\n\n    \nint\n \ntm_hour\n;\n \n/* hours after midnight: [0 - 23] */\n\n    \nint\n \ntm_mday\n;\n \n/* day of the month: [1 - 31] */\n\n    \nint\n \ntm_mon\n;\n \n/* months since January: [0 - 11] */\n\n    \nint\n \ntm_year\n;\n \n/* years since 1900 */\n\n    \nint\n \ntm_wday\n;\n \n/* days since Sunday: [0 - 6] */\n\n    \nint\n \ntm_yday\n;\n \n/* days since January 1: [0 - 365] */\n\n    \nint\n \ntm_isdst\n;\n \n/* daylight saving time flag: \n0, 0, \n0 */\n\n\n};\n\n\n\n\n\n\nThe reason that the seconds can be greater than 59 is to allow for a \nleap second\n.\n\n\n\n\n\n\n\ngmtime\n: converts the calendar time to UTC time (broken time)\n\n\nlocaltime\n: converts the calendar time to local time (broken time)\n\n\nmktime\n: takes a broken-down time, expressed as a local time, and converts it into a \ntime_t\n value\n\n\nThe \nstrftime\n and \nstrftime_l\n functions are the same, except that the \nstrftime_l\n function allows the caller to specify the locale as an argument. The strftime function uses the locale specified by the \nTZ\n environment variable\n\n\ntmptr\n argument is the time value to format, specified by a pointer to a broken-down time value. [p192]\n\n\nformat\n argument controls the formatting of the time value\n\n\n\n\n\n\n\n\nConversion specifiers for \nstrftime\n\n\n\n\n\n\n\n\nFormat\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n%a\n\n\nabbreviated weekday name\n\n\nThu\n\n\n\n\n\n\n%A\n\n\nfull weekday name\n\n\nThursday\n\n\n\n\n\n\n%b\n\n\nabbreviated month name\n\n\nJan\n\n\n\n\n\n\n%B\n\n\nfull month name\n\n\nJanuary\n\n\n\n\n\n\n%c\n\n\ndate and time\n\n\nThu Jan 19 21:24:52 2012\n\n\n\n\n\n\n%C\n\n\nyear/100: [00\u201399]\n\n\n20\n\n\n\n\n\n\n%d\n\n\nday of the month: [01\u201331]\n\n\n19\n\n\n\n\n\n\n%D\n\n\ndate [MM/DD/YY]\n\n\n01/19/12\n\n\n\n\n\n\n%e\n\n\nday of month (single digit preceded by space) [1\u201331]\n\n\n19\n\n\n\n\n\n\n%F\n\n\nISO 8601 date format [YYYY\u2013MM\u2013DD]\n\n\n2012-01-19\n\n\n\n\n\n\n%g\n\n\nlast two digits of ISO 8601 week-based year [00\u201399]\n\n\n12\n\n\n\n\n\n\n%G\n\n\nISO 8601 week-based year\n\n\n2012\n\n\n\n\n\n\n%h\n\n\nsame as \n%b\n\n\nJan\n\n\n\n\n\n\n%H\n\n\nhour of the day (24-hour format): [00\u201323]\n\n\n21\n\n\n\n\n\n\n%I\n\n\nhour of the day (12-hour format): [01\u201312]\n\n\n09\n\n\n\n\n\n\n%j\n\n\nday of the year: [001\u2013366]\n\n\n019\n\n\n\n\n\n\n%m\n\n\nmonth: [01\u201312]\n\n\n01\n\n\n\n\n\n\n%M\n\n\nminute: [00\u201359]\n\n\n24\n\n\n\n\n\n\n%n\n\n\nnewline character\n\n\n\n\n\n\n\n\n%p\n\n\nAM/PM\n\n\nPM\n\n\n\n\n\n\n%r\n\n\nlocale\u2019s time (12-hour format)\n\n\n09:24:52 PM\n\n\n\n\n\n\n%R\n\n\nsame as \n%H:%M\n\n\n21:24\n\n\n\n\n\n\n%S\n\n\nsecond: [00\u201360]\n\n\n52\n\n\n\n\n\n\n%t\n\n\nhorizontal tab character\n\n\n\n\n\n\n\n\n%T\n\n\nsame as \n%H:%M:%S\n\n\n21:24:52\n\n\n\n\n\n\n%u\n\n\nISO 8601 weekday [Monday = 1, 1\u20137]\n\n\n4\n\n\n\n\n\n\n%U\n\n\nSunday week number: [00\u201353]\n\n\n03\n\n\n\n\n\n\n%V\n\n\nISO 8601 week number: [01\u201353]\n\n\n03\n\n\n\n\n\n\n%w\n\n\nweekday: [0 = Sunday, 0\u20136]\n\n\n4\n\n\n\n\n\n\n%W\n\n\nMonday week number: [00\u201353]\n\n\n03\n\n\n\n\n\n\n%x\n\n\nlocale\u2019s date 01/19/\n\n\n12\n\n\n\n\n\n\n%X\n\n\nlocale\u2019s time 21:24:\n\n\n52\n\n\n\n\n\n\n%y\n\n\nlast two digits of year: [00\u201399]\n\n\n12\n\n\n\n\n\n\n%Y\n\n\nyear\n\n\n2012\n\n\n\n\n\n\n%z\n\n\noffset from UTC in ISO 8601 format\n\n\n-0500\n\n\n\n\n\n\n%Z\n\n\ntime zone name\n\n\nEST\n\n\n\n\n\n\n%%\n\n\ntranslates to a percent sign\n\n\n%\n\n\n\n\n\n\n\n\n\n\nstrftime\n example: \nstrftime.c\n\n\n\n\nConversion specifiers for \nstrptime\n\n\n\n\n\n\n\n\nFormat\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n%a\n\n\nabbreviated or full weekday name\n\n\n\n\n\n\n%A\n\n\nsame as \n%a\n\n\n\n\n\n\n%b\n\n\nabbreviated or full month name\n\n\n\n\n\n\n%B\n\n\nsame as \n%b\n\n\n\n\n\n\n%c\n\n\ndate and time\n\n\n\n\n\n\n%C\n\n\nall but the last two digits of the year\n\n\n\n\n\n\n%d\n\n\nday of the month: [01\u201331]\n\n\n\n\n\n\n%D\n\n\ndate [MM/DD/YY]\n\n\n\n\n\n\n%e\n\n\nsame as \n%d\n\n\n\n\n\n\n%h\n\n\nsame as \n%b\n\n\n\n\n\n\n%H\n\n\nhour of the day (24-hour format): [00\u201323]\n\n\n\n\n\n\n%I\n\n\nhour of the day (12-hour format): [01\u201312]\n\n\n\n\n\n\n%j\n\n\nday of the year: [001\u2013366]\n\n\n\n\n\n\n%m\n\n\nmonth: [01\u201312]\n\n\n\n\n\n\n%M\n\n\nminute: [00\u201359]\n\n\n\n\n\n\n%n\n\n\nany white space\n\n\n\n\n\n\n%p\n\n\nAM/PM\n\n\n\n\n\n\n%r\n\n\nlocale\u2019s time (12-hour format, AM/PM notation)\n\n\n\n\n\n\n%R\n\n\ntime as \n%H:%M\n\n\n\n\n\n\n%S\n\n\nsecond: [00\u201360]\n\n\n\n\n\n\n%t\n\n\nany white space\n\n\n\n\n\n\n%T\n\n\ntime as \n%H:%M:%S\n\n\n\n\n\n\n%U\n\n\nSunday week number: [00\u201353]\n\n\n\n\n\n\n%w\n\n\nweekday: [0 = Sunday, 0\u20136]\n\n\n\n\n\n\n%W\n\n\nMonday week number: [00\u201353]\n\n\n\n\n\n\n%x\n\n\nlocale\u2019s date\n\n\n\n\n\n\n%X\n\n\nlocale\u2019s time\n\n\n\n\n\n\n%y\n\n\nlast two digits of year: [00\u201399]\n\n\n\n\n\n\n%Y\n\n\nyear\n\n\n\n\n\n\n%%\n\n\ntranslates to a percent sign\n\n\n\n\n\n\n\n\nFunctions that are affected by \nTZ\n environment variable. If defined, the value of this environment variable is used by these functions instead of the default time zone:\n\n\n\n\nlocaltime\n\n\nmktime\n\n\nstrftime", 
            "title": "Chapter 6. System Data Files and Information"
        }, 
        {
            "location": "/apue/ch7/", 
            "text": "Chapter 7. Process Environment\n\n\nIntroduction\n\n\nmain\n Function\n\n\nA C program starts execution with a function called \nmain\n:\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nargv\n[]);\n\n\n\n\n\n\n\n\nargc\n: number of command-line arguments\n\n\nargv\n: an array of pointers to the arguments\n\n\n\n\nWhen a C program is executed by the kernel (by one of the \nexec\n functions), a special start-up routine is called before the \nmain\n function is called. The executable program file specifies this routine as the starting address for the program; this is set up by the link editor (linker) when it is invoked by the C compiler. This start-up routine takes values from the kernel (the command-line arguments and the environment) and sets things up so that the \nmain\n function is called as shown earlier.\n\n\nProcess Termination\n\n\nThere are eight ways for a process to terminate.\n\n\n\n\n\n\nNormal termination occurs in five ways:\n\n\n\n\nReturn from \nmain\n\n\nCalling \nexit\n\n\nCalling \n_exit\n or \n_Exit\n\n\nReturn of the last thread from its start routine (Section 11.5)\n\n\nCalling \npthread_exit\n (Section 11.5) from the last thread\n\n\n\n\n\n\n\n\nAbnormal termination occurs in three ways:\n\n\n\n\nCalling \nabort\n (Section 10.17)\n\n\nReceipt of a signal (Section 10.2)\n\n\nResponse of the last thread to a cancellation request (Sections 11.5 and 12.7)\n\n\n\n\n\n\n\n\nExit Functions\n\n\nThree functions terminate a program normally:\n\n\n\n\n\n\n\n_exit\n: returns to the kernel immediately\n\n\n_Exit\n: same as \n_exit\n\n\nexit\n: performs certain cleanup processing and then returns to the kernel. Historically, it has always performed a clean shutdown of the standard I/O library: the \nfclose\n function is called for all open streams\n\n\n\n\nAll three exit functions expect a single integer argument (\nexit status\n).\n\n\nThe \nexit status of the process is undefined\n, if any of the following occurs:\n\n\n\n\nAny of these functions is called without an exit status\n\n\nmain\n does a return without a return value\n\n\nmain\n function is not declared to return an integer\n\n\n\n\nIf the return type of main is an integer and main \"falls off the end\" (an implicit return), the exit status of the process is 0.\n\n\nReturning an integer value from the main function is equivalent to calling exit with the same value:\n\n\nexit(0);\n is same as \nreturn(0);\n from the \nmain\n function.\n\n\natexit\n Function\n\n\nWith ISO C, a process can register at least 32 functions that are automatically called by \nexit\n. These are called \nexit handlers\n and are registered by calling the \natexit\n function.\n\n\n\n\n\n\n\nfunc\n argument is the address of the function to be called by \nexit\n. When this function is called, it is not passed any arguments and is not expected to return a value. The \nexit\n function calls these functions in reverse order of their registration. Each function is called as many times as it was registered.\n\n\n\n\nWith ISO C and POSIX.1, \nexit\n first calls the exit handlers and then closes (via \nfclose\n) all open streams. POSIX.1 extends the ISO C standard by specifying that any exit handlers installed will be cleared if the program calls any of the \nexec\n family of functions.\n\n\nThe only way a program can be executed by the kernel is if one of the \nexec\n functions is called. \nThe only way a process can voluntarily terminate is if \n_exit\n or \n_Exit\n is called\n, either explicitly or implicitly (by calling \nexit\n). A process can also be involuntarily terminated by a signal.\n\n\nCommand-Line Arguments\n\n\nWhen a program is executed, the process that does the \nexec\n can pass command-line arguments to the new program. This is part of the normal operation of the UNIX system shells.\n\n\nExample:\n\n\n#include \napue.h\n\n\n\nint\n\n\nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nargv\n[])\n\n\n{\n\n    \nint\n \ni\n;\n\n    \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \nargc\n;\n \ni\n++\n)\n \n/* echo all command-line args */\n\n        \nprintf\n(\nargv[%d]: %s\n\\n\n,\n \ni\n,\n \nargv\n[\ni\n]);\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nWe are guaranteed by both ISO C and POSIX.1 that argv[argc] is a null pointer. This lets us alternatively code the argument-processing loop as:\n\n\nfor\n \n(\ni\n \n=\n \n0\n;\n \nargv\n[\ni\n]\n \n!=\n \nNULL\n;\n \ni\n++\n)\n\n\n\n\n\n\nEnvironment List\n\n\nEach program is also passed an environment list, which is an array of character pointers, with each pointer containing the address of a null-terminated C string. It is contained in the global variable environ:\n\n\nextern\n \nchar\n \n**\nenviron\n;\n\n\n\n\n\n\n\n\n\n\nenviron\n is called the \nenvironment pointer\n, the array of pointers the environment list, and the strings they point to the \nenvironment strings\n, which by convention is \nname=value\n strings. By convetion, predefined names are entirely uppercase.\n\n\n\n\nMemory Layout of a C Program\n\n\nHistorically, a C program has been composed of the following pieces:\n\n\n\n\nText segment: consists of the machine instructions that the CPU executes\n\n\nInitialized data segment (or simply data segment): contains variables that are specifically initialized in the program\n\n\nUninitialized data segment (often called the \"bss\" segment, which is named after \"block started by symbol\"): data in this segment is initialized by the kernel to arithmetic 0 or null pointers before the program starts executing\n\n\nStack: stores automatic variables, along with information that is saved each time a function is called\n\n\nHeap is where dynamic memory allocation usually takes place\n\n\n\n\n\n\nWith Linux on a 32-bit Intel x86 processor, the text segment starts at location \n0x08048000\n, and the bottom of the stack starts just below \n0xC0000000\n. \nThe stack grows from higher-numbered addresses to lower-numbered addresses on this particular architecture.\n The unused virtual address space between the top of the heap and the top of the stack is large\n\n\nThe \nsize(1)\n command reports the sizes (in bytes) of the text, data, and bss segments:\n\n\n$ \nsize /usr/bin/cc /bin/sh\ntext data bss dec hex filename\n\n346919\n \n3576\n \n6680\n \n357175\n \n57337\n /usr/bin/cc\n\n102134\n \n1776\n \n11272\n \n115182\n 1c1ee /bin/sh\n\n\n\n\n\nShared Libraries\n\n\nShared libraries remove the common library routines from the executable file and maintains a single copy of the library routine somewhere in memory that all processes reference:\n\n\n\n\nPros: reduces the size of each executable file; library functions can be replaced with new versions without having to relink edit every program that uses the library\n\n\nCons: adds some runtime overhead, either when the program is first executed or the first time each shared library function is called\n\n\n\n\nMemory Allocation\n\n\n\n\n\n\n\nmalloc\n: allocates a specified number of bytes of memory\n\n\ncalloc\n: allocates space for a specified number of objects of a specified size\n\n\nrealloc\n: increases or decreases the size of a previously allocated area. The final argument to realloc is the new size of the region, not the\ndifference between the old and new sizes\n\n\n\n\nThe pointer returned by the three allocation functions is guaranteed to be suitably aligned so that it can be used for any data object.\n\n\nBecause the three \nalloc\n functions return a generic \nvoid *\n pointer, if we \n#include \nstdlib.h\n (to obtain the function prototypes), we do not explicitly have to cast the pointer returned by these functions when we assign it to a pointer of a different type. \nThe default return value for undeclared functions is int, so using a cast without the proper function declaration could hide an error on systems where the size of type int differs from the size of a function\u2019s return value (a pointer in this case).\n\n\n\n\nfree\n: causes the space pointed to by \nptr\n to be deallocated. This freed space is usually put into a pool of available memory and can be allocated in a later call to one of the three \nalloc\n functions.\n\n\n\n\nThe allocation routines are usually implemented with the \nsbrk(2)\n system call. This system call expands (or contracts) the heap of the process. Although \nsbrk\n can expand or contract the memory of a process, most versions of \nmalloc\n and free never decrease their memory size. \nThe space that we free is available for a later allocation, but the freed space is not usually returned to the kernel; instead, that space is kept in the \nmalloc\n pool.\n\n\nAlternate Memory Allocators\n\n\n[p209]\n\n\n\n\nlibmalloc\n\n\nvmalloc\n\n\nquick-fit\n\n\njemalloc\n\n\nTCMalloc\n\n\nalloca\n Function: has the same calling sequence as \nmalloc\n; however, instead of allocating memory from the heap, the memory is allocated from the stack frame of the current function\n\n\n\n\nEnvironment Variables\n\n\nThe environment strings are usually of the form:\n\n\nname=value\n\n\n\n\n\nThe UNIX kernel never looks at these strings; their interpretation is up to the various applications. \n\n\n\n\n\n\n\ngetenv\n: returns a pointer to the value of a \nname=value\n string. We should always use \ngetenv\n to fetch a specific value from the environment, instead of accessing \nenviron\n directly\n\n\n\n\n\n\n\n\nputenv\n: takes a string of the form \nname=value\n and places it in the environment list. If name already exists, its old definition is first removed.\n\n\nsetenv\n: sets \nname\n to \nvalue\n. If name already exists in the environment, then:\n\n\nIf \nrewrite\n is nonzero, the existing definition for \nname\n is first removed\n\n\nIf \nrewrite\n is 0, the existing definition for \nname\n is not removed, \nname\n is not set to the new value, and no error occurs\n\n\n\n\n\n\nunsetenv\n: removes any definition of name. It is not an error if such a definition does not exist.\n\n\n\n\nNote the difference between \nputenv\n and \nsetenv\n. Whereas \nsetenv\n must allocate memory to create the \nname=value\n string from its arguments, \nputenv\n is free to place the string passed to it directly into the environment. Indeed, many implementations do exactly this, so \nit would be an error to pass putenv a string allocated on the stack, since the memory would be reused after we return from the current function.\n\n\n\n\nDeleting a string: we just find the pointer in the environment list and move all subsequent pointers down one.\n\n\nModifying a existing \nname\n:\n\n\nIf new \nvalue\n is smaller than or equal to old: we just copy the string\n\n\nIf new \nvalue\n is larger than old: we must \nmalloc\n and replace the old pointer in the environment list for \nname\n with the pointer to this allocated area\n\n\n\n\n\n\nAdding a new \nname\n:\n\n\nFirst time: we call \nmalloc\n, copy the old environment list to this new area and store a pointer to the \nname=value\n string at the end of\nthis list of pointers. We also store a null pointer at the end of this list, of course. Finally, we set \nenviron\n to point to this new list of pointers. \nIf the original environment list was contained above the top of the stack, as is common, then we have moved this list of pointers to the heap. But most of the pointers in this list still point to \nname=value\n strings above the top of the stack.\n\n\nNot first time: we call \nrealloc\n to allocate room for one more pointer. The pointer to the new \nname=value\n string is stored at the end of the list (on top of the previous null pointer), followed by a null pointer.\n\n\n\n\n\n\n\n\nsetjmp\n and \nlongjmp\n Functions\n\n\nIn C, we can't \ngoto\n a label that\u2019s in another function. Instead, we must use the \nsetjmp\n and \nlongjmp\n functions to perform this type of branching. These two functions are useful for handling error conditions that occur in a deeply nested function call.\n\n\n\n\n\nExamples:\n\n\n\n\ncmd1.c\n\n\ncmd2.c\n\n\n\n\nAutomatic, Register, and Volatile Variables\n\n\nWhen we return to \nmain\n as a result of the \nlongjmp\n, implementations do not try to roll back these automatic variables and register variables (in \nmain\n), though standards say only that their values are indeterminate.\n\n\nExample:\n\n\n\n\ntestjmp.c\n\n\n\n\nCompile the above program, with and without compiler optimizations, the results are different:\n\n\n$ gcc testjmp.c compile without any optimization\n$ ./a.out\nin f1():\nglobval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99\nafter longjmp:\nglobval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99\n$ gcc -O testjmp.c compile with full optimization\n$ ./a.out\nin f1():\nglobval = 95, autoval = 96, regival = 97, volaval = 98, statval = 99\nafter longjmp:\nglobval = 95, autoval = 2, regival = 3, volaval = 98, statval = 99\n\n\n\n\n\nThe optimizations don\u2019t affect the global, static, and volatile variables. The \nsetjmp(3)\n manual page on one system states that variables stored in memory will have values as of the time of the \nlongjmp\n, whereas variables in the CPU and floating-point registers are restored to their values when \nsetjmp\n was called. Without optimization, all five variables are stored in memory. When we enable optimization, both \nautoval\n and \nregival\n go into registers, even though the former wasn't declared \nregister\n, and the \nvolatile\n variable stays in memory.\n\n\nPotential Problem with Automatic Variables\n\n\nAn automatic variable can never be referenced after the function that declared it returns.\n\n\nIncorrect usage of an automatic variable:\n\n\n#include \nstdio.h\n\n\nFILE\n \n*\n\n\nopen_data\n(\nvoid\n)\n\n\n{\n\n    \nFILE\n \n*\nfp\n;\n\n    \nchar\n \ndatabuf\n[\nBUFSIZ\n];\n \n/* setvbuf makes this the stdio buffer */\n\n    \nif\n \n((\nfp\n \n=\n \nfopen\n(\ndatafile\n,\n \nr\n))\n \n==\n \nNULL\n)\n\n        \nreturn\n(\nNULL\n);\n\n    \nif\n \n(\nsetvbuf\n(\nfp\n,\n \ndatabuf\n,\n \n_IOLBF\n,\n \nBUFSIZ\n)\n \n!=\n \n0\n)\n\n        \nreturn\n(\nNULL\n);\n\n    \nreturn\n(\nfp\n);\n \n/* error */\n\n\n}\n\n\n\n\n\n\nThe problem is that when \nopen_data\n returns, the space it used on the stack will be used by the stack frame for the next function that is called. But the standard I/O library will still be using that portion of memory for its stream buffer. Chaos is sure to result. To correct this problem, the array \ndatabuf\n needs to be allocated from global memory, either statically (\nstatic\n or \nextern\n) or dynamically (one of the \nalloc\n functions).\n\n\ngetrlimit\n and \nsetrlimit\n Functions\n\n\nEvery process has a set of resource limits, some of which can be queried and changed by the \ngetrlimit\n and \nsetrlimit\n functions.\n\n\n\n\n\nThese two functions are defined in the XSI option in the Single UNIX Specification. The resource limits for a process are normally established by process 0 when the system is initialized and then inherited by each successive process. Each implementation has its own way of tuning the various limits.\n\n\n\n\nrlptr\n: a pointer to the following structure:\n\n\n\n\nstruct\n \nrlimit\n \n{\n\n    \nrlim_t\n \nrlim_cur\n;\n \n/* soft limit: current limit */\n\n    \nrlim_t\n \nrlim_max\n;\n \n/* hard limit: maximum value for rlim_cur */\n\n\n};\n\n\n\n\n\n\n\n\n\n\nresource\n argument takes on one of the following values:\n\n\n\n\nRLIMIT_AS\n: The maximum size in bytes of a process\u2019s total available memory. This affects the \nsbrk\n function and the \nmmap\n function.\n\n\nRLIMIT_CORE\n: The maximum size in bytes of a core file. A limit of 0 prevents the creation of a core file.\n\n\nRLIMIT_CPU\n: The maximum amount of CPU time in seconds. When the soft limit is exceeded, the SIGXCPU signal is sent to the process.\n\n\nRLIMIT_DATA\n: The maximum size in bytes of the data segment: the sum of the initialized data, uninitialized data, and heap from \nFigure 7.6\n.\n\n\nRLIMIT_FSIZE\n: The maximum size in bytes of a file that may be created.  When the soft limit is exceeded, the process is sent the \nSIGXFSZ\n signal.\n\n\nRLIMIT_MEMLOCK\n: The maximum amount of memory in bytes that a process can lock into memory using \nmlock(2)\n.\n\n\nRLIMIT_MSGQUEUE\n: The maximum amount of memory in bytes that a process can allocate for POSIX message queues.\n\n\nRLIMIT_NICE\n: The limit to which a process\u2019s nice value can be raised to affect its scheduling priority.\n\n\nRLIMIT_NOFILE\n: The maximum number of open files per process. Changing this limit affects the value returned by the \nsysconf\n function for its \n_SC_OPEN_MAX\n argument.\n\n\nRLIMIT_NPROC\n: The maximum number of child processes per real user ID. Changing this limit affects the value returned for \n_SC_CHILD_MAX\n by the \nsysconf\n function.  \n\n\nRLIMIT_NPTS\n: The maximum number of pseudo terminals that a user can have open at one time.\n\n\nRLIMIT_RSS\n: Maximum resident set size (RSS) in bytes. If available physical memory is low, the kernel takes memory from processes that exceed their RSS.\n\n\nRLIMIT_SBSIZE\n: The maximum size in bytes of socket buffers that a user can consume at any given time.\n\n\nRLIMIT_SIGPENDING\n: The maximum number of signals that can be queued for a process. This limit is enforced by the sigqueue function\n\n\nRLIMIT_STACK\n: The maximum size in bytes of the stack. See \nFigure 7.6\n.\n\n\nRLIMIT_SWAP\n: The maximum amount of swap space in bytes that a user can consume.\n\n\nRLIMIT_VMEM\n This is a synonym for \nRLIMIT_AS\n.\n\n\n\n\n\n\n\n\nRules of changing resource limits:\n\n\n\n\nA process can change its soft limit to a value less than or equal to its hard limit.\n\n\nA process can lower its hard limit to a value greater than or equal to its soft limit. \nThis lowering of the hard limit is irreversible for normal users.\n\n\nOnly a superuser process can raise a hard limit.\n\n\n\n\nThe resource limits affect the calling process and are inherited by any of its children. This means that the setting of resource limits needs to be built into the shells to affect all our future processes. Indeed, the Bourne shell, the GNU Bourne-again shell, and the Korn shell have the built-in \nulimit\n command, and the C shell has the built-in limit command. (The \numask\n and \nchdir\n functions also have to be handled as shell built-ins.)\n\n\nExample:\n\n\n\n\ngetrlimit.c\n\n\n\n\nSummary\n\n\nUnderstanding the environment of a C program within a UNIX system\u2019s environment is a prerequisite to understanding the process control features of the UNIX System. This chapter discusses process start and termination, and how a process is passed  an argument list and an environment. Although both the argument list and the environment are uninterpreted by the kernel, it is the kernel that passes both from the caller of \nexec\n to the new process.  This chapter also examines the typical memory layout of a C program and how a process can dynamically allocate and free memory.", 
            "title": "Chapter 7. Process Environment"
        }, 
        {
            "location": "/apue/ch8/", 
            "text": "Chapter 8. Process Control\n\n\nProcess Identifiers\n\n\nEvery process has a unique process ID, a non-negative integer. As processes terminate, their IDs can be reused. \nMost UNIX systems implement algorithms to delay reuse so that newly created processes are assigned IDs different from those used by processes that terminated recently. This prevents a new process from being mistaken for the previous process to have used the same ID.\n\n\nThere are some special processes, but the details differ from implementation to implementation:\n\n\n\n\nProcess ID 0: scheduler process (often known as the \nswapper\n), which is part of the kernel and is known as a system process\n\n\nProcess ID 1: \ninit\n process, invoked by the kernel at the end of the bootstrap procedure.\n\n\nIt is responsible for bringing up a UNIX system after the kernel has been bootstrapped. \ninit\n usually reads the system-dependent initialization files (\n/etc/rc*\n files or \n/etc/inittab\n and the files in \n/etc/init.d\n) and brings the system to a certain state.\n\n\nIt never dies.\n\n\nIt is a normal user process, not a system process within the kernel.\n\n\nIt runs with superuser privileges.\n\n\n\n\n\n\n\n\nEach UNIX System implementation has its own set of kernel processes that provide operating system services.\n For example, on some virtual memory implementations of the UNIX System, process ID 2 is the \npagedaemon\n. This process is responsible for supporting the paging of the virtual memory system.\n\n\n\n\n\nNone of these functions has an error return.\n\n\nfork\n Function\n\n\nAn existing process can create a new one by calling the \nfork\n function.\n\n\n\n\n\n\n\nThe new process created by \nfork\n is called the \nchild process\n. This function is called once but returns twice. The only difference in the returns is that the return value in the child is 0, whereas the return value in the parent is the process ID of the new child. [p299]\n\n\nfork\n returns child's process ID in parent: a process can have more than one child, and \nthere is no function that allows a process to obtain the process IDs of its children\n\n\nfork\n returns 0 in child: \na process can have only a single parent, and the child can always call \ngetppid\n to obtain the process ID of its parent\n\n\n\n\n\n\nBoth the child and the parent continue executing with the instruction that follows the call to \nfork\n. The child is a copy of the parent; the parent and the child do not share these portions of memory. The parent and the child do share the text segment.\n\n\nCopy-on-write (COW) is used on modern implementations: a complete copy of the parent\u2019s data, stack and heap is not performed. The shared regions are changed to read-only by the kernel. The kernel makes a copy of that piece of memory only if either process tries to modify these regions.\n\n\n\n\nVariations of the \nfork\n function are provided by some platforms. All four platforms discussed in this book support the \nvfork(2)\n variant discussed in the next section. Linux 3.2.0 also provides new process creation through the \nclone(2)\n system call. This is a generalized form of \nfork\n that allows the caller to control what is shared between parent and child.\n\n\nExample (\nfork1.c\n):\n\n\n#include \napue.h\n\n\n\nint\n \nglobvar\n \n=\n \n6\n;\n \n/* external variable in initialized data */\n\n\nchar\n \nbuf\n[]\n \n=\n \na write to stdout\n\\n\n;\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \nint\n \nvar\n;\n \n/* automatic variable on the stack */\n\n    \npid_t\n \npid\n;\n\n\n    \nvar\n \n=\n \n88\n;\n\n    \nif\n \n(\nwrite\n(\nSTDOUT_FILENO\n,\n \nbuf\n,\n \nsizeof\n(\nbuf\n)\n-\n1\n)\n \n!=\n \nsizeof\n(\nbuf\n)\n-\n1\n)\n\n        \nerr_sys\n(\nwrite error\n);\n\n    \nprintf\n(\nbefore fork\n\\n\n);\n \n/* we don\u2019t flush stdout */\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n \n/* child */\n\n        \nglobvar\n++\n;\n \n/* modify variables */\n\n        \nvar\n++\n;\n\n    \n}\n \nelse\n \n{\n\n        \nsleep\n(\n2\n);\n \n/* parent */\n\n    \n}\n\n\n    \nprintf\n(\npid = %ld, glob = %d, var = %d\n\\n\n,\n \n(\nlong\n)\ngetpid\n(),\n \nglobvar\n,\n\n           \nvar\n);\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\n$ ./a.out\na write to stdout\nbefore fork\npid = 430, glob = 7, var = 89 # child\u2019s variables were changed\npid = 429, glob = 6, var = 88 # parent\u2019s copy was not changed\n$ ./a.out \n temp.out\n$ cat temp.out\na write to stdout\nbefore fork\npid = 432, glob = 7, var = 89\nbefore fork\npid = 431, glob = 6, var = 88\n\n\n\n\n\nAnalysis:\n\n\n\n\nWhether the child starts executing before the parent or vice versa is not known. The order depends on the scheduling algorithm used by the kernel. If it\u2019s required that the child and parent synchronize their actions, some form of interprocess communication is required.\n\n\nsizeof(buf)-1\n (subtracting 1 from the size of \nbuf\n) avoids writing the terminating null byte. \nstrlen\n calculates the length of a string not including the terminating null byte, while \nsizeof\n calculates the size of the buffer, including the terminating null byte. However, using \nstrlen\n requires a function call, whereas \nsizeof\n calculates the buffer length at compile time.\n\n\n\"a write to stdout\" (once): \nwrite\n function is not buffered and is called before the \nfork\n, its data is written once to standard output\n\n\n\"before fork\" (once in the first case, twice in the second case): \nprintf\n from the standard I/O library is buffered\n\n\nFirst case (running the program interactively): standard I/O is \nline buffered\n and standard output buffer is flushed by the newline\n\n\nSecond case (redirect stdout to a file): standard I/O is \nfully buffered\n. The \nprintf\n (\nprintf(\"before fork\\n\");\n) before the \nfork\n is called once, but the line remains in the buffer when \nfork\n is called. \nThis buffer is then copied into the child when the parent\u2019s data space is copied to the child. Both the parent and the child now have a standard I/O buffer with this line in it.\n The second \nprintf\n (\nprintf(\"pid = %ld, glob = %d, var = %d\\n\", ...);\n), right before the exit, just appends its data to the existing buffer. When each process terminates, its copy of the buffer is finally flushed.\n\n\n\n\n\n\n\n\nFile Sharing\n\n\nOne characteristic of \nfork\n is that all file descriptors that are open in the parent are duplicated in the child, because it\u2019s as if the \ndup\n function had been called for each descriptor. The parent and the child shareafile table entry for every open descriptor.\n\n\nFor a process that has three different files opened for standard input, standard output, and standard error, on return from \nfork\n, we have the arrangement shown below:\n\n\n\n\nIt is important that the parent and the child share the same file offset. Otherwise, this type of interaction would be more difficult to accomplish and would require explicit actions by the parent.\n\n\nThere are two normal cases for handling the descriptors after a \nfork\n:\n\n\n\n\nThe parent waits for the child to complete.\n\n\nBoth the parent and the child go their own ways. After the fork, both the parent and child close the descriptors that they don't need, so neither interferes with the other\u2019s open descriptors. This scenario is often found with network servers.\n\n\n\n\nBesides the open files, other properties of the parent are inherited by the child:\n\n\n\n\nReal user ID, real group ID, effective user ID, and effective group ID\n\n\nSupplementary group IDs\n\n\nProcess group ID\n\n\nSession ID\n\n\nControlling terminal\n\n\nThe set-user-ID and set-group-ID flags\n\n\nCurrent working directory\n\n\nRoot directory\n\n\nFile mode creation mask\n\n\nSignal mask and dispositions\n\n\nThe close-on-exec flag for any open file descriptors\n\n\nEnvironment\n\n\nAttached shared memory segments\n\n\nMemory mappings\n\n\nResource limits\n\n\n\n\nThe differences between the parent and child are:\n\n\n\n\nThe return values from fork are different.\n\n\nThe process IDs are different.\n\n\nThe two processes have different parent process IDs: the parent process ID of the child is the parent; the parent process ID of the parent doesn\u2019t change.\n\n\nThe child\u2019s \ntms_utime\n, \ntms_stime\n, \ntms_cutime\n, and \ntms_cstime\n values are set to 0 (these times are discussed in Section 8.17).\n\n\nFile locks set by the parent are not inherited by the child.\n\n\nPending alarms are cleared for the child.\n\n\nThe set of pending signals for the child is set to the empty set\n\n\n\n\nThe two main reasons for \nfork\n to fail\n\n\n\n\nIf too many processes are already in the system, which usually means that something else is wrong\n\n\nIf the total number of processes for this real user ID exceeds the system\u2019s limit. (\nCHILD_MAX\n specifies the maximum number of simultaneous processes per real user ID.)\n\n\n\n\nThe two uses for \nfork\n\n\n\n\nWhen a process wants to duplicate itself so that the parent and the child can each execute different sections of code at the same time.\n\n\nThis is common for network servers\u2014the parent waits for a service request from a client. When the request arrives, the parent calls \nfork\n and lets the child handle the request. The parent goes back to waiting for the next service request to arrive.\n\n\n\n\n\n\nWhen a process wants to execute a different program.\n\n\nThis is common for shells. In this case, the child does an \nexec\n right after it returns from the \nfork\n.\n\n\n\n\n\n\n\n\nSome operating systems combine the operations from step 2, a \nfork\n followed by an \nexec\n, into a single operation called a \nspawn\n. The UNIX System separates the two, as there are numerous cases where it is useful to \nfork\n without doing an \nexec\n. Also, separating the two operations allows the child to change the per-process attributes between the \nfork\n and the \nexec\n, such as I/O redirection, user ID, signal disposition, and so on\n\n\nvfork\n Function\n\n\nThe function \nvfork\n has the same calling sequence and same return values as \nfork\n, but the semantics of the two functions differ.\n\n\nThe \nvfork\n function was intended to create a new process for the purpose of executing a new program (step 2 at the end of the previous section). \nThe \nvfork\n function creates the new process, just like \nfork\n, without copying the address space of the parent into the child\n, as the child won\u2019t reference that address space; the child simply calls \nexec\n (or \nexit\n) right after the \nvfork\n. Instead, \nthe child runs in the address space of the parent until it calls either \nexec\n or \nexit\n.\n\n\nThis optimization is more efficient on some implementations of the UNIX System, but leads to undefined results if the child:\n\n\n\n\nmodifies any data (except the variable used to hold the return value from \nvfork\n)\n\n\nmakes function calls\n\n\nreturns without calling \nexec\n or \nexit\n\n\n\n\nAnother difference between the two functions is that \nvfork\n guarantees that the child runs first, until the child calls \nexec\n or \nexit\n. When the child calls either of these functions, the parent resumes. (This can lead to deadlock if the child depends on further actions of the parent before calling either of these two functions.)\n\n\nExample (\nvfork1.c\n)\n\n\nThe program is a modified version of the program from \nfork1.c\n. We\u2019ve replaced the call to \nfork\n with \nvfork\n and removed the write to standard output. Also, we don\u2019t need to have the parent call \nsleep\n, as we\u2019re guaranteed that it is put to sleep by the kernel until the child calls either \nexec\n or \nexit\n.\n\n\n#include \napue.h\n\n\n\nint\n \nglobvar\n \n=\n \n6\n;\n \n/* external variable in initialized data */\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \nint\n \nvar\n;\n \n/* automatic variable on the stack */\n\n    \npid_t\n \npid\n;\n\n\n    \nvar\n \n=\n \n88\n;\n\n    \nprintf\n(\nbefore vfork\n\\n\n);\n \n/* we don\u2019t flush stdio */\n\n    \nif\n \n((\npid\n \n=\n \nvfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nvfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n \n/* child */\n\n        \nglobvar\n++\n;\n \n/* modify parent\u2019s variables */\n\n        \nvar\n++\n;\n\n        \n_exit\n(\n0\n);\n \n/* child terminates */\n\n    \n}\n\n\n    \n/* parent continues here */\n\n    \nprintf\n(\npid = %ld, glob = %d, var = %d\n\\n\n,\n \n(\nlong\n)\ngetpid\n(),\n \nglobvar\n,\n\n           \nvar\n);\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nRunning this program gives us\n\n\n$ ./a.out\nbefore vfork\npid = 29039, glob = 7, var = 89\n\n\n\n\n\nAnalysis:\n\n\n\n\nThe incrementing of the variables done by the child changes the values in the parent. Because the child runs in the address space of the parent.\n\n\n_exit\n is called instead of \nexit\n, because \n_exit\n does not perform any flushing of standard I/O buffers. If we call \nexit\n instead, the results are indeterminate. Depending on the implementation of the standard I/O library, we might see no difference in the output, or we might find that the output from the \nfirst \nprintf\n (see \nDoubts and Solutions\n) in the parent has disappeared.\n\n\nIf the implementation only flushes the standard I/O streams, then we will see no difference from the output generated if the child called \n_exit\n.\n\n\nIf the implementation also closes the standard I/O streams, however, the memory representing the \nFILE\n object for the standard output will be cleared out. Because the child is borrowing the parent\u2019s address space, when the parent resumes and calls \nprintf\n, no output will appear and \nprintf\n will return \u22121.\n\n\nThe parent\u2019s \nSTDOUT_FILENO\n is still valid, as the child gets a copy of the parent\u2019s file descriptor array\n\n\n\n\n\n\n\n\nMost modern implementations of \nexit\n do not close the streams. Because the process is about to exit, the kernel will close all the file descriptors open in the process. Closing them in the library simply adds overhead without any benefit.\n\n\nexit\n Functions\n\n\nA process can terminate normally in five ways (as described in \nSection 7.3\n):\n\n\n\n\nExecuting a return from the \nmain\n function. This is equivalent to calling \nexit\n.\n\n\nCalling the exit function, which includes the calling of all exit handlers that have been registered by calling \natexit\n and closing all standard I/O streams.\n\n\nISO C does not deal with file descriptors, multiple processes (parents and children), and job control. The definition of this function is incomplete for a UNIX system.\n\n\n\n\n\n\nCalling the \n_exit\n or \n_Exit\n function.\n\n\n_Exit\n: defined by ISO C to provide a way for a process to terminate without running exit handlers or signal handlers\n\n\n_exit\n: called by \nexit\n and handles the UNIX system-specific details; \n_exit\n is specified by POSIX.1.\n\n\nWhether standard I/O streams are flushed depends on the implementation.\n\n\nOn UNIX systems, \n_Exit\n and \n_exit\n are synonymous and do not flush standard I/O streams.\n\n\n\n\n\n\nExecuting a \nreturn\n from the start routine of the last thread in the process.\n\n\nThe return value of the thread is not used as the return value of the process. When the last thread returns from its start routine, the process exits with a termination status of 0.\n\n\n\n\n\n\nCalling the \npthread_exit\n function from the last thread in the process.\n\n\n\n\nThe three forms of abnormal termination:\n\n\n\n\nCalling \nabort\n. This is a special case of the next item, as it generates the \nSIGABRT\n signal.\n\n\nWhen the process receives certain signals. The signal can be generated by:\n\n\nthe process itself, e.g. calling the \nabort\n function\n\n\nsome other processes\n\n\nthe kernel, e.g. the process references a memory location not within its address space or tries to divide by 0\n\n\n\n\n\n\nThe last thread responds to a cancellation request. By default, cancellation occurs in a deferred manner: one thread requests that another be canceled, and sometime later the target thread terminates.\n\n\n\n\nRegardless of how a process terminates, the same code in the kernel is eventually executed. This kernel code closes all the open descriptors for the process, releases the memory that it was using, and so on.\n\n\nThe terminating process is to be able to notify its parent how it terminated by by passing an exit status as the argument to one of the three exit functions. In the case of an abnormal termination, the kernel (not the process) generates a termination status to indicate the reason for the abnormal termination. In any case, the parent of the process can obtain the termination status from either the \nwait\n or the \nwaitpid\n function.\n\n\nExit status vs. termination status\n\n\n\n\nExit status\n: is the argument to one of the three exit functions or the return value from main.\n\n\nTermination status\n: the exit status is converted into a termination status by the kernel when \n_exit\n is finally called. If the child terminated normally, the parent can obtain the exit status of the child.\n\n\n\n\nOrphan process\n\n\nOrphan process\n (or \norphaned child process\n) is any process whose parent terminates.\n\n\nThe child has a parent process after the call to \nfork\n. What happens if the parent terminates before the child? The answer is the \ninit\n process becomes the parent process of any process whose parent terminates. This is called \"the process has been inherited by \ninit\n\". Whenever a process terminates, the kernel goes through all active processes to see whether the terminating process is the parent of any process that still exists. If so, the parent process ID of the surviving process is changed to be 1 (the process ID of \ninit\n). This way, it's guaranteed that every process has a parent.\n\n\nZombie process\n\n\nZombie process\n is a process that has terminated, but whose parent has not yet waited for it. The \nps(1)\n command prints the state of a zombie process\nas \nZ\n.\n\n\nWhat happens when a child terminates before its parent?\n\n\nIf the child completely disappeared, the parent wouldn\u2019t be able to fetch its termination status when and if the parent was finally ready to check if the child had terminated. The kernel keeps a small amount of information for every terminating process, so that the information is available when the parent of the terminating process calls \nwait\n or \nwaitpid\n. This information consists of the process ID, the termination status of the process, and the amount of CPU time taken by the process. The kernel can discard all the memory used by the process and close its open files.\n\n\ninit\n's children\n\n\nWhat happens when a process that has been inherited by \ninit\n terminates? It does not become a zombie. \ninit\n is written so that whenever one of its children terminates, \ninit\n calls one of the \nwait\n functions to fetch the termination status. By doing this, init prevents the system from being clogged by zombies.\n\n\nOne of init\u2019s children refers to either of the following:\n\n\n\n\nA process that \ninit\n generates directly (e.g. \ngetty\n)\n\n\nA process whose parent has terminated and has been subsequently inherited by \ninit\n.\n\n\n\n\nwait\n and \nwaitpid\n Functions\n\n\nWhen a process terminates, either normally or abnormally, the kernel notifies the parent by sending the \nSIGCHLD\n signal to the parent.\n Because the termination of a child is an asynchronous event (it can happen at any time while the parent is running). This signal is the asynchronous notification from the kernel to the parent. The parent can choose to ignore this signal, or it can provide a function that is called when the signal occurs: a signal handler. \nThe default action for this signal is to be ignored.\n\n\nA process that calls \nwait\n or \nwaitpid\n can:\n\n\n\n\nBlock, if all of its children are still running\n\n\nReturn immediately with the termination status of a child, if a child has terminated and is waiting for its termination status to be fetched\n\n\nReturn immediately with an error, if it doesn\u2019t have any child processes\n\n\n\n\nIf the process is calling \nwait\n because it received the \nSIGCHLD\n signal, we expect wait to return immediately. But if we call it at any random point in time, it can block.\n\n\n\n\n\nThe differences between these two functions are:\n\n\n\n\nThe \nwait\n function can block the caller until a child process terminates, whereas \nwaitpid\n has an option that prevents it from blocking.\n\n\nThe \nwaitpid\n function doesn\u2019t wait for the child that terminates first; it has a number of options that control which process it waits for.\n\n\n\n\nIf a child has already terminated and is a zombie, \nwait\n returns immediately with that child\u2019s status. Otherwise, it blocks the caller until a child terminates. If the caller blocks and has multiple children, \nwait\n returns when one terminates. We can always tell which child terminated, because the process ID is returned by the function.\n\n\nThe argument \nstatloc\n is is a pointer to an integer. If this argument is not a null pointer, the termination status of the terminated process is stored in the location pointed to by the argument.\n\n\nThe integer status that these two functions return has been defined by the implementation, with certain bits indicating the exit status (for a normal return), other bits indicating the signal number (for an abnormal return), one bit indicating whether a core file was generated, and so on.\n\n\nFour mutually exclusive macros are defined in \nsys/wait.h\n to tell us how the process terminated, and they all begin with \nWIF\n. Based on which of these four macros is true, other macros are used to obtain the exit status, signal number, and the like.\n\n\nMacros to examine the termination status returned by \nwait\n and \nwaitpid\n:\n\n\n\n\n\n\n\n\nMacro\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nWIFEXITED(status)\n\n\nTrue if status was returned for a child that terminated normally. In this case, we can execute \nWEXITSTATUS(status)\n to fetch the low-order 8 bits of the argument that the child passed to \nexit\n, \n_exit\n, or \n_Exit\n.\n\n\n\n\n\n\nWIFSIGNALED(status)\n\n\nTrue if status was returned for a child that terminated abnormally, by receipt of a signal that it didn\u2019t catch. In this case, we can execute \nWTERMSIG(status)\n to fetch the signal number that caused the termination. Additionally, some implementations (but not the Single UNIX Specification) define the macro \nWCOREDUMP(status)\n that returns true if a core file of the terminated process was generated.\n\n\n\n\n\n\nWIFSTOPPED(status)\n\n\nTrue if status was returned for a child that is currently stopped. In this case, we can execute \nWSTOPSIG(status)\n to fetch the signal number that caused the child to stop.\n\n\n\n\n\n\nWIFCONTINUED(status)\n\n\nTrue if status was returned for a child that has been continued after a job control stop (XSI option; \nwaitpid\n only).\n\n\n\n\n\n\n\n\nThe function \npr_exit\n uses these macros (above) to print a description of the termination status.\n\n\n\n\nlib/prexit.c\n\n\n\n\n#include \napue.h\n\n\n#include \nsys/wait.h\n\n\n\nvoid\n\n\npr_exit\n(\nint\n \nstatus\n)\n\n\n{\n\n    \nif\n \n(\nWIFEXITED\n(\nstatus\n))\n\n        \nprintf\n(\nnormal termination, exit status = %d\n\\n\n,\n\n                \nWEXITSTATUS\n(\nstatus\n));\n\n    \nelse\n \nif\n \n(\nWIFSIGNALED\n(\nstatus\n))\n\n        \nprintf\n(\nabnormal termination, signal number = %d%s\n\\n\n,\n\n                \nWTERMSIG\n(\nstatus\n),\n\n\n#ifdef  WCOREDUMP\n\n                \nWCOREDUMP\n(\nstatus\n)\n \n?\n \n (core file generated)\n \n:\n \n);\n\n\n#else\n\n                \n);\n\n\n#endif\n\n    \nelse\n \nif\n \n(\nWIFSTOPPED\n(\nstatus\n))\n\n        \nprintf\n(\nchild stopped, signal number = %d\n\\n\n,\n\n                \nWSTOPSIG\n(\nstatus\n));\n\n\n}\n\n\n\n\n\n\n\n\nwait1.c\n\n\n\n\n#include \napue.h\n\n\n#include \nsys/wait.h\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \npid_t\n   \npid\n;\n\n    \nint\n     \nstatus\n;\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n\n        \nerr_sys\n(\nfork error\n);\n\n    \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n              \n/* child */\n\n        \nexit\n(\n7\n);\n\n\n    \nif\n \n(\nwait\n(\nstatus\n)\n \n!=\n \npid\n)\n       \n/* wait for child */\n\n        \nerr_sys\n(\nwait error\n);\n\n    \npr_exit\n(\nstatus\n);\n                \n/* and print its status */\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n\n        \nerr_sys\n(\nfork error\n);\n\n    \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n              \n/* child */\n\n        \nabort\n();\n                    \n/* generates SIGABRT */\n\n\n    \nif\n \n(\nwait\n(\nstatus\n)\n \n!=\n \npid\n)\n       \n/* wait for child */\n\n        \nerr_sys\n(\nwait error\n);\n\n    \npr_exit\n(\nstatus\n);\n                \n/* and print its status */\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n\n        \nerr_sys\n(\nfork error\n);\n\n    \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n              \n/* child */\n\n        \nstatus\n \n/=\n \n0\n;\n                \n/* divide by 0 generates SIGFPE */\n\n\n    \nif\n \n(\nwait\n(\nstatus\n)\n \n!=\n \npid\n)\n       \n/* wait for child */\n\n        \nerr_sys\n(\nwait error\n);\n\n    \npr_exit\n(\nstatus\n);\n                \n/* and print its status */\n\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nResults:\n\n\n$ ./a.out\nnormal termination, exit status = 7\nabnormal termination, signal number = 6 (core file generated)\nabnormal termination, signal number = 8 (core file generated)\n\n\n\n\n\nWe print the signal number from \nWTERMSIG\n. We can look at the \nsignal.h\n header to verify that \nSIGABRT\n has a value of 6 and that \nSIGFPE\n has a value of 8.\n\n\nwait\n for a specific process: \nwaitpid\n\n\nIf we have more than one child, \nwait\n returns on termination of any of the children. If we want to wait for a specific process to terminate (assuming we know which process ID we want to wait for), in older versions of the UNIX System, we would have to call \nwait\n and compare the returned process ID with the one we\u2019re interested in. The POSIX.1 \nwaitpid\n function can be used to wait for a specific process.\n\n\nThe interpretation of the pid argument for waitpid depends on its value:\n\n\n\n\npid\n == \u22121 - Waits for any child process. In this respect, \nwaitpid\n is equivalent to \nwait\n.\n\n\npid\n \n 0 - Waits for the child whose process ID equals \npid\n.\n\n\npid\n == 0 - Waits for any child whose \nprocess group ID\n equals that of the calling process.\n\n\npid\n \n \u22121 - Waits for any child whose process group ID equals the absolute value of \npid\n.\n\n\n\n\nThe \nwaitpid\n function returns the process ID of the child that terminated and stores the child\u2019s termination status in the memory location pointed to by \nstatloc\n.\n\n\nErrors of \nwait\n and \nwaitpid\n\n\n\n\nWith \nwait\n, the only real error is if the calling process has no children. (Another error return is possible, in case the function call is interrupted by a signal) [p242]\n\n\nWith \nwaitpid\n, it\u2019s possible to get an error if the specified process or process group does not exist or is not a child of the calling process\n\n\n\n\noptions\n argument of \nwaitpid\n\n\nThe \noptions\n argument either is 0 or is constructed from the bitwise OR of the constants in the table below.\n\n\nThe \noptions\n constants for \nwaitpid\n:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nWCONTINUED\n\n\nIf the implementation supports job control, the status of any child specified by \npid\n that has been continued after being stopped, but whose status has not yet been reported, is returned (XSI option).\n\n\n\n\n\n\nWNOHANG\n\n\nThe \nwaitpid\n function will not block if a child specified by \npid\n is not immediately available. In this case, the return value is 0.\n\n\n\n\n\n\nWUNTRACED\n\n\nIf the implementation supports job control, the status of any child specified by \npid\n that has stopped, and whose status has not been reported since it has stopped, is returned. The \nWIFSTOPPED\n macro determines whether the return value corresponds to a stopped child process.\n\n\n\n\n\n\n\n\nThe \nwaitpid\n function provides three features that aren\u2019t provided by the \nwait\n function:\n\n\n\n\nThe \nwaitpid\n function lets us wait for one particular process, whereas the \nwait\n function returns the status of any terminated child (\npopen\n function)\n\n\nThe \nwaitpid\n function provides a nonblocking version of \nwait\n. There are times when we want to fetch a child\u2019s status, but we don\u2019t want to block.\n\n\nThe \nwaitpid\n function provides support for job control with the \nWUNTRACED\n and \nWCONTINUED\n options.\n\n\n\n\nfork\n twice\n\n\nExample (\nfork2.c\n)\n\n\nIf we want to write a process so that it \nfork\ns a child but we don\u2019t want to wait for the child to complete and we don\u2019t want the child to become a zombie until we terminate, \nthe trick is to call \nfork\n twice.\n\n\n#include \napue.h\n\n\n#include \nsys/wait.h\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \npid_t\n   \npid\n;\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n      \n/* first child */\n\n        \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n\n            \nerr_sys\n(\nfork error\n);\n\n        \nelse\n \nif\n \n(\npid\n \n \n0\n)\n\n            \nexit\n(\n0\n);\n    \n/* parent from second fork == first child */\n\n\n        \n/*\n\n\n         * We\nre the second child; our parent becomes init as soon\n\n\n         * as our real parent calls exit() in the statement above.\n\n\n         * Here\ns where we\nd continue executing, knowing that when\n\n\n         * we\nre done, init will reap our status.\n\n\n         */\n\n        \nsleep\n(\n2\n);\n\n        \nprintf\n(\nsecond child, parent pid = %ld\n\\n\n,\n \n(\nlong\n)\ngetppid\n());\n\n        \nexit\n(\n0\n);\n\n    \n}\n\n\n    \nif\n \n(\nwaitpid\n(\npid\n,\n \nNULL\n,\n \n0\n)\n \n!=\n \npid\n)\n   \n/* wait for first child */\n\n        \nerr_sys\n(\nwaitpid error\n);\n\n\n    \n/*\n\n\n     * We\nre the parent (the original process); we continue executing,\n\n\n     * knowing that we\nre not the parent of the second child.\n\n\n     */\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nResults:\n\n\n$ ./a.out\n$ second child, parent pid = 1\n\n\n\n\n\nAnalysis:\n\n\nWe call \nsleep\n in the second child to ensure that the first child terminates before printing the parent process ID. After a \nfork\n, either the parent or the child can continue executing; we never know which will resume execution first. If we didn\u2019t put the second child to sleep, and if it resumed execution after the \nfork\n before its parent, the parent process ID that it printed would be that of its parent, not process ID 1.\n\n\nNote that the shell prints its prompt when the original process terminates, which is before the second child prints its parent process ID.\n\n\nwaitid\n Function\n\n\nThe Single UNIX Specification includes an additional \nwaitid\n function to retrieve the exit status of a process.\n\n\n\n\napue_waitid.h\n\n\n\n\n\n\n\nLike \nwaitpid\n, \nwaitid\n allows a process to specify which children to wait for. Instead of encoding this information in a single argument combined with the process ID or process group ID, two separate arguments are used. The \nid\n parameter is interpreted based on the value of \nidtype\n.\n\n\n\n\n\n\nThe \nidtype\n constants for \nwaitid\n:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nP_PID\n\n\nWait for a particular process: \nid\n contains the process ID of the child to wait for.\n\n\n\n\n\n\nP_PGID\n\n\nWait for any child process in a particular process group: \nid\n contains the process group ID of the children to wait for.\n\n\n\n\n\n\nP_ALL\n\n\nWait for any child process: \nid\n is ignored.\n\n\n\n\n\n\n\n\n\n\n\n\nThe \noptions\n argument is a bitwise OR of the flags shown below:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nWCONTINUED\n\n\nWait for a process that has previously stopped and has been continued, and whose status has not yet been reported.\n\n\n\n\n\n\nWEXITED\n\n\nWait for processes that have exited.\n\n\n\n\n\n\nWNOHANG\n\n\nReturn immediately instead of blocking if there is no child exit status available.\n\n\n\n\n\n\nWNOWAIT\n\n\nDon\u2019t destroy the child exit status. The child\u2019s exit status can be retrieved by a subsequent call to \nwait\n, \nwaitid\n, or \nwaitpid\n.\n\n\n\n\n\n\nWSTOPPED\n\n\nWait for a process that has stopped and whose status has not yet been reported.\n\n\n\n\n\n\n\n\nAt least one of \nWCONTINUED\n, \nWEXITED\n, or \nWSTOPPED\n must be specified in the options argument.\n\n\n\n\n\n\nThe \ninfop\n argument is a pointer to a \nsiginfo\n structure. This structure contains detailed information about the signal generated that caused the state change in the child process (Section 10.14)\n\n\n\n\n\n\nwait3\n and \nwait4\n Functions\n\n\nMost UNIX system implementations provide two additional functions: \nwait3\n and \nwait4\n, with an additional argument \nrusage\n that allows the kernel to return a summary of the resources used by the terminated process and all its child processes.\n\n\n\n\napue_wait3.h\n\n\n\n\n\n\n\nThe resource information includes such statistics as the amount of user CPU time, amount of system CPU time, number of page faults, number of signals received, and the like. Refer to the \ngetrusage(2)\n manual page for additional details.\n\n\nRace Conditions\n\n\nA \nrace condition\n occurs when multiple processes are trying to do something with shared data and the final outcome depends on the order in which the processes run. The \nfork\n function is a lively breeding ground for race conditions, \nif any of the logic after the \nfork\n depends on whether the parent or child runs first. In general, we cannot predict which process runs first. Even if we knew which process would run first, what happens after that process starts running depends on the system load and the kernel\u2019s scheduling algorithm.\n\n\nWe saw a potential race condition in the program in \nFigure 8.8\n when the second child printed its parent process ID.\n\n\n\n\nIf the second child runs before the first child, then its parent process will be the first child.\n\n\nIf the first child runs first and has enough time to \nexit\n, then the parent process of the second child is init.\n\n\nIf the system was heavily loaded, the second child could resume after sleep returns, before the first child has a chance to run, calling \nsleep\n  guarantees nothing.\n\n\n\n\nProblems of this form can be difficult to debug because they tend to work \"most of the time\".\n\n\n\n\nA process that wants to wait for a child to terminate must call one of the \nwait\n functions.\n\n\nA process that wants to wait for its parent to terminate can use a loop in the following form:\n\n\n\n\nwhile\n \n(\ngetppid\n()\n \n!=\n \n1\n)\n\n    \nsleep\n(\n1\n);\n\n\n\n\n\n\nThe problem with this type of loop, called \npolling\n, is that it wastes CPU time, as the caller is awakened every second to test the condition.\n\n\nTo avoid race conditions and to avoid polling, some form of signaling is required between multiple processes:\n\n\n\n\nSignals can be used for this purpose\n\n\nInterprocess communication (IPC) can also be used\n\n\n\n\nFor a parent and child relationship, we often have the following scenario. After the \nfork\n, both the parent and the child have something to do. For example, the parent could update a record in a log file with the child\u2019s process ID, and the child might have to create a file for the parent. In this example, we require that each process tell the other when it has finished its initial set of operations, and that each wait for the other to complete, before heading off on its own. The following code illustrates this scenario:\n\n\n#include \napue.h\n\n\n\nTELL_WAIT\n();\n \n/* set things up for TELL_xxx \n WAIT_xxx */\n\n\n\nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n    \nerr_sys\n(\nfork error\n);\n\n\n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n \n/* child */\n\n\n    \n/* child does whatever is necessary ... */\n\n\n    \nTELL_PARENT\n(\ngetppid\n());\n \n/* tell parent we\u2019re done */\n\n    \nWAIT_PARENT\n();\n \n/* and wait for parent */\n\n\n    \n/* and the child continues on its way ... */\n\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n/* parent does whatever is necessary ... */\n\n\n\nTELL_CHILD\n(\npid\n);\n \n/* tell child we\u2019re done */\n\n\nWAIT_CHILD\n();\n \n/* and wait for child */\n\n\n\n/* and the parent continues on its way ... */\n\n\nexit\n(\n0\n);\n\n\n\n\n\n\nWe assume that the header \napue.h\n defines whatever variables are required. The five routines \nTELL_WAIT\n, \nTELL_PARENT\n, \nTELL_CHILD\n, \nWAIT_PARENT\n, and \nWAIT_CHILD\n can be either macros or functions (\nlib/tellwait.c\n). We\u2019ll show various ways to implement these \nTELL\n and \nWAIT\n routines in later chapters: Section 10.16 shows an implementation using signals; Figure 15.7 shows an implementation using pipes.\n\n\nThe program below contains a race condition because the output depends on the order in which the processes are run by the kernel and the length of time for which each process runs.\n\n\n\n\ntellwait1.c\n\n\n\n\n#include \napue.h\n\n\n\nstatic\n \nvoid\n \ncharatatime\n(\nchar\n \n*\n);\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \npid_t\n   \npid\n;\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n\n        \ncharatatime\n(\noutput from child\n\\n\n);\n\n    \n}\n \nelse\n \n{\n\n        \ncharatatime\n(\noutput from parent\n\\n\n);\n\n    \n}\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\nstatic\n \nvoid\n\n\ncharatatime\n(\nchar\n \n*\nstr\n)\n\n\n{\n\n    \nchar\n    \n*\nptr\n;\n\n    \nint\n     \nc\n;\n\n\n    \nsetbuf\n(\nstdout\n,\n \nNULL\n);\n           \n/* set unbuffered */\n\n    \nfor\n \n(\nptr\n \n=\n \nstr\n;\n \n(\nc\n \n=\n \n*\nptr\n++\n)\n \n!=\n \n0\n;\n \n)\n\n        \nputc\n(\nc\n,\n \nstdout\n);\n\n\n}\n\n\n\n\n\n\nResults:\n\n\n$ ./a.out\nooutput from child\nutput from parent\n$ ./a.out\nooutput from child\nutput from parent\n$ ./a.out\noutput from child\noutput from parent\n\n\n\n\n\nAnalysis:\nWe set the standard output unbuffered, so every character output generates a write.  The goal in this example is to allow the kernel to switch between the two processes as often as possible to demonstrate the race condition.\n\n\nWe need to change (part of) the above program in to use the \nTELL\n and \nWAIT\n functions.\n\n\n\n\nThe parent goes first:\n\n\n\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n\n        \nWAIT_PARENT\n();\n      \n/* parent goes first */\n\n        \ncharatatime\n(\noutput from child\n\\n\n);\n\n    \n}\n \nelse\n \n{\n\n        \ncharatatime\n(\noutput from parent\n\\n\n);\n\n        \nTELL_CHILD\n(\npid\n);\n\n    \n}\n\n\n\n\n\n\n\n\nThe child goes first:\n\n\n\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n\n        \ncharatatime\n(\noutput from child\n\\n\n);\n\n        \nTELL_PARENT\n(\ngetppid\n());\n\n    \n}\n \nelse\n \n{\n\n        \nWAIT_CHILD\n();\n \n/* child goes first */\n\n        \ncharatatime\n(\noutput from parent\n\\n\n);\n\n    \n}\n\n\n\n\n\n\nexec\n Functions\n\n\nOne use of the \nfork\n function is to create a new process (the child) that then causes another program to be executed by calling one of the \nexec\n functions.\n\n\n\n\nWhen a process calls one of the \nexec\n functions, that process is completely replaced by the new program which starts executing at its \nmain\n function.\n\n\nThe process ID does not change across an \nexec\n, because a new process is not created.\n\n\nexec\n merely replaces the current process (its text, data, heap, and stack segments) with a brand-new program from disk.\n\n\n\n\nUNIX System process control primitives:\n\n\n\n\nfork\n creates new processes\n\n\nexec\n functions initiates new programs\n\n\nexit\n handles termination\n\n\nwait\n functions handle waiting for termination\n\n\n\n\nWe\u2019ll use these primitives in later sections to build additional functions, such as \npopen\n and \nsystem\n.\n\n\nThere are seven different \nexec\n functions:\n\n\n\n\napue_execl.h\n\n\n\n\n\n\n\nThe first four take a pathname argument, the next two take a filename argument, and the last one takes a file descriptor argument.\n\n\nWhen \nfilename\n argument is specified:\n\n\n\n\nIf filename contains a slash, it is taken as a pathname.\n\n\nOtherwise, the executable file is searched for in the directories specified by the PATH environment variable.\n\n\nThe \nPATH\n variable contains a list of directories, called path prefixes, that are separated by colons, like the \nname=value\n environment string \nPATH=/bin:/usr/bin:/usr/local/bin/:.\n. The dot (\n.\n) specifies the current directory (There are security reasons for never including the current directory in the search path). A zero-length prefix also means the current directory. It can be specified as:\n\n\na colon at the beginning of the \nvalue\n: \nPATH=:/bin:/usr/bin\n\n\ntwo colons in a row: \nPATH=/bin::/usr/bin\n\n\na colon at the end of the \nvalue\n: \nPATH=/bin:/usr/bin:\n\nIf either \nexeclp\n or \nexecvp\n finds an executable file using one of the path prefixes, but the file isn\u2019t a machine executable that was generated by the link editor, the function assumes that the file is a shell script and tries to invoke \n/bin/sh\n with the filename as input to the shell.\n\n\n\n\n\n\n\n\nWith \nfexecve\n (using a file descriptor), the caller can verify the file is in fact the intended file and execute it without a race. Otherwise, a malicious user with appropriate privileges could replace the executable file (or a portion of the path to the executable file) after it has been located and verified, but before the caller can execute it. See \nTOCTTOU\n errors in Section 3.3.\n\n\nThe passing of the argument list (\nl\n stands for list and \nv\n stands for vector):\n\n\n\n\nexecl\n, \nexeclp\n, and \nexecle\n require each of the command-line arguments to be specified as separate arguments.\n\n\nexecv\n, \nexecvp\n, \nexecve\n, and \nfexecve\n require (the address) of an array of pointers to the arguments\n\n\n\n\nThe arguments for \nexecl\n, \nexecle\n, and \nexeclp\n are shown as:\n\n\n    \nchar\n \n*\narg0\n,\n \nchar\n \n*\narg1\n,\n \n...,\n \nchar\n \n*\nargn\n,\n \n(\nchar\n \n*\n)\n0\n\n\n\n\n\n\nThe final command-line argument is followed by a null pointer. If this null pointer is specified by the constant 0, we must cast it to a pointer; if we don\u2019t, it\u2019s interpreted as an integer argument.\n\n\nThe passing of the environment list to the new program.\n\n\n\n\nexecle\n, \nexecve\n, and \nfexecve\n functions (ending in \ne\n) allow us to pass a pointer to an array of pointers to the environment strings.\n\n\nexecl\n, \nexecv\n, \nexeclp\n and \nexecvp\n use the \nenviron\n variable in the calling process to copy the existing environment for the new program. [p251]\n\n\n\n\nThe arguments to \nexecle\n were shown as:\n\n\nchar\n \n*\npathname\n,\n \nchar\n \n*\narg0\n,\n \n...,\n \nchar\n \n*\nargn\n,\n \n(\nchar\n \n*\n)\n0\n,\n \nchar\n \n*\nenvp\n[]\n\n\n\n\n\n\nDifferences among the seven \nexec\n functions\n\n\n\n\n\n\n\n\nFunction\n\n\npathname\n\n\nfilename\n\n\nfd\n\n\nArg list\n\n\nargv[]\n\n\nenviron\n\n\nenvp[]\n\n\n\n\n\n\n\n\n\n\n\n\nexecl\n\n\n*\n\n\n\n\n\n\n*\n\n\n\n\n*\n\n\n\n\n\n\n\n\n\n\nexeclp\n\n\n\n\n*\n\n\n\n\n*\n\n\n\n\n*\n\n\n\n\n\n\n\n\n\n\nexecle\n\n\n*\n\n\n\n\n\n\n*\n\n\n\n\n\n\n*\n\n\n\n\n\n\n\n\nexecv\n\n\n*\n\n\n\n\n\n\n\n\n*\n\n\n*\n\n\n\n\n\n\n\n\n\n\nexecvp\n\n\n\n\n*\n\n\n\n\n\n\n*\n\n\n*\n\n\n\n\n\n\n\n\n\n\nexecve\n\n\n*\n\n\n\n\n\n\n\n\n*\n\n\n\n\n*\n\n\n\n\n\n\n\n\nfexecve\n\n\n\n\n\n\n*\n\n\n\n\n*\n\n\n\n\n*\n\n\n\n\n\n\n\n\n(letter in name)\n\n\n\n\np\n\n\nf\n\n\nl\n\n\nv\n\n\n\n\ne\n\n\n\n\n\n\n\n\n\n\nEvery system has a limit on the total size of the argument list and the environment list. This limit is given by \nARG_MAX\n and its value must be at least 4,096 bytes on a POSIX.1 system. For example, the following command can generate a shell error:\n\n\n$\n grep getrlimit /usr/share/man/*/*\n\nArgument list too long\n\n\n\n\n\n\nTo get around the limitation in argument list size, we can use the \nxargs(1)\n:\n\n\n$\n find /usr/share/man -type f -print \n|\n xargs grep getrlimit\n\n$\n find /usr/share/man -type f -print \n|\n xargs bzgrep getrlimit\n\n\n\n\n\nThe process ID does not change after an \nexec\n, but the new program inherits additional properties from the calling process:\n\n\n\n\nProcess ID and parent process ID\n\n\nReal user ID and real group ID\n\n\nSupplementary group IDs\n\n\nProcess group ID\n\n\nSession ID\n\n\nControlling terminal\n\n\nTime left until alarm clock\n\n\nCurrent working directory\n\n\nRoot directory\n\n\nFile mode creation mask\n\n\nFile locks\n\n\nProcess signal mask\n\n\nPending signals\n\n\nResource limits\n\n\nNice value\n\n\nValues for \ntms_utime\n, \ntms_stime\n, \ntms_cutime\n, and \ntms_cstime\n\n\n\n\nThe handling of open files depends on the value of the close-on-exec (\nFD_CLOEXEC\n) flag for each descriptor:\n\n\n\n\nIf this flag is set, the descriptor is closed across an exec. The default (the flag is not set) is to leave the descriptor open across the \nexec\n.\n\n\nPOSIX.1 specifically requires that open directory streams (see \nopendir\n in \nChapter 4\n). This is normally done by the\n\nopendir\n function calling \nfcntl\n to set the close-on-exec flag.\n\n\n\n\nThe real user ID and the real group ID remain the same across the \nexec\n, but the effective IDs can change, depending on the status of the set-user-ID and the setgroup-ID bits for the program file that is executed. If the set-user-ID bit is set for the new program, the effective user ID becomes the owner ID of the program file.  Otherwise, the effective user ID is not changed (it\u2019s not set to the real user ID). The group ID is handled in the same way.\n\n\nexec\n library functions and system call\n\n\nIn many UNIX system implementations, only one of these seven functions, \nexecve\n, is a system call within the kernel. The other six are just library functions that eventually invoke this system call.\n\n\nRelationship of the seven \nexec\n functions:\n\n\n\n\nExample:\n\n\n\n\nexec1.c\n\n\n\n\n#include \napue.h\n\n\n#include \nsys/wait.h\n\n\n\nchar\n    \n*\nenv_init\n[]\n \n=\n \n{\n \nUSER=unknown\n,\n \nPATH=/tmp\n,\n \nNULL\n \n};\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \npid_t\n   \npid\n;\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n  \n/* specify pathname, specify environment */\n\n        \nif\n \n(\nexecle\n(\n/home/sar/bin/echoall\n,\n \nechoall\n,\n \nmyarg1\n,\n\n                \nMY ARG2\n,\n \n(\nchar\n \n*\n)\n0\n,\n \nenv_init\n)\n \n \n0\n)\n\n            \nerr_sys\n(\nexecle error\n);\n\n    \n}\n\n\n    \nif\n \n(\nwaitpid\n(\npid\n,\n \nNULL\n,\n \n0\n)\n \n \n0\n)\n\n        \nerr_sys\n(\nwait error\n);\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n  \n/* specify filename, inherit environment */\n\n        \nif\n \n(\nexeclp\n(\nechoall\n,\n \nechoall\n,\n \nonly 1 arg\n,\n \n(\nchar\n \n*\n)\n0\n)\n \n \n0\n)\n\n            \nerr_sys\n(\nexeclp error\n);\n\n    \n}\n\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\n\n\nechoall.c\n\n\n\n\n#include \napue.h\n\n\n\nint\n\n\nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nargv\n[])\n\n\n{\n\n    \nint\n         \ni\n;\n\n    \nchar\n        \n**\nptr\n;\n\n    \nextern\n \nchar\n \n**\nenviron\n;\n\n\n    \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \nargc\n;\n \ni\n++\n)\n      \n/* echo all command-line args */\n\n        \nprintf\n(\nargv[%d]: %s\n\\n\n,\n \ni\n,\n \nargv\n[\ni\n]);\n\n\n    \nfor\n \n(\nptr\n \n=\n \nenviron\n;\n \n*\nptr\n \n!=\n \n0\n;\n \nptr\n++\n)\n   \n/* and all env strings */\n\n        \nprintf\n(\n%s\n\\n\n,\n \n*\nptr\n);\n\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nResults:\n\n\n$ ./a.out\nargv[0]: echoall\nargv[1]: myarg1\nargv[2]: MY ARG2\nUSER=unknown\nPATH=/tmp\n$ argv[0]: echoall\nargv[1]: only 1 arg\nUSER=sar\nLOGNAME=sar\nSHELL=/bin/bash\n...\nHOME=/home/sar\n\n\n\n\n\nAnalysis:\n\n\n\n\nThe program \nechoall\n is executed twice in the program.\n\n\nWe set the first argument, \nargv[0]\n in the new program, to be the filename component of the pathname. Some shells set this argument to be the complete pathname. This is a convention only; we can set \nargv[0]\n to any string we like.\n\n\nThe \nlogin\n command does this when it executes the shell. Before executing the shell, login adds a dash as a prefix to \nargv[0]\n to indicate to the shell that it is being invoked as a login shell. A login shell will execute the start-up profile commands, whereas a nonlogin shell will not.\n\n\n\n\n\n\nThe shell prompt (\n$\n) appeared before the printing of \nargv[0]\n from the second exec. This occurred because the parent did not wait for this child process to finish.\n\n\n\n\nChanging User IDs and Group IDs\n\n\nIn the UNIX System, privileges and access control are on user and group IDs. When programs need additional privileges or access to unallowed resources, they need to change their user or group ID to an ID that has the appropriate privilege or access. It is similar when the programs need to lower their privileges or prevent access to certain resources. [p255]\n\n\nWhen designing applications, we try to use the \nleast-privilege\n model, which means our programs should use the least privilege necessary to accomplish any given task. This reduces the risk that security might be compromised by a malicious user trying to trick our programs into using their privileges in unintended ways.\n\n\nWe can set the real user ID and effective user ID with the \nsetuid\n function and set the real group ID and the effective group ID with the \nsetgid\n function.\n\n\n\n\napue_setuid.h\n\n\n\n\n\n\n\nThe rules for who can change the IDs, considering only the user ID now (Everything we describe for the user ID also applies to the group ID.)\n\n\n\n\nIf the process has superuser privileges, the \nsetuid\n function sets the real user ID, effective user ID, and saved set-user-ID to \nuid\n.\n\n\nIf the process does not have superuser privileges, but \nuid\n equals either the real user ID or the saved set-user-ID, setuid sets only the effective user ID to \nuid\n. The real user ID and the saved set-user-ID are not changed.\n\n\nIf neither of these two conditions is true, \nerrno\n is set to \nEPERM\n and \u22121 is returned.\n\n\n\n\nWe are assuming that \n_POSIX_SAVED_IDS\n is true. The saved IDs areamandatory feature in the 2001 version of POSIX.1.\n\n\nThe statements about the three user IDs that the kernel maintains:\n\n\n\n\nOnly a superuser process can change the real user ID.\n\n\nNormally, the real user ID is set by the \nlogin(1)\n program when we log in and never changes. Because \nlogin\n is a superuser process, it sets all three user IDs when it calls \nsetuid\n.\n\n\n\n\n\n\nThe effective user ID is set by the \nexec\n functions only if the set-user-ID bit is set for the program file.\n\n\nIf the set-user-ID bit is not set, the \nexec\n functions leave the effective user ID as its current value.\n\n\nWe can call \nsetuid\n at any time to set the effective user ID to either the real user ID or the saved set-user-ID.\n\n\nNaturally, we can\u2019t set the effective user ID to any random value.\n\n\n\n\n\n\nThe saved set-user-ID is copied from the effective user ID by \nexec\n. If the file\u2019s set-user-ID bit is set, this copy is saved after \nexec\n stores the effective user ID from the file\u2019s user ID.\n\n\n\n\nThe following figure summarizes the various ways these three user IDs can be changed:\n\n\n\n\nWe can obtain only the current value of the real user ID and the effective user ID with the functions \ngetuid\n and \ngeteuid\n (\napue_getpid.h\n). There is no portable way to obtain the current value of the saved set-user-ID. FreeBSD 8.0 and LINUX 3.2.0 provide the \ngetresuid\n and \ngetresgid\n functions, which can be used to get the saved set-user-ID and saved set-group-ID, respectively.\n\n\nsetreuid\n and \nsetregid\n Functions\n\n\nHistorically, BSD supported the swapping of the real user ID and the effective user ID with the setreuid function.\n\n\n\n\napue_setreuid.h\n\n\n\n\n\n\n\n\n\nA value of \u22121 for any of the arguments indicates that the corresponding ID should remain unchanged.\n\n\nAn unprivileged user can always swap between the real user ID and the effective user ID. This allows a set-user-ID program to swap to the user\u2019s normal permissions and swap back again later for set-user-ID operations.\n\n\nWhen the saved set-user-ID feature was introduced with POSIX.1, the rule was enhanced to also allow an unprivileged user to set its effective user ID to its saved set-user-ID.\n\n\n\n\n[p257]\n\n\nseteuid\n and \nsetegid\n Functions\n\n\nPOSIX.1 includes \nseteuid\n and \nsetegid\n that only change the effective user ID or effective group ID.\n\n\n\n\napue_seteuid.h\n\n\n\n\n\n\n\n\n\nAn unprivileged user can set its effective user ID to either its real user ID or its saved set-user-ID.\n\n\nFor a privileged user, only the effective user ID is set to \nuid\n. This differs from \nsetuid\n function, which changes all three user IDs.\n\n\n\n\nThe figure below summarizes all the functions that we\u2019ve described here that modify the three user IDs:\n\n\n\n\nGroup IDs\n\n\nEverything covered so far for user IDs in this section also applies in a similar fashion to group IDs. The \nsupplementary group IDs\n are not affected by \nsetgid\n, \nsetregid\n, or \nsetegid\n.\n\n\nExample of set-user-ID programs: \nat\n\n\nOn Linux 3.2.0, the \nat\n program is installed set-user-ID to user \ndaemon\n and the programs are run by the \natd(8)\n daemon. This allows the at command to write privileged files owned by the daemon that will run the commands on behalf of the user running the \nat\n command.\n\n\nTo prevent privilege breach, the daemon that run the commands on users's behalf have to switch between sets of privileges: users and those of the daemon. The following steps take place [p259-260]:\n\n\n\n\nAssuming that the \nat\n program file is owned by \nroot\n with set-user-ID bit set. When we run it, we have:\n\n\nreal user ID = our user ID (unchanged)\n\n\neffective user ID = root\n\n\nsaved set-user-ID = root\n\n\n\n\n\n\nat\n command reduces its privileges by calling \nseteuid\n function to set the effective user ID to our read user ID:\n\n\nreal user ID = our user ID (unchanged)\n\n\neffective user ID = our user ID\n\n\nsaved set-user-ID = root (unchanged)\n\n\n\n\n\n\nWhen \nat\n needs to access the configuration files (these files are owned by the daemon that will run the commands for us) that control which commands are to be run and the time at which they need to run, it calls \nseteuid\n to set the effective user ID to root, which is allowed because the argument to seteuid equals the saved set-user-ID:\n\n\nreal user ID = our user ID (unchanged)\n\n\neffective user ID = root\n\n\nsaved set-user-ID = root (unchanged)\n\n\n\n\n\n\nAfter the files are modified to record the commands to be run and the time at which they are to be run, the \nat\n command lowers its privileges by calling \nseteuid\n to set its effective user ID to our user ID:\n\n\nreal user ID = our user ID (unchanged)\n\n\neffective user ID = our user ID\n\n\nsaved set-user-ID = root (unchanged)\n\n\n\n\n\n\nThe daemon starts out running with root privileges. To run commands on our behalf, the daemon calls \nfork\n and the child calls \nsetuid\n to change its user ID to our user ID. Because the child is running with root privileges, this changes all of the IDs. We have:\n\n\nreal user ID = our user ID\n\n\neffective user ID = our user ID\n\n\nsaved set-user-ID = our user ID\n\n\n\n\n\n\n\n\nThen the daemon safely executes commands on our behalf, because it can access only the files to which we normally have access.\n\n\nBy using the saved set-user-ID in this fashion, we can use the extra privileges granted to us by the set-user-ID of the program file only when we need elevated privileges. Any other time, however, the process runs with our normal permissions. [p260]\n\n\nInterpreter Files\n\n\nOn contemporary UNIX systems, \ninterpreter files\n are text files that begin with a line of the form (\nshebang\n):\n\n\n#! pathname [ optional-argument ]\n\n\n\n\n\n\nThe space between the exclamation point and the pathname is optional. The most common of these interpreter files begin with the line:\n\n\n#!/bin/sh\n\n\n\n\n\n\n\n\npathname\n is normally an absolute pathname, since no special operations are performed on it (\nPATH\n is not used)\n\n\nThe recognition of interpreter files is done within the kernel as part of processing the \nexec\n system call\n\n\nThe actual file that gets executed by the kernel is not the interpreter file, but rather the file specified by the \npathname\n on the first line of the interpreter file.\n\n\n\n\nInterpreter file vs. Interpreter\n\n\n\n\nInterpreter file: is a text file that begins with \n#!\n.\n\n\nInterpreter: is specified by the \npathname\n on the first line of the interpreter file.\n\n\n\n\nBe aware that systems place a size limit on the first line of an interpreter file. This limit includes the \n#!\n, the \npathname\n, the optional argument, the terminating newline, and any spaces. On Linux 3.2.0, the limit is 128 bytes.\n\n\nExample: A program that \nexec\ns an interpreter file\n\n\n\n\nexec2.c\n\n\n\n\n#include \napue.h\n\n\n#include \nsys/wait.h\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \npid_t\n \npid\n;\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n \n/* child */\n\n        \nif\n \n(\nexecl\n(\n/home/sar/bin/testinterp\n,\n\n                  \ntestinterp\n,\n \nmyarg1\n,\n \nMY ARG2\n,\n \n(\nchar\n \n*\n)\n0\n)\n \n \n0\n)\n\n            \nerr_sys\n(\nexecl error\n);\n\n    \n}\n\n    \nif\n \n(\nwaitpid\n(\npid\n,\n \nNULL\n,\n \n0\n)\n \n \n0\n)\n \n/* parent */\n\n        \nerr_sys\n(\nwaitpid error\n);\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nResults:\n\n\n$ cat /home/sar/bin/testinterp\n#!/home/sar/bin/echoarg foo\n$ ./a.out\nargv[0]: /home/sar/bin/echoarg\nargv[1]: foo\nargv[2]: /home/sar/bin/testinterp\nargv[3]: myarg1\nargv[4]: MY ARG2\n\n\n\n\n\nAnalysis:\n\n\nThe program (from \nSection 7.4\n) \nechoarg\n is the interpreter that echoes each of its command-line arguments.\n\n\nWhen the kernel \nexec\ns the interpreter (\n/home/sar/bin/echoarg\n):\n\n\n\n\nargv[0]\n is \npathname\n of the interpreter\n\n\nargv[1]\n is the optional argument from the interpreter file (\nfoo\n)\n\n\nThe remaining arguments are the \npathname\n (\n/home/sar/bin/testinterp\n) and the second and third arguments from the call to \nexecl\n in the program (\nmyarg1\n and \nMY ARG2\n)\n\n\nBoth \nargv[1]\n and \nargv[2]\n from the call to \nexecl\n have been shifted right two positions.\n\n\nThe kernel takes the \npathname\n from the \nexecl\n call instead of the first argument (\ntestinterp\n), on the assumption that the \npathname\n might contain more information than the first argument.\n\n\n\n\nExample: \nawk\n\n\nA common use for the optional argument following the interpreter pathname is to specify the \n-f\n option for programs that support this option. For example, an \nawk(1)\n program can be executed as:\n\n\nawk -f myfile\n\n\n\n\n\nIt tells \nawk\n to read the \nawk\n program from the file \nmyfile\n.\n\n\nUsing the \n-f\n option with an interpreter file lets us write\n\n\n#!/bin/awk -f\n\n\n# (awk program follows in the interpreter file)\n\n\n\n\n\n\n\n\nawkexample\n\n\n\n\n#!/usr/bin/awk -f\n\nBEGIN \n{\n\n    \nfor\n \n(\ni\n \n=\n 0\n;\n i \n ARGC\n;\n i++\n)\n\n        \nprintf\n \nARGV[%d] = %s\\n\n, i, ARGV\n[\ni\n]\n\n    \nexit\n\n\n}\n\n\n\n\n\n\nAssume the above interpreter file is  \n/usr/local/bin/awkexample\n and one of the path prefixes is \n/usr/local/bin\n, we can execute the program:\n\n\n$ awkexample file1 FILENAME2 f3\nARGV[0] = awk\nARGV[1] = file1\nARGV[2] = FILENAME2\nARGV[3] = f3\n\n\n\n\n\nWhen \n/bin/awk\n is executed, its command-line arguments are:\n\n\n/bin/awk -f /usr/local/bin/awkexample file1 FILENAME2 f3\n\n\n\n\n\n[p263]\n\n\nInterpreter files provide an efficiency gain for the user at some expense in the kernel, since it\u2019s the kernel that recognizes these files. They are useful for the following reasons:\n\n\nFirst, they hide that certain programs are scripts in some other language. For example, use \nawkexample optional-arguments\n instead of \nawk -f awkexample optional-argument\n, we do not need to know that the program is really an \nawk\n script.\n\n\nSecond, interpreter scripts provide an efficiency gain. For example, if we place the previous \nawk\n program into a shell script like this:\n\n\nawk \nBEGIN {\n\n\n    for (i = 0; i \n ARGC; i++)\n\n\n        printf \nARGV[%d] = %s\\n\n, i, ARGV[i]\n\n\n    exit\n\n\n}\n \n$*\n\n\n\n\n\n\nMore work is required when executing this script:\n\n\n\n\nThe shell reads the command and tries to \nexeclp\n the filename (shell script). Since the shell script is an executable file but isn't a machine executable, an error is returned and \nexeclp\n assumes that the file is a shell script.\n\n\n/bin/sh\n is executed with the pathname of the shell script as its argument.\n\n\nThe shell correctly runs the script, but to run the \nawk\n programs, the shell does \nfork\n, \nexec\n and \nwait\n.\n\n\n\n\nThird, interpreter scripts let us write shell scripts using shells other than \n/bin/sh\n. When it finds an executable file that isn\u2019t a machine executable, \nexeclp\n has to choose a shell to invoke, and it always uses \n/bin/sh\n.\n\n\nsystem\n Function\n\n\nIt is convenient to execute a command string from within a program.\n\n\n\n\napue_system.h\n\n\n\n\n\n\n\nArguments:\n\n\nIf \ncmdstring\n is a null pointer, system returns nonzero only if a command processor is available, which determines whether the \nsystem\n function is supported on a given platform. Under UNIX systems, it is always available.\n\n\nReturn values:\n\n\nSince \nsystem\n is implemented by calling \nfork\n, \nexec\n, and \nwaitpid\n, there are three types of return values:\n\n\n\n\nIf either the \nfork\n fails or \nwaitpid\n returns an error other than \nEINTR\n, \nsystem\n returns \u22121 with \nerrno\n set to indicate the error.\n\n\nIf the \nexec\n fails, implying that the shell can\u2019t be executed, the return value is as if the shell had executed \nexit(127)\n.\n\n\nIf all three functions succeed, the return value is the termination status of the shell, in the format specified for \nwaitpid\n.\n\n\n\n\nThe code below is an implementation of the \nsystem\n function, which doesn't handle is signals.\n\n\n#include    \nsys/wait.h\n\n\n#include    \nerrno.h\n\n\n#include    \nunistd.h\n\n\n\nint\n\n\nsystem\n(\nconst\n \nchar\n \n*\ncmdstring\n)\n   \n/* version without signal handling */\n\n\n{\n\n    \npid_t\n   \npid\n;\n\n    \nint\n     \nstatus\n;\n\n\n    \nif\n \n(\ncmdstring\n \n==\n \nNULL\n)\n\n        \nreturn\n(\n1\n);\n      \n/* always a command processor with UNIX */\n\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nstatus\n \n=\n \n-\n1\n;\n    \n/* probably out of processes */\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n==\n \n0\n)\n \n{\n              \n/* child */\n\n        \nexecl\n(\n/bin/sh\n,\n \nsh\n,\n \n-c\n,\n \ncmdstring\n,\n \n(\nchar\n \n*\n)\n0\n);\n\n        \n_exit\n(\n127\n);\n     \n/* execl error */\n\n    \n}\n \nelse\n \n{\n                            \n/* parent */\n\n        \nwhile\n \n(\nwaitpid\n(\npid\n,\n \nstatus\n,\n \n0\n)\n \n \n0\n)\n \n{\n\n            \nif\n \n(\nerrno\n \n!=\n \nEINTR\n)\n \n{\n\n                \nstatus\n \n=\n \n-\n1\n;\n \n/* error other than EINTR from waitpid() */\n\n                \nbreak\n;\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n    \nreturn\n(\nstatus\n);\n\n\n}\n\n\n\n\n\n\n\n\nThe shell\u2019s \n-c\n option tells it to take the next command-line argument, \ncmdstring\n, as its command input instead of reading from standard input or from a given file. The shell parses this null-terminated C string and breaks it up into separate command-line arguments for the command. The actual command string that is passed to the shell can contain any valid shell commands.\n\n\n_exit\n is called instead of \nexit\n. This prevents any standard I/O buffers, which would have been copied from the parent to the child across the fork, from being flushed in the child.\n\n\n\n\n[p266-267]\n\n\nSet-User-ID Programs\n\n\nCalling \nsystem\n from a set-user-ID program creates a security hole and should never be attempted.\n\n\n[p267-269]\n\n\nThe superuser permissions that we gave the set-user-ID program are retained across the \nfork\n and \nexec\n that are done by \nsystem\n.\n\n\nIf it is running with special permissions (set-user-ID or set-group-ID), and wants to spawn another process, a process should use \nfork\n and \nexec\n directly, being certain to change back to normal permissions after the \nfork\n, before calling \nexec\n. The \nsystem\n function should never be used from a set-user-ID or a set-group-ID program.\n\n\nProcess Accounting\n\n\nOn UNIX systems, process accounting can be enabled so that kernel writes an accounting record each time a process terminates, which typically contain a small amount of binary data with the name of the command, the amount of CPU time used, the user ID and group ID, the starting time.\n\n\nThe function \nacct\n enables and disables process accounting. The only use of this function is from the \naccton(8)\n command.\n\n\nA superuser executes accton with a pathname argument to enable accounting. The accounting records are written to the specified file, which is usually \n/var/account/acct\n on FreeBSD and Mac OS X, \n/var/log/account/pacct\n on Linux, and \n/var/adm/pacct\n on Solaris. Accounting is turned off by executing accton without any arguments.\n\n\nThe structure of the accounting records is defined in the header \nsys/acct.h\n, which look something like:\n\n\ntypedef\n \nu_short\n \ncomp_t\n;\n \n/* 3-bit base 8 exponent; 13-bit fraction */\n\n\n\nstruct\n \nacct\n\n\n{\n\n    \nchar\n \nac_flag\n;\n \n/* flag (see Figure 8.26) */\n\n    \nchar\n \nac_stat\n;\n \n/* termination status (signal \n core flag only) */\n\n    \n/* (Solaris only) */\n\n    \nuid_t\n \nac_uid\n;\n \n/* real user ID */\n\n    \ngid_t\n \nac_gid\n;\n \n/* real group ID */\n\n    \ndev_t\n \nac_tty\n;\n \n/* controlling terminal */\n\n    \ntime_t\n \nac_btime\n;\n \n/* starting calendar time */\n\n    \ncomp_t\n \nac_utime\n;\n \n/* user CPU time */\n\n    \ncomp_t\n \nac_stime\n;\n \n/* system CPU time */\n\n    \ncomp_t\n \nac_etime\n;\n \n/* elapsed time */\n\n    \ncomp_t\n \nac_mem\n;\n \n/* average memory usage */\n\n    \ncomp_t\n \nac_io\n;\n \n/* bytes transferred (by read and write) */\n\n    \n/* \nblocks\n on BSD systems */\n\n    \ncomp_t\n \nac_rw\n;\n \n/* blocks read or written */\n\n    \n/* (not present on BSD systems) */\n\n    \nchar\n \nac_comm\n[\n8\n];\n \n/* command name: [8] for Solaris, */\n\n    \n/* [10] for Mac OS X, [16] for FreeBSD, and */\n\n    \n/* [17] for Linux */\n\n\n};\n\n\n\n\n\n\n\n\nTimes are recorded in units of clock ticks on most platforms, but FreeBSD stores microseconds instead.\n\n\nThe \nac_flag\n member records certain events during the execution of the process. See table below.\n\n\n\n\n\n\n\n\n\n\nac_flag\n\n\nDescription\n\n\nFreeBSD 8.0\n\n\nLinux 3.2.0\n\n\nMac OS X 10.6.8\n\n\nSolaris 10\n\n\n\n\n\n\n\n\n\n\nAFORK\n\n\nprocess is the result of \nfork\n, but never called \nexec\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\n\n\n\n\nASU\n\n\nprocess used superuser privileges\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\n\n\n\n\nACORE\n\n\nprocess dumped core\n\n\nx\n\n\nx\n\n\nx\n\n\n\n\n\n\n\n\nAXSIG\n\n\nprocess was killed by a signal\n\n\nx\n\n\nx\n\n\nx\n\n\n\n\n\n\n\n\nAEXPND\n\n\nexpanded accounting entry\n\n\n\n\n\n\n\n\nx\n\n\n\n\n\n\nANVER\n\n\nnew record format\n\n\nx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe data required for the accounting record (e.g. CPU times and number of characters transferred) is kept by the kernel in the process table and initialized whenever a new process is created, as in the child after a \nfork\n. Each accounting record is written when the process terminates. This has two consequences:\n\n\n\n\nWe cannot get accounting records for processes that never terminate, such as \ninit\n and kernel daemons.\n\n\nThe order of the records in the accounting file corresponds to the termination order of the processes, not the order in which they were started. [p270]. We can\u2019t reconstruct the exact starting order of various processes, given the data in the accounting file.\n\n\n\n\nThe accounting records correspond to processes, not programs. A new record is initialized by the kernel for the child after a \nfork\n, not when a new program is executed. Although exec doesn\u2019t create a new accounting record, the command name changes, and the \nAFORK\n flag is cleared. For example, if A \nexec\ns B, then B \nexec\ns C, and C \nexit\n, only a single accounting record is written.  The command name in the record corresponds to program C, but the CPU times are the sum for programs A, B, and C.\n\n\nUser Identification\n\n\nAny process can find out its real and effective user ID and group ID. \ngetpwuid(getuid())\n can be used to find out the login name of the user who\u2019s running the program. However, a single user can have multiple login names, that is, a person might have multiple entries in the password file with the same user ID to have a different login shell for each entry. The system normally keeps track of the name we log in under the \nutmp\n file (see \nSection 6.8\n), and the \ngetlogin\n function provides a way to fetch that login name.\n\n\n\n\napue_getlogin.h\n\n\n\n\n\n\n\nThis function can fail if the process is not attached to a terminal that a user logged in to. We normally call these processes \ndaemons\n.\n\n\nGiven the login name, we can then use it to look up the user in the password file (e.g. to determine the login shell) using \ngetpwnam\n.\n\n\nThe environment variable \nLOGNAME\n is usually initialized with the user\u2019s login name by \nlogin(1)\n and inherited by the login shell. However, a user can modify an environment variable, so we shouldn\u2019t use \nLOGNAME\n to validate the user in any way. Instead, we should use \ngetlogin\n.\n\n\nProcess Scheduling\n\n\nHistorically, the UNIX System provided processes with only coarse control over their scheduling priority. The scheduling policy and priority were determined by the kernel.\n\n\n\n\nA process could choose to run with lower priority by adjusting its \nnice value\n\n\nA process could be \"nice\" and reduce its share of the CPU by adjusting its nice value\n\n\n\n\n\n\nOnly a privileged process was allowed to increase its scheduling priority.\n\n\n\n\nIn the Single UNIX Specification, nice values range from 0 to \n(2*NZERO)\u22121\n, although some implementations support a range from 0 to \n2*NZERO\n. Lower nice values have higher scheduling priority. Lower nice values have higher scheduling priority. \n\"The more nice you are, the lower your scheduling priority is.\"\n \nNZERO\n is the default nice value of the system. [p276]\n\n\nA process can retrieve and change its nice value with the \nnice\n function. With this function, a process can affect only its own nice value; it can\u2019t affect the nice value of any other process.\n\n\n\n\napue_nice.h\n\n\n\n\n\n\n\n\n\nThe \nincr\n argument is added to the nice value of the calling process.\n\n\nIf \nincr\n is too large or too small, the system silently reduces it to the maximum or minimum legal value.\n\n\n-1 is a legal successful return value. We need to clear \nerrno\n before calling nice and check its value if nice returns \u22121. If the call to nice succeeds and the return value is \u22121, then errno will still be zero. If \nerrno\n is nonzero, it means that the call to nice failed.\n\n\n\n\n\n\n\n\nThe \ngetpriority\n function can be used to get the nice value for a process and for a group of related processes.\n\n\n\n\napue_getpriority.h\n\n\n\n\n\n\n\n\n\nThe \nwhich\n argument can take on one of three following values; it controls how the \nwho\n argument is interpreted:\n\n\nPRIO_PROCESS\n: a process\n\n\nPRIO_PGRP\n: a process group\n\n\nPRIO_USER\n: a user ID\n\n\n\n\n\n\nThe \nwho\n argument:\n\n\n0 (a value of zero): the calling process, process group, or user (depending on the value of the \nwhich\n argument).\n\n\n\n\n\n\n\n\nWhen the which argument applies to more than one process, the highest priority (lowest value) of all the applicable processes is returned.\n\n\nThe \nsetpriority\n function can be used to set the priority of a process, a process group, or all the processes belonging to a particular user ID.\n\n\n\n\napue_setpriority.h\n\n\n\n\n\n\n\nThe \nwhich\n and \nwho\n arguments are the same as in the \ngetpriority\n function. The \nvalue\n is added to \nNZERO\n and this becomes the new nice value.\n\n\nA child process inherits the nice value from its parent process in FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10.\n\n\nProcess Times\n\n\nThree times can be measured:\n\n\n\n\nWall clock time\n\n\nUser CPU time\n\n\nSystem CPU time\n\n\n\n\nAny process can call the \ntimes\n function to obtain these values for itself and any terminated children.\n\n\n\n\napue_times.h\n\n\n\n\n\n\n\nThis function fills in the \ntms\n structure pointed to by \nbuf\n:\n\n\nstruct\n \ntms\n \n{\n\n    \nclock_t\n \ntms_utime\n;\n \n/* user CPU time */\n\n    \nclock_t\n \ntms_stime\n;\n \n/* system CPU time */\n\n    \nclock_t\n \ntms_cutime\n;\n \n/* user CPU time, terminated children */\n\n    \nclock_t\n \ntms_cstime\n;\n \n/* system CPU time, terminated children */\n\n\n};\n\n\n\n\n\n\nThe \ntms\n structure does not contain any measurement for the wall clock time. Instead, the function returns the wall clock time as the value of the function. This value is measured from some arbitrary point in the past, so we can\u2019t use its absolute value; instead, we use its relative value. We call \ntimes\n and save the return value. At some later time, we call \ntimes\n again and subtract the earlier return value from the new return value. The difference is the wall clock time.\n\n\nThe two structure fields for child processes contain values only for children that we have waited for with one of the \nwait\n functions.\n\n\nAll the \nclock_t\n values returned by this function are converted to seconds using the number of clock ticks per second, the \n_SC_CLK_TCK\n value returned by \nsysconf\n, that is, divide the \nclock_t\n value by the \n_SC_CLK_TCK\n value. For example,\n\n\n[p280-282]\n\n\n#include \napue.h\n\n\n#include \nsys/times.h\n\n\n\nclock_t\n \nstart\n,\n \nend\n;\n\n\nlong\n \nclktck\n \n=\n \n0\n;\n\n\nstruct\n \ntms\n \ntmsstart\n,\n \ntmsend\n\n\n\nif\n \n((\nclktck\n \n=\n \nsysconf\n(\n_SC_CLK_TCK\n))\n \n \n0\n)\n\n    \nerr_sys\n(\nsysconf error\n);\n\n\n\nif\n \n((\nstart\n \n=\n \ntimes\n(\ntmsstart\n))\n \n==\n \n-\n1\n)\n \n/* starting values */\n\n    \nerr_sys\n(\ntimes error\n);\n\n\n\n/* do some work */\n\n\n\nif\n \n((\nend\n \n=\n \ntimes\n(\ntmsend\n))\n \n==\n \n-\n1\n)\n \n/* ending values */\n\n    \nerr_sys\n(\ntimes error\n);\n\n\n\nprintf\n(\n real: %7.2f\n\\n\n,\n \nreal\n \n/\n \n(\ndouble\n)\n \nclktck\n);\n\n\n\n\n\n\nSummary\n\n\nA thorough understanding of process control is essential for advanced UNIX programming. There are only a few functions to master: \nfork\n, the \nexec\n family, \n_exit\n, \nwait\n, and \nwaitpid\n. These primitives are used in many applications.\n\n\nExamination of the \nsystem\n function and process accounting gave us another look at all these process control functions.\n\n\nAn understanding of the various user IDs and group IDs that are provided (real, effective, and saved) is critical to writing safe set-user-ID programs.\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\np235 on \nvfork\n\n\n\n\nIf we call \nexit\n instead, the results are indeterminate. Depending on the implementation of the standard I/O library, we might see no difference in the output, or we might find that the output from the first \nprintf\n in the parent has disappeared.\n\n\n\n\nI think \"first \nprintf\n\" should be \"second \nprintf\n\", because the output of the first \nprintf\n is flushed. For the second \nprintf\n, it says \"no output will appear and \nprintf\n will return \u22121\".", 
            "title": "Chapter 8. Process Control"
        }, 
        {
            "location": "/apue/ch9/", 
            "text": "Chapter 9. Process Relationships\n\n\nIntroduction\n\n\nEvery process has a parent process (the initial kernel-level process is usually its own parent). The parent is notified when the child terminates, and the parent can obtain the child\u2019s exit status.\n\n\nThis chapter details process groups and the concept of session introduced by POSIX.1, as well as relationship between the login shell that is invoked when a user logs in and all the processes that are started from the login shell.\n\n\nThe concept of UNIX system signal mechanism in \nChapter 10\n is needed.\n\n\nTerminal Logins\n\n\nIn early UNIX systems, the terminals (dumb terminals that are hard-wired connected to the host) were either local (directly connected) or remote (connected through a modem). These logins came through a terminal device driver in the kernel. [p285]\n\n\nAs bitmapped graphical terminals became available, windowing systems were developed to provide users with new ways to interact with host computers.  Applications were developed to create \"terminal windows\" to emulate character-based terminals, allowing users to interact with hosts in familiar ways (i.e., via the shell command line).\n\n\nToday, some platforms allow you to start a windowing system after logging in, whereas other platforms automatically start the windowing system for you. In the latter case, you might still have to log in, depending on how the windowing system is configured (some windowing systems can be configured to log you in automatically).\n\n\nThe procedure that we now describe is used to log in to a UNIX system using a terminal. The procedure is similar regardless of the type of terminal we use. It could be a:\n\n\n\n\ncharacter-based terminal,\n\n\na graphical terminal emulating a simple character-based terminal,\n\n\nor a graphical terminal running a windowing system.\n\n\n\n\nBSD Terminal Logins\n\n\nThe file \n/etc/ttys\n (created by the system administrator) has one line per terminal device. Each line specifies the name of the device and other parameters (e.g. baud rate) that are passed to the \ngetty\n program.\n\n\nAfter the system is bootstrapped, the kernel creates the \ninit\n process (PID 1) which brings the system up in multiuser mode. The \ninit\n process reads the file \n/etc/ttys\n and, for every terminal device that allows a login, does a \nfork\n followed by an \nexec\n of the program \ngetty\n.\n\n\n\n\nAll the processes shown in the figure above have a real user ID of 0 and an effective user ID of 0 (they all have superuser privileges). All the processes other than the original \ninit\n process have a parent process ID of 1.\n\n\n\n\nThe \ninit\n process \nexec\ns the \ngetty\n program with an empty environment.\n\n\ngetty\n calls \nopen\n to open terminal device for reading and writing. File descriptors 0, 1, and 2 are set to the device.\n\n\nThen, \ngetty\n outputs something like \nlogin:\n and waits for us to enter our user name. \ngetty\n can detect special characters to change the terminal's speed (baud rate). [p287]\n\n\n\n\nWhen we enter our user name, \ngetty\n\u2019s job is complete, and it then invokes the \nlogin\n program, similar to:\n\n\nexecle(\n/bin/login\n, \nlogin\n, \n-p\n, username, (char *)0, envp);\n\n\n\n\n\n\n\n\n\nThough \ninit\n invokes \ngetty\n with an empty environment, \ngetty\n creates an environment for \nlogin\n (the \nenvp\n argument) with the name of the terminal (something like \nTERM=foo\n, where the type of terminal \nfoo\n is taken from the \ngettytab\n file) and any environment strings that are specified in the \ngettytab\n. The \n-p\n flag to \nlogin\n tells it to preserve the environment that it is passed and to add to that environment, not replace it.\n\n\n\n\nlogin\n does the following things:\n\n\nIt calls \ngetpwnam\n to fetch our password file entry.\n\n\nIt calls \ngetpass(3)\n to display the prompt \nPassword:\n and read our password (with echoing disabled).\n\n\nIt calls \ncrypt(3)\n to encrypt the password that we entered and compares the encrypted result to the \npw_passwd\n field from our shadow password file entry.\n\n\nIf the login attempt fails because of an invalid password (after a few tries), \nlogin\n calls \nexit\n with an argument of 1. This termination will be noticed by the parent (\ninit\n), and it will do another \nfork\n followed by an \nexec\n of \ngetty\n, starting the procedure over again for this terminal.\n\n\n\n\n\n\n\n\nThis is the traditional authentication procedure used on UNIX systems. Modern UNIX systems have evolved to support multiple authentication procedures. FreeBSD, Linux, Mac OS X, and Solaris all support a more flexible scheme known as PAM (\nPluggable Authentication Modules\n). PAM allows an administrator to configure the authentication methods to be used to access services that are written to use the PAM library. [p288]\n\n\nIf we log in correctly, \nlogin\n will:\n\n\n\n\nChange to our home directory (\nchdir\n)\n\n\nChange the ownership of our terminal device (\nchown\n) so we own it\n\n\nChange the access permissions for our terminal device so we have permission to read from and write to it\n\n\nSet our group IDs by calling \nsetgid\n and \ninitgroups\n\n\nInitialize the environment with all the information that login has:\n\n\nour home directory (\nHOME\n),\n\n\nshell (\nSHELL\n),\n\n\nuser name (\nUSER\n and \nLOGNAME\n),\n\n\nand a default path (\nPATH\n).\n\n\n\n\n\n\n\n\nChange to our user ID (\nsetuid\n) and invoke our login shell, as in\n\n\nexecl(\n/bin/sh\n, \n-sh\n, (char *)0);\n\n\n\n\n\nThe minus sign as the first character of \nargv[0]\n is a flag to all the shells that indicates they are being invoked as a \nlogin shell\n. The shells can look at this character and modify their start-up accordingly.\n\n\n\n\n\n\nThe \nlogin\n can optionally print the \nmessage-of-the-day\n file, check for new mail, and performs other tasks.\n\n\nSince it is called by a superuser process, \nsetuid\n changes all three user IDs: the real user ID, effective user ID, and saved set-user-ID. The call to \nsetgid\n that was done earlier by \nlogin\n has the same effect on all three group IDs.\n\n\nAt this point, our login shell is running. Its parent process ID is the original \ninit\n process (process ID 1), so when our login shell terminates, \ninit\n is sent a \nSIGCHLD\n signal and it starts the whole procedure over again for this terminal. File descriptors 0, 1, and 2 for our login shell are set to the terminal device. See the figure below:\n\n\n\n\nOur login shell now reads its start-up files (\n.profile\n for the Bourne shell and Korn shell; \n.bash_profile\n, \n.bash_login\n, or \n.profile\n for the GNU Bourne-again shell; and \n.cshrc\n and \n.login\n for the C shell). These start-up files usually change some of the environment variables and add many other variables to the environment. For example, most users set their own \nPATH\n and often prompt for the actual terminal type (\nTERM\n). When the start-up files are done, we finally get the shell\u2019s prompt and can enter commands.\n\n\nMac OS X Terminal Logins\n\n\nOn Mac OS X, the terminal login process follows essentially the same steps as in the BSD login process (since Mac OS X is based in part on FreeBSD) with the following differences:\n\n\n\n\nThe work of \ninit\n is performed by \nlaunchd\n.\n\n\nWe are presented with a graphical-based login screen from the start.\n\n\n\n\nLinux Terminal Logins\n\n\nThe Linux login procedure is very similar to the BSD procedure. The login command is derived from 4.3BSD. The main difference is in terminal configuration.\n\n\nSome Linux distributions ship with a version of the \ninit\n program that uses administrative files patterned after System V\u2019s \ninit\n file formats. where \n/etc/inittab\n specifies the terminal devices for which \ninit\n should start a \ngetty\n process. Other Linux distributions, such as Ubuntu, ship with a version of init that is known as \"\nUpstart\n\". It uses configuration files named \n*.conf\n that are\nstored in the \n/etc/init\n directory. For example, the specifications for running \ngetty\n on \n/dev/tty1\n might be found in the file \n/etc/init/tty1.conf\n.\n\n\nDepending on the version of \ngetty\n in use, the terminal characteristics are specified either on the command line (as with \nagetty\n) or in the file \n/etc/gettydefs\n (as with \nmgetty\n).\n\n\nSolaris Terminal Logins\n\n\n[p290]\n\n\nNetwork Logins\n\n\nThe main difference between a serial terminal login and a network login is that the connection between the terminal and the computer isn\u2019t point-to-point. In this case, \nlogin\n is simply a service available, just like any other network service, such as FTP or SMTP.\n\n\nWith the terminal logins, \ninit\n knows which terminal devices are enabled for logins and spawns a \ngetty\n process for each device. In the case of network logins, however, all the logins come through the kernel\u2019s network interface drivers (e.g., the Ethernet driver), and we don\u2019t know ahead of time how many of these will occur. Instead of having a process waiting for each possible login, we now have to wait for a network connection request to arrive.\n\n\nTo allow the same software to process logins over both terminal logins and network logins, a software driver called a \npseudo terminal\n (detailed in \nChapter 19\n) is used to emulate the behavior of a serial terminal and map terminal operations to network operations, and vice versa.\n\n\nBSD Network Logins\n\n\nIn BSD, the \ninetd\n process, sometimes called the \nInternet superserver\n, waits for most network connections.\n\n\nAs part of the system start-up, \ninit\n invokes a shell that executes the shell script \n/etc/rc\n, which starts \ninetd\n along with other daemons. Once the shell script terminates, the parent process of \ninetd\n becomes \ninit\n; \ninetd\n waits for TCP/IP connection requests to arrive at the host. When a connection request arrives for it to handle, \ninetd\n does a \nfork\n and \nexec\n of the appropriate program.\n\n\nAssume a TCP connection request arrives for the TELNET server (a remote login application). The remote user initiates the login by starting the TELNET client:\n\n\ntelnet hostname\n\n\n\n\n\nThe client opens a TCP connection to \nhostname\n and the user who started the client program is now logged in to the server\u2019s host. The figure below shows the sequence of processes involved in executing the TELNET server, called \ntelnetd\n:\n\n\n\n\nThen, \nthe \ntelnetd\n process then opens a pseudo terminal device and splits into two processes using \nfork\n,\n which do the following:\n\n\n\n\nThe parent (\ntelnetd\n) handles the communication across the network connection.\n\n\nThe child \nexec\ns the \nlogin\n program.\n\n\nThe parent and the child are connected through the pseudo terminal. Before doing the \nexec\n, the child sets up file descriptors 0, 1, and 2 to the pseudo terminal.\n\n\nIf we log in correctly, login performs the same steps described in \nSection 9.2\n: it changes to our home directory and sets our group IDs, user ID, and our initial environment. Then \nlogin\n replaces itself with our login shell by calling \nexec\n.\n\n\n\n\n\n\nWhether we log in through a terminal (\nFigure 9.3\n) or a network (\nFigure 9.5\n), we have a login shell with its standard input, standard output, and standard error connected to either a terminal device or a pseudo terminal device.\n\n\nIn the coming sections, we'll see that the login shell is the start of a POSIX.1 session, and that the terminal or pseudo terminal is the controlling terminal for the session.\n\n\nMac OS X Network Logins\n\n\nThe network login on Mac OS X is identical to that on BSD, except that the \ntelnet\n daemon is run from \nlaunchd\n. By default, the \ntelnet\n daemon is disabled on Mac OS X (although it can be enabled with the \nlaunchctl(1)\n command). The preferred way to perform a network login on Mac OS X is with \nssh\n, the secure shell command.\n\n\nLinux Network Logins\n\n\nNetwork logins under Linux are the same as under BSD, except that some distributions use an alternative \ninetd\n process called the extended Internet services daemon, \nxinetd\n. The \nxinetd\n process provides a finer level of control over services it starts compared to \ninetd\n.\n\n\nSolaris Network Logins\n\n\n[p293]\n\n\nProcess Groups\n\n\nIn addition to having a process ID, each process belongs to a \nprocess group\n.\n\n\n\n\nA process group is a collection of one or more processes (usually associated with the same job) that can receive signals from the same terminal.\n\n\nEach process group has a unique process group ID. Process group IDs are similar to process IDs: they are positive integers and can be stored in a \npid_t\n data type.\n\n\n\n\nThe function \ngetpgrp\n returns the process group ID of the calling process. The \ngetpgid\n function took a \npid\n argument and returned the process group for that process.\n\n\n\n\napue_getpgrp.h\n\n\n\n\n\n\n\nFor \ngetpgid\n, if \npid\n is 0, the process group ID of the calling process is returned. Thus,\n\n\ngetpgid\n(\n0\n);\n\n\n\n\n\n\nis equivalent to:\n\n\ngetpgrp\n();\n\n\n\n\n\n\nEach process group can have a \nprocess group leader\n, whose process group ID equals to its process ID.\n\n\nProcess group lifetime\n\n\nThe process group life time is the period of time that begins when the group is created and ends when the last remaining process leaves the group. It is possible for a process group leader to create a process group, create processes in the group, and then terminate. The process group still exists, as long as at least one process is in the group, regardless of whether the group leader terminates. The last remaining process in the process group can either terminate or enter some other process group.\n\n\nsetpgid\n function\n\n\nA process can join an existing process group or creates a new process group by calling \nsetpgid\n.\n\n\n\n\napue_setpgid.h\n\n\n\n\n\n\n\nThe \nsetpgid\n function sets the process group ID of the process whose process ID equals \npid\n to \npgid\n.\n\n\nArguments:\n\n\n\n\nIf \npid\n == \npgid\n, the process specified by \npid\n becomes a process group leader.\n\n\nIf \npid\n == 0, the process ID of the caller is used.\n\n\nIf \npgid\n == 0, then the specified \npid\n is used as the process group ID.\n\n\n\n\nRules:\n\n\n\n\nA process can set the process group ID of only itself or any of its children.\n\n\nA process cannot change the process group ID of one of its children after that child has called one of the \nexec\n functions.\n\n\n\n\nJob-control shells\n\n\nIn most job-control shells, this function is called after a \nfork\n to have the parent set the process group ID of the child, and to have the child set its own process group ID. \nOne of these calls is redundant, but by doing both, we are guaranteed that the child is placed into its own process group before either process assumes that this has happened.  If we didn\u2019t do this, we would have a race condition, since the child\u2019s process group membership would depend on which process executes first.\n (See \nDoubts and Solutions\n for details) [p294]\n\n\nProcess groups and signals\n\n\nWe can send a signal to either a single process (identified by its process ID) or a process group (identified by its process group ID). Similarly, the \nwaitpid\n function lets us wait for either a single process or one process from a specified process group.\n\n\nSessions\n\n\nA session is a collection of one or more process groups.\n\n\n\n\nThe processes in a process group are usually placed there by a shell pipeline. The arrangement in the figure above is generated by the shell commands of the form:\n\n\nproc1 \n|\n proc2 \n\nproc3 \n|\n proc4 \n|\n proc5\n\n\n\n\n\nThe \nsetsid\n function\n\n\nA process establishes a new session by calling the \nsetsid\n function.\n\n\n\n\napue_setsid.h\n\n\n\n\n\n\n\nIf the calling process is not a process group leader, this function creates a new session. Three things happen:\n\n\n\n\nThe process becomes the \nsession leader\n of this new session. (A session leader is the process that creates a session.) The process is the only process in this new session\n\n\nThe process becomes the process group leader of a new process group. The new process group ID is the process ID of the calling process.\n\n\nThe process has no controlling terminal. If the process had a controlling terminal before calling \nsetsid\n, that association is broken.\n\n\n\n\nThis function returns an error if the caller is already a process group leader.\n\n\nEnsuring the successful call of \nsetsid\n\n\nSince the \nsetsid\n function returns an error if the caller is a process group leader, to ensure this is not the case, the usual practice is to call \nfork\n and have the parent terminate and the child continue. It is guaranteed that the child is not a process group leader, because the process group ID of the parent is inherited by the child, but the child gets a new process ID. Hence, it is impossible for the child\u2019s process ID to equal its inherited process group ID.\n\n\nSession Leader and Session ID\n\n\nThe Single UNIX Specification talks only about a \"session leader\"; there is no \"session ID\" similar to a process ID or a process group ID. A session leader is a single process that has a unique process ID, so we could talk about a session ID that is the process ID of the session leader. This concept of a session ID was introduced in SVR4.\n\n\nThe \ngetsid\n function\n\n\nThe \ngetsid\n function returns the process group ID of a process\u2019s session leader.\n\n\n\n\napue_getsid.h\n\n\n\n\n\n\n\nIf \npid\n is 0, \ngetsid\n returns the process group ID of the calling process\u2019s session leader. For security reasons, some implementations may restrict the calling process from obtaining the process group ID of the session leader if \npid\n doesn\u2019t belong to the same session as the caller.\n\n\nControlling Terminal\n\n\nSessions and process groups have a few other characteristics.\n\n\n\n\nA session can have a single \ncontrolling terminal\n. This is usually the terminal device (in the case of a \nterminal login\n) or pseudo terminal device (in the case of a \nnetwork login\n) on which we log in.\n\n\nThe session leader that establishes the connection to the controlling terminal is called the \ncontrolling process\n.\n\n\nThe process groups within a session can be divided into a single \nforeground process group\n and one or more \nbackground process groups\n.\n\n\nIf a session has a controlling terminal, it has a single foreground process group and all other process groups in the session are background process groups.\n\n\nWhenever we press the terminal\u2019s interrupt key (often DELETE or Control-C), the interrupt signal is sent to all processes in the foreground process group.\n\n\nWhenever we press the terminal\u2019s quit key (often Control-backslash), the quit signal is sent to all processes in the foreground process group.\n\n\nIf a modem (or network) disconnect is detected by the terminal interface, the hang-up signal is sent to the controlling process (the session leader).\n\n\n\n\nThese characteristics are shown in the figure below:\n\n\n\n\nUsually, the controlling terminal is established automatically when we log in.\n\n\nMechanisms of allocating a controlling terminal\n\n\nSystem V\n\n\nSystems derived from UNIX System V allocate the controlling terminal for a session when the session leader opens the first terminal device that is not already associated with a session, as long as the call to \nopen\n does not specify the \nO_NOCTTY\n flag.\n\n\nBSD\n\n\nBSD-based systems allocate the controlling terminal for a session when the session leader calls \nioctl\n with a request argument of \nTIOCSCTTY\n (the third argument is a null pointer). The session cannot already have a controlling terminal for this call to succeed. Normally, this call to \nioctl\n follows a call to \nsetsid\n, which guarantees that the process is a session leader without a controlling terminal.\n\n\nNote that although Mac OS X 10.6.8 is derived from BSD, it behaves like System V when allocating a controlling terminal.\n\n\n\n\n\n\n\n\nMethod\n\n\nFreeBSD 8.0\n\n\nLinux 3.2.0\n\n\nMac OS X 10.6.8\n\n\nSolaris 10\n\n\n\n\n\n\n\n\n\n\nopen\n without \nO_NOCTTY\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\n\n\n\n\nTIOCSCTTY\n \nioctl\n command\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\n\n\n\n\n\n\nWhen a program wants to talk to the controlling terminal, regardless of whether the standard input or standard output is redirected, it can \nopen\n the file \n/dev/tty\n. This special file is a synonym within the kernel for the controlling terminal. If the program doesn\u2019t have a controlling terminal, the \nopen\n of this device will fail.\n\n\nThe \ncrypt\n command and \ngetpass\n function\n\n\nThe classic example is the \ngetpass(3)\n function, which reads a password (with terminal echoing turned off, of course). [p298]\n\n\nThe \ngetpass\n function is called by the \ncrypt(1)\n program and can be used in a pipeline. For example:\n\n\ncrypt \n salaries \n|\n lpr\n\n\n\n\n\nIt decrypts the file salaries and pipes the output to the print spooler. Because \ncrypt\n reads its input file on its standard input, the standard input can\u2019t be used to enter the password. Also, \ncrypt\n is designed so that we have to enter the encryption password each time we run the program, to prevent us from saving the password in a file (which could be a security hole).\n\n\ntcgetpgrp\n, \ntcsetpgrp\n, and \ntcgetsid\n Functions\n\n\nWe need a way to tell the kernel which process group is the foreground process group, so that the terminal device driver knows where to send the terminal input and the terminal-generated signals. (\nFigure 9.7\n)\n\n\n\n\napue_tcgetpgrp.h\n\n\n\n\n\n\n\n\n\nThe function \ntcgetpgrp\n returns the process group ID of the foreground process group associated with the terminal open on \nfd\n.\n\n\nIf the process has a controlling terminal, the process can call \ntcsetpgrp\n to set the foreground process group ID to \npgrpid\n. The value of \npgrpid\n must be the process group ID of a process group in the same session, and \nfd\n must refer to the controlling terminal of the session.\n\n\n\n\nThese two functions are normally called by job-control shells.\n\n\nThe \ntcgetsid\n function allows an application to obtain the process group ID for the session leader given a file descriptor for the controlling TTY.\n\n\n\n\napue_tcgetsid.h\n\n\n\n\n\n\n\nApplications that need to manage controlling terminals can use \ntcgetsid\n to identify the session ID of the controlling terminal\u2019s session leader, which is equivalent to the session leader\u2019s process group ID.\n\n\nJob Control\n\n\nJob control\n allows us to start multiple jobs (groups of processes) from a single terminal and to control which jobs can access the terminal and which jobs are run in the background. Job control requires three forms of support:\n\n\n\n\nA shell that supports job control\n\n\nThe terminal driver in the kernel must support job control\n\n\nThe kernel must support certain job-control signals\n\n\n\n\nFrom our perspective, when using job control from a shell, we can start a job in either the foreground or the background. A job is simply a collection of processes, often a pipeline of processes.\n\n\nFor example, start a job consisting of one process in the foreground:\n\n\nvi main.c\n\n\n\n\n\nStart two jobs in the background (all the processes invoked by these background jobs are in the background.):\n\n\npr *.c \n|\n lpr \n\nmake all \n\n\n\n\n\n\nKorn shell example\n\n\nWhen we start a background job, the shell assigns it a job identifier and prints one or more of the process IDs.\n\n\n$ make all \n Make.out \n\n\n[1] 1475\n\n\n$ pr *.c | lpr \n\n\n[2] 1490\n\n\n$   # just press RETURN\n\n\n[2] + Done pr *.c | lpr \n\n\n[1] + Done make all \n Make.out \n\n\n\n\n\n\n\n\nThe \nmake\n is job number 1 and the starting process ID is 1475. The next pipeline is job number 2 and the process ID of the first process is 1490.\n\n\nWhen the jobs are done and we press RETURN, the shell tells us that the jobs are complete. The reason we have to press RETURN is to have the shell print its prompt. The shell doesn\u2019t print the changed status of background jobs at any random time (only after we press RETURN and right before it prints its prompt, to let us enter a new command line). If the shell didn\u2019t do this, it could produce output while we were entering an input line.\n\n\nThe interaction with the terminal driver arises because a special terminal character affects the foreground job. The terminal driver looks for three special characters, which generate signals to (all processes in ) the foreground process group:\n\n\nSIGINT\n: generated by the interrupt character (typically DELETE or Control-C).\n\n\nSIGQUIT\n: generated by the quit character (typically Control-backslash).\n\n\nSIGTSTP\n: generated by the suspend character (typically Control-Z).\n\n\n\n\n\n\n\n\nWhile we can have a foreground job and one or more background jobs, only the foreground job receives terminal input (the characters that we enter at the terminal). It is not an error for a background job to try to read from the terminal, but the terminal driver detects this and sends a special signal to the background job: \nSIGTTIN\n. This signal normally stops the background job; by using the shell, we are notified of this event and can bring the job into the foreground so that it can read from the terminal.\n\n\ncat \n temp.foo \n   # start in background, but it\u2019ll read from standard input\n\n\n[1] 1681\n\n\n$                  # we press RETURN\n\n\n[1] + Stopped (SIGTTIN) cat \n temp.foo \n\n\n$ fg %1            # bring job number 1 into the foreground\n\n\ncat \n temp.foo     # the shell tells us which job is now in the foreground\n\n\nhello, world       # enter one line\n\n\n\u02c6D                 # type the end-of-file character\n\n\n$ cat temp.foo     # check that the one line was put into the file\n\n\nhello, world\n\n\n\n\n\n\n\n\nSIGTTIN\n: When the background \ncat\n tries to read its standard input (the controlling terminal), the terminal driver, knowing that it is a background job, sends the \nSIGTTIN\n signal to the background job.\n\n\nThe shell detects the change in status of its child (see \nwait\n and \nwaitpid\n function in \nSection 8.6\n) and tells us that the job has been stopped.\n\n\nThe shell\u2019s \nfg\n command move the stopped job into the foreground, which causes the shell to place the job into the foreground process group (tcsetpgrp) and send the continue signal (\nSIGCONT\n) to the process group.\n\n\nSince it is now in the foreground process group, the job can read from the controlling terminal.\n\n\n\n\nNote that this example doesn\u2019t work on Mac OS X 10.6.8. When we try to bring the cat command into the foreground, the read fails with errno set to EINTR. Since Mac OS X is based on FreeBSD, and FreeBSD works as expected, this must be a bug in Mac OS X.\n\n\nThere is an option that we can allow or disallow a background job to send its output to the controlling terminal. Normally, we use the \nstty(1)\n command to change this option.\n\n\n$ cat temp.foo \n   # execute in background\n\n\n[1] 1719\n\n\n$ hello, world     # the output from the background job appears after the prompt\n\n\nwe press RETURN\n\n\n[1] + Done cat temp.foo \n\n\n$ stty tostop      # disable ability of background jobs to output to controlling terminal\n\n\n$ cat temp.foo \n   # try it again in the background\n\n\n[1] 1721\n\n\n$                  # we press RETURN and find the job is stopped\n\n\n[1] + Stopped(SIGTTOU) cat temp.foo \n\n\n$ fg %1            # resume stopped job in the foreground\n\n\ncat temp.foo       # the shell tells us which job is now in the foreground\n\n\nhello, world       # and here is its output\n\n\n\n\n\n\nWhen we disallow background jobs from writing to the controlling terminal, cat will block when it tries to write to its standard output, because the terminal driver identifies the write as coming from a background process and sends the job the \nSIGTTOU\n signal. When we use the shell\u2019s \nfg\n command to bring the job into the foreground, the job completes.\n\n\nThe figure below summarizes some of the features of job control that have been described so far:\n\n\n\n\n\n\nThe solid lines through the terminal driver box mean that the terminal I/O and the terminal-generated signals are always connected from the foreground process group to the actual terminal.\n\n\nThe dashed line corresponding to the \nSIGTTOU\n signal means that whether the output from a process in the background process group appears on the terminal is an option.\n\n\n\n\nJob control was originally designed and implemented before windowing terminals were widespread. It is a required feature of POSIX.1. [p302-303]\n\n\nShell Execution of Programs\n\n\nThis section examines how the shells execute programs and how this relates to the concepts of process groups, controlling terminals, and sessions\n\n\nThe shell without job control: the Bourne shell on Solaris\n\n\nFor example, with the classic Bourne shell running on Solaris, we execute:\n\n\nps -o pid,ppid,pgid,sid,comm\n\n\n\n\n\nThe output is\n\n\n  PID  PPID  PGID  SID COMMAND\n  949   947   949  949 sh\n 1774   949   949  949 ps\n\n\n\n\n\n\n\nThe parent of the \nps\n command is the shell.\n\n\nBoth the shell and the \nps\n command are in the same session and foreground process group (949), \nbecause that is what you get when you execute a command with a shell that doesn\u2019t support job control.\n\n\n\n\nTerminal process group ID: \ntpgid\n option of the \nps(1)\n command\n\n\n[p303]\n\n\nSome platforms support an \ntpgid\n option to have the \nps(1)\n command print the process group ID associated with the session\u2019s controlling terminal. This value would be shown under the TPGID column:\n\n\nps -o pid,ppid,pgid,sid,tpgid,comm\n\n\n\n\n\nNote that it is misleading to associate a process with a terminal process group ID (the TPGID column):\n\n\n\n\nA process does not have a terminal process control group. A process belongs to a process group, and the process group belongs to a session.\n\n\nThe session may or may not have a controlling terminal.\n\n\nIf the session does have a controlling terminal, then the terminal device knows the process group ID of the foreground process. This value can be set in the terminal driver with the \ntcsetpgrp\n function (\nFigure 9.9\n).\n\n\n\n\n\n\nThe foreground process group ID is an attribute of the terminal, not the process. This value from the terminal device driver is what ps prints as the TPGID. If it finds that the session doesn\u2019t have a controlling terminal, ps prints either 0 or \u22121, depending on the platform.\n\n\n\n\nIf we execute the command in the background:\n\n\nps -o pid,ppid,pgid,sid,comm \n\n\n\n\n\n\nThe only value that changes is the process ID of the command:\n\n\n  PID  PPID  PGID  SID COMMAND\n  949   947   949  949 sh\n 1812   949   949  949 ps\n\n\n\n\n\nThis shell doesn\u2019t know about job control, so the background job is not put into its own process group and the controlling terminal isn\u2019t taken away from the background job.\n\n\nTo see how this shell handles a pipeline, we execute:\n\n\nps -o pid,ppid,pgid,sid,comm \n|\n cat1\n\n\n\n\n\nThe output is:\n\n\n  PID  PPID  PGID  SID COMMAND\n  949   947   949  949 sh\n 1823   949   949  949 cat1\n 1824  1823   949  949 ps\n\n\n\n\n\nThe program \ncat1\n is just a copy of the standard \ncat\n program, with a different name. The last process in the pipeline (\ncat\n) is the child of the shell and that the first process in the pipeline (\nps\n) is a child of the last process. It appears that \nthe shell \nfork\ns a copy of itself and that this copy then forks to make each of the previous processes in the pipeline.\n\n\nIf we execute the pipeline in the background:\n\n\nps -o pid,ppid,pgid,sid,comm \n|\n cat1 \n\n\n\n\n\n\nOnly the process IDs change. Since the shell doesn\u2019t handle job control, the process group ID of the background processes remains 949, as does the process group ID of the session\n\n\nIf a background process tries to read from its controlling terminal, like:\n\n\ncat \n temp.foo \n\n\n\n\n\n\nWithout job control, the shell automatically redirects the standard input of a background process to \n/dev/null\n, if the process doesn\u2019t redirect standard input itself. A read from \n/dev/null\n generates an end of file. This means that our background \ncat\n process immediately reads an end of file and terminates normally.\n\n\nThe previous paragraph adequately handles the case of a background process accessing the controlling terminal through its standard input, but what happens if a background process specifically opens \n/dev/tty\n and reads from the controlling terminal? The answer is \"It depends\", but the result is probably not what we want. For example:\n\n\ncrypt \n salaries \n|\n lpr \n\n\n\n\n\n\nThis pipeline is run in the background, but the \ncrypt\n program opens \n/dev/tty\n, changes the terminal characteristics (to disable echoing), reads from the device, and resets the terminal characteristics. The prompt \nPassword:\n from \ncrypt\n is printed on the terminal, but what we enter (the encryption password) is read by the shell, which tries to execute a command of that name. The next line we enter to the shell is taken as the password, and the file is not encrypted correctly, sending junk to the printer. Here we have two processes trying to read from the same device at the same time, and the result depends on the system. Job control, as described earlier, handles this multiplexing of a single terminal between multiple processes in a better fashion. [p304]\n\n\nIf we execute three processes in the pipeline, we can examine the process control used by this shell:\n\n\nps -o pid,ppid,pgid,sid,comm \n|\n cat1 \n|\n cat2\n\n\n\n\n\nThe output is: [p305]\n\n\n  PID  PPID  PGID  SID COMMAND\n  949   947   949  949 sh\n 1988   949   949  949 cat2\n 1989  1988   949  949 ps\n 1990  1988   949  949 cat1\n\n\n\n\n\nAgain, the last process in the pipeline is the child of the shell, and all previous processes in the pipeline are children of the last process. See the figure below:\n\n\n\n\nSince the last process in the pipeline is the child of the login shell, the shell is notified when that process (\ncat2\n) terminates.\n\n\nThe shell with job control: Bourne-again shell on Linux\n\n\nStarting with this example, foreground process group are shown in \nbolder font\n.\n\n\nThe command:\n\n\nps -o pid,ppid,pgid,sid,tpgid,comm\n\n\n\n\n\ngives us:\n\n\n\n   PID   PPID   PGID   SID  TPGID  COMMAND\n  2837   2818   2837  2837   5796  bash\n  \n5796\n   2837   \n5796\n  2837   5796  ps\n\n\n\n\nWe can see the result, which is different from the Bourne shell example:\n\n\n\n\nThe Bourne-again shell places the foreground job (\nps\n) into its own process group (5796).\n\n\nThe \nps\n command is the process group leader and the only process in this process group. This process group is the foreground process group, since it has the controlling terminal.\n\n\nThe login shell is a background process group while the \nps\n command executes.\n\n\nBoth process groups, 2837 and 5796, are members of the same session.\n\n\n\n\nExecuting this process in the background:\n\n\nps -o pid,ppid,pgid,sid,tpgid,comm \n\n\n\n\n\n\ngives us:\n\n\n\n   PID   PPID   PGID   SID  TPGID  COMMAND\n  \n2837\n   2818   \n2837\n  2837   2837  bash\n  5797   2837   5797  2837   2837  ps\n\n\n\n\n\n\nps\n command is again placed into its own process group.\n\n\nThe process group (5797) is no longer the foreground process group but a background process group.\n\n\nThe foreground process group is our login shell, as indicated by TPGID of 2837.\n\n\n\n\nExecuting two processes in a pipeline, as in:\n\n\nps -o pid,ppid,pgid,sid,tpgid,comm \n|\n cat1\n\n\n\n\n\ngives us:\n\n\n\n   PID   PPID   PGID   SID  TPGID  COMMAND\n  2837   2818   2837  2837   5799  bash\n  \n5799\n   2837   \n5799\n  2837   5799  ps\n  \n5800\n   2837   \n5799\n  2837   5799  cat1\n\n\n\n\n\n\nBoth processes, \nps\n and \ncat1\n, are placed into a new process group (5799), which is the foreground process group.\n\n\nThe login shell is the parent of both processes. This is different from the Bourne shell, which created the last process (\ncat1\n) in the pipeline first, and this process is the parent of first process (\nps\n).\n\n\n\n\nIf we execute this pipeline in the background:\n\n\nps -o pid,ppid,pgid,sid,tpgid,comm \n|\n cat1 \n\n\n\n\n\n\nThe output:\n\n\n\n   PID   PPID   PGID   SID  TPGID  COMMAND\n  \n2837\n   2818   \n2837\n  2837   2837  bash\n  5801   2837   5801  2837   2837  ps\n  5802   2837   5801  2837   2837  cat1\n\n\n\n\nThe results are similar, but now \nps\n and \ncat1\n are placed in the same background process group (5801).\n\n\n[p307]\n\n\nOrphaned Process Groups\n\n\nA process whose parent terminates is called an orphan and is inherited by the \ninit\n process. The entire process groups that can be orphaned and this section discusses how POSIX.1 handles this situation.\n\n\nExample of a process whose child is stopped\n\n\nThe following figure shows a situation: the parent process has \nfork\ned a child that stops, and the parent is about to exit.\n\n\n\n\nThe program that creates an orphaned process group is shown below:\n\n\n\n\nrelation/orphan3.c\n\n\n\n\n#include \napue.h\n\n\n#include \nerrno.h\n\n\n\nstatic\n \nvoid\n\n\nsig_hup\n(\nint\n \nsigno\n)\n\n\n{\n\n    \nprintf\n(\nSIGHUP received, pid = %ld\n\\n\n,\n \n(\nlong\n)\ngetpid\n());\n\n\n}\n\n\n\nstatic\n \nvoid\n\n\npr_ids\n(\nchar\n \n*\nname\n)\n\n\n{\n\n    \nprintf\n(\n%s: pid = %ld, ppid = %ld, pgrp = %ld, tpgrp = %ld\n\\n\n,\n\n        \nname\n,\n \n(\nlong\n)\ngetpid\n(),\n \n(\nlong\n)\ngetppid\n(),\n \n(\nlong\n)\ngetpgrp\n(),\n\n        \n(\nlong\n)\ntcgetpgrp\n(\nSTDIN_FILENO\n));\n\n    \nfflush\n(\nstdout\n);\n\n\n}\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \nchar\n    \nc\n;\n\n    \npid_t\n   \npid\n;\n\n\n    \npr_ids\n(\nparent\n);\n\n    \nif\n \n((\npid\n \n=\n \nfork\n())\n \n \n0\n)\n \n{\n\n        \nerr_sys\n(\nfork error\n);\n\n    \n}\n \nelse\n \nif\n \n(\npid\n \n \n0\n)\n \n{\n   \n/* parent */\n\n        \nsleep\n(\n5\n);\n       \n/* sleep to let child stop itself */\n\n    \n}\n \nelse\n \n{\n            \n/* child */\n\n        \npr_ids\n(\nchild\n);\n\n        \nsignal\n(\nSIGHUP\n,\n \nsig_hup\n);\n    \n/* establish signal handler */\n\n        \nkill\n(\ngetpid\n(),\n \nSIGTSTP\n);\n    \n/* stop ourself */\n\n        \npr_ids\n(\nchild\n);\n    \n/* prints only if we\nre continued */\n\n        \nif\n \n(\nread\n(\nSTDIN_FILENO\n,\n \nc\n,\n \n1\n)\n \n!=\n \n1\n)\n\n            \nprintf\n(\nread error %d on controlling TTY\n\\n\n,\n \nerrno\n);\n\n    \n}\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nResult in a job-control shell:\n\n\n$ ./a.out\n\n\nparent: pid = 6099, ppid = 2837, pgrp = 6099, tpgrp = 6099\n\n\nchild: pid = 6100, ppid = 6099, pgrp = 6099, tpgrp = 6099\n\n\n$ SIGHUP received, pid = 6100\n\n\nchild: pid = 6100, ppid = 1, pgrp = 6099, tpgrp = 2837\n\n\nread error 5 on controlling TTY\n\n\n\n\n\n\nAnalysis: [p307-309]\n\n\n\n\nThe shell places the foreground process into its own process group (6099) and the shell itself stays in its own process group (2837). The child inherits the process group of its parent (6099).\n\n\nAfter \nfork\n, the parent sleeps for 5 seconds. This is our (imperfect) way of letting the child execute before the parent terminates.\n\n\nThe child establishes a signal handler for the hang-up signal (\nSIGHUP\n) so we can see whether it is sent to the child. (signal handlers are discussed in \nChapter 10\n)\n\n\nThe child sends itself the stop signal (\nSIGTSTP\n) with the \nkill\n function. This stops the child, similar to our stopping a foreground job with our terminal\u2019s suspend character (Control-Z).\n\n\nWhen the parent terminates, the child is orphaned, so the child\u2019s parent process ID becomes 1, which is the \ninit\n process ID.\n\n\nAt this point, the child is a member of an \norphaned process group\n:\n\n\nThe POSIX.1 definition of an orphaned process group: one in which the parent of every member is either itself a member of the group or is not a member of the group\u2019s session. Another way of saying this is: \nthe process group is not orphaned as long as a process in the group has a parent in a different process group but in the same session.\n\n\nIf the process group is not orphaned, there is a chance that one of those parents in a different process group but in the same session will restart a stopped process in the process group that is not orphaned. Here, the parent of every process in the group (e.g., process 1 is the parent of process 6100) belongs to another session.\n\n\n\n\n\n\nSince the process group is orphaned when the parent terminates, and the process group contains a stopped process, POSIX.1 requires that every process in the newly orphaned process group be sent the hang-up signal (\nSIGHUP\n) followed by the continue signal (\nSIGCONT\n).\n\n\nThis causes the child to be continued, after processing the hang-up signal. The default action for the hang-up signal is to terminate the process, so we have to provide a signal handler to catch the signal. We therefore expect the \nprintf\n in the \nsig_hup\n function to appear before the \nprintf\n in the \npr_ids\n function.\n\n\n\n\n\n\nNote that the shell prompt appears with the output from the child, because two processes (login shell and the child) are writing to the terminal. The parent process ID of the child has become 1.\n\n\nAfter calling \npr_ids\n in the child, the program tries to read from standard input. POSIX.1 specifies that the \nread\n is to return an error with errno set to EIO (whose value is 5 on this system) in this situation. [p309]\n\n\nAs discussed earlier in this chapter, when a process in a background process group tries to read from its controlling terminal, \nSIGTTIN\n is generated for the background process group. But for an orphaned process group, if the kernel were to stop it with this signal, the processes in the process group would probably never be continued.\n\n\n\n\n\n\nFinally, our child was placed in a background process group when the parent terminated, since the parent was executed as a foreground job by the shell.\n\n\n\n\nFreeBSD Implementation\n\n\nThe figure below shows the FreeBSD implementation of sessions and process groups:\n\n\n\n\n\n\nsession\n structure is allocated for each session (each time \nsetsid\n is called).\n\n\ns_count\n: number of process groups in the session. When this counter is decremented to 0, the structure can be freed.\n\n\ns_leader\n: pointer to the proc structure of the session leader.\n\n\ns_ttyvp\n: pointer to the vnode structure of the controlling terminal.\n\n\ns_ttyp\n: pointer to the tty structure of the controlling terminal.\n\n\ns_sid\n: session ID. (Not part of the Single UNIX Specification)\n\n\n\n\n\n\n\n\nWhen \nsetsid\n is called, a new session structure is allocated within the kernel. \ns_count\n is set to 1, \ns_leader\n is set to point to the \nproc\n structure of the calling process, \ns_sid\n is set to the process ID, and \ns_ttyvp\n and \ns_ttyp\n are set to null pointers, since the new session doesn\u2019t have a controlling terminal.\n\n\n\n\ntty\n structure is contained in the kernel for each terminal device and each pseudo terminal device.\n\n\nt_session\n points to the \nsession\n structure that has this terminal as its controlling terminal. This pointer is used by the terminal to send a hangup signal to the session leader if the terminal loses carrier (\nFigure 9.7\n). Note that the \ntty\n and \nsession\n structure point to each other.\n\n\nt_pgrp\n points to the \npgrp\n structure of the foreground process group. This field is used by the terminal driver to send signals to the foreground process group. The three signals generated by entering special characters that are sent to the foreground process group are:\n\n\ninterrupt\n\n\nquit\n\n\nsuspend\n\n\n\n\n\n\nt_termios\n is a structure containing all the special characters and related information for this terminal, such as baud rate, whether echo is enabled, and so on.\n\n\nt_winsize\n is a \nwinsize\n structure that contains the current size of the terminal window. When the size of the terminal window changes, the \nSIGWINCH\n signal is sent to the foreground process group.\n\n\n\n\n\n\n\n\nThe kernel finds the foreground process group of a particular session by following fields of pointers, starting with the \nsession\n structure:\n\n\n\n\nFollow \ns_ttyp\n of the \nsession\n structure to get to the \ntty\n structure (controlling terminal).\n\n\n\n\nFollow \nt_pgrp\n of the \ntty\n structure to get to the \npgrp\n structure (foreground process group).\n\n\n\n\n\n\npgrp\n structure contains the information for a particular process group.\n\n\n\n\npg_id\n is the process group ID.\n\n\npg_session\n points to the \nsession\n structure for the session to which this process group belongs.\n\n\npg_members\n is a pointer to the list of \nproc\n structures that are members of this process group. The \np_pglist\n structure in that \nproc\n structure is a doubly linked list entry that points to both the next process and the previous process in the group. [p311]\n\n\n\n\n\n\nvnode\n structureis allocated when the controlling terminal device is opened. All references to \n/dev/tty\n in a process go through this \nvnode\n structure.\n\n\n\n\nSummary\n\n\nThis chapter describes relation between groups of processes, sessions, which are made up of process groups. Job control is a feature supported by most UNIX systems. The controlling terminal for a process, \n/dev/tty\n, is also involved in these process relationships.\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\np294 on \nfork\n's race condition concerning \nsetpgid\n\n\n\n\nIn most job-control shells, this function is called after a \nfork\n to have the parent set the process group ID of the child, and to have the child set its own process group ID. One of these calls is redundant, but by doing both, we are guaranteed that the child is placed into its own process group before either process assumes that this has happened.  If we didn\u2019t do this, we would have a race condition, since the child\u2019s process group membership would depend on which process executes first.\n\n\n\n\nSolution:\n\n\nThe shell (parent) wants and ensures the process to be in the right process group at any time before either of the child and parent continues execution.\n\n\n\n\nStack Overflow\n\n\nLaunching Jobs\n in the GNU C Library", 
            "title": "Chapter 9. Process Relationships"
        }, 
        {
            "location": "/apue/ch10/", 
            "text": "Chapter 10. Signals\n\n\nIntroduction\n\n\nSignals are software interrupts. They provide a way of handling asynchronous events. Most nontrivial application programs need to deal with signals.\n\n\nPOSIX reliable signals\n\n\nSignals have been provided since the early versions of the UNIX System, but the signal model provided with systems such as Version 7 was not reliable. Signals could get lost, and it was difficult for a process to turn off selected signals when executing critical regions of code. Both 4.3BSD and SVR3 made changes to the signal model, adding what are called \nreliable signals\n. But the changes made by Berkeley and AT\nT were incompatible. Fortunately, POSIX.1 standardized the reliable-signal routines, and that is what we describe here.\n\n\nThis chapter starts with an overview of signals and a description of what each signal is normally used for, then discusses problems with earlier implementations, since it is often important to understand what is wrong with an implementation before seeing how to do things correctly. This chapter contains numerous examples that are not entirely correct and a discussion of the defects.\n\n\nSignal Concepts\n\n\n\n\n\n\nEvery signal has a name. They all begin with the three characters \nSIG\n. For example:\n\n\n\n\nSIGABRT\n is the abort signal that is generated when a process calls the \nabort\n function.\n\n\nSIGALRM\n is the alarm signal that is generated when the timer set by the \nalarm\n function goes off.\n\n\n\n\nFreeBSD 8.0 supports 32 different signals. Mac OS X 10.6.8 and Linux 3.2.0 each support 31 different signals, whereas Solaris 10 supports 40 different signals. FreeBSD, Linux, and Solaris, support additional application-defined signals introduced to support \nreal-time applications\n.\n\n\n\n\n\n\nSignal names are all defined by positive integer constants (the signal number) in the header \nsignal.h\n.\n\n\n\n\nImplementations actually define the individual signals in a different header file, but this header file is included by \nsignal.h\n.\n\n\nIt bad for the kernel to include header files meant for user-level applications, so if the applications and the kernel both need the same definitions, the information is placed in a kernel header file that is then included by the user-level header file.\n\n\nsys/signal.h\n: FreeBSD 8.0 and Mac OS X 10.6.8\n\n\nbits/signum.h\n: Linux 3.2.0\n\n\nsys/iso/signal_iso.h\n: Solaris 10\n\n\n\n\n\n\n\n\n\n\nNo signal has a signal number of 0. The \nkill\n function uses the signal number of 0 for a special case. POSIX.1 calls this value the null signal.\n\n\nNumerous conditions can generate a signal:\n\n\nThe terminal-generated signals occur when users press certain terminal keys. Pressing the DELETE key or Control-C on the terminal normally causes the interrupt signal (\nSIGINT\n) to be generated.\n\n\nHardware exceptions generate signals. For example, divide by 0 and invalid memory reference. These conditions are usually detected by the hardware, and the kernel is notified. The kernel then generates the appropriate signal for the process that was running at the time the condition occurred. For example, \nSIGSEGV\n is generated for a process that executes an invalid memory reference.\n\n\nThe \nkill(2)\n function allows a process to send any signal to another process or process group, with limitations: we have to be the owner of the process that we\u2019re sending the signal to, or we have to be the superuser.\n\n\nThe \nkill(1)\n command allows us to send signals to other processes. This program is just an interface to the \nkill\n function. This command is often used to terminate a runaway background process.\n\n\nSoftware conditions can generate signals when a process should be notified of various events. For example:\n\n\nSIGURG\n: generated when out-of-band data arrives over a network connection),\n\n\nSIGPIPE\n: generated when a process writes to a pipe that has no reader)\n\n\nSIGALRM\n: generated when an alarm clock set by the process expires).\n\n\n\n\n\n\n\n\n\n\n\n\nSignals are classic examples of asynchronous events. They occur at random times to the process. The process can\u2019t simply test a variable (such as \nerrno\n) to see whether a signal has occurred; instead, the process has to tell the kernel \"if and when this signal occurs, do the following\".\n\n\nSignal dispositions\n\n\nWe can tell the kernel to do one of three things when a signal occurs. This is called the \ndisposition of the signal\n, or the \naction associated with a signal\n. (\nsignal(7)\n)\n\n\n\n\nIgnore the signal\n. Most signals can be ignored, but two signals can never be ignored: \nSIGKILL\n and \nSIGSTOP\n.\n\n\nThe reason these two signals can\u2019t be ignored is to provide the kernel and the superuser with a surefire way of either killing or stopping any process.\n\n\nIf we ignore some of the signals that are generated by a hardware exception (such as illegal memory reference or divide by 0), the behavior of the process is undefined.\n\n\n\n\n\n\nCatch the signal\n. To do this, we tell the kernel to call a function of ours whenever the signal occurs. In our function, we can do whatever we want to handle the condition. For example:\n\n\nIf we\u2019re writing a command interpreter, when the user generates the interrupt signal at the keyboard, we probably want to return to the main loop of the program, terminating whatever command we were executing for the user.\n\n\nIf the \nSIGCHLD\n signal is caught, it means that a child process has terminated, so the signal-catching function can call \nwaitpid\n to fetch the child\u2019s process ID and termination status.\n\n\nIf the process has created temporary files, we may want to write a signal-catching function for the SIGTERM signal (the termination signal that is the default signal sent by the kill command) to clean up the temporary files.\n\n\nNote that the two signals \nSIGKILL\n and \nSIGSTOP\n can\u2019t be caught.\n\n\n\n\n\n\nLet the default action apply\n. Every signal has a default action. The default action for most signals is to terminate the process.\n\n\n\n\nThe signals \nSIGKILL\n and \nSIGSTOP\n cannot be caught, blocked, or ignored. (\nsignal(7)\n)\n\n\nUNIX System signals\n\n\nThe following table lists the names of all the signals, an indication of which systems support the signal, and the default action for the signal. The SUS column contains \"x\" if the signal is defined as part of the base POSIX.1 specification and XSI if it is defined as part of the XSI option. The supported systems are FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 and Solaris 10.\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nISO C\n\n\nSUS\n\n\nFreeBSD\n\n\nLinux\n\n\nMac OS X\n\n\nSolaris\n\n\nDefault action\n\n\n\n\n\n\n\n\n\n\nSIGABRT\n\n\nabnormal termination (\nabort\n)\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGALRM\n\n\ntimer expired (\nalarm\n)\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGBUS\n\n\nhardware fault\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGCANCEL\n\n\nthreads library internal use\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGCHLD\n\n\nchange in status of child\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGCONT\n\n\ncontinue stopped process\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\ncontinue/ignore\n\n\n\n\n\n\nSIGEMT\n\n\nhardware fault\n\n\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGFPE\n\n\narithmetic exception\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGFREEZE\n\n\ncheckpoint freeze\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGHUP\n\n\nhangup\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGILL\n\n\nillegal instruction\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGINFO\n\n\nstatus request from keyboard\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nignore\n\n\n\n\n\n\nSIGINT\n\n\nterminal interrupt character\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGIO\n\n\nasynchronous I/O\n\n\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate/ignore\n\n\n\n\n\n\nSIGIOT\n\n\nhardware fault\n\n\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGJVM1\n\n\nJava virtual machine internal use\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGJVM2\n\n\nJava virtual machine internal use\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGKILL\n\n\ntermination\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGLOST\n\n\nresource lost\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGLWP\n\n\nthreads library internal use\n\n\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGPIPE\n\n\nwrite to pipe with no readers\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGPOLL\n\n\npollable event (\npoll\n)\n\n\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGPROF\n\n\nprofiling time alarm (\nsetitimer\n)\n\n\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGPWR\n\n\npower fail/restart\n\n\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\nterminate/ignore\n\n\n\n\n\n\nSIGQUIT\n\n\nterminal quit character\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGSEGV\n\n\ninvalid memory reference\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGSTKFLT\n\n\ncoprocessor stack fault\n\n\n\n\n\n\n\n\nx\n\n\n\n\n\n\nterminate\n\n\n\n\n\n\nSIGSTOP\n\n\nstop\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nstop process\n\n\n\n\n\n\nSIGSYS\n\n\ninvalid system call\n\n\n\n\nXSI\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGTERM\n\n\ntermination\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGTHAW\n\n\ncheckpoint thaw\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGTHR\n\n\nthreads library internal use\n\n\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGTRAP\n\n\nhardware fault\n\n\n\n\nXSI\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core\n\n\n\n\n\n\nSIGTSTP\n\n\nterminal stop character\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nstop process\n\n\n\n\n\n\nSIGTTIN\n\n\nbackground read from control tty\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nstop process\n\n\n\n\n\n\nSIGTTOU\n\n\nbackground write to control tty\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nstop process\n\n\n\n\n\n\nSIGURG\n\n\nurgent condition (sockets)\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGUSR1\n\n\nuser-defined signal\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGUSR2\n\n\nuser-defined signal\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGVTALRM\n\n\nvirtual time alarm (\nsetitimer\n)\n\n\n\n\nXSI\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate\n\n\n\n\n\n\nSIGWAITING\n\n\nthreads library internal use\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGWINCH\n\n\nterminal window size change\n\n\n\n\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nignore\n\n\n\n\n\n\nSIGXCPU\n\n\nCPU limit exceeded (\nsetrlimit\n)\n\n\n\n\nXSI\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core/ignore\n\n\n\n\n\n\nSIGXFSZ\n\n\nfile size limit exceeded (\nsetrlimit\n)\n\n\n\n\nXSI\n\n\nx\n\n\nx\n\n\nx\n\n\nx\n\n\nterminate+core/ignore\n\n\n\n\n\n\nSIGXRES\n\n\nresource control exceeded\n\n\n\n\n\n\n\n\n\n\n\n\nx\n\n\nignore\n\n\n\n\n\n\n\n\nThe core file\n\n\nWhen the default action (in the table above) is labeled \"terminate+core\", it means that a memory image of the process is left in the file named \ncore\n of the current working directory of the process. This file can be used with most UNIX System debuggers to examine the state of the process at the time it terminated.\n\n\nThe name of the \ncore\n file varies among implementations.  On Mac OS X 10.6.8, the core file is named core.\npid\n, where \npid\n is the ID of the process that received the signal. On Linux 3.2.0, the name is configured through \n/proc/sys/kernel/core_pattern\n. (\ncore(5)\n) [p315]\n\n\nMost implementations leave the core file in the current working directory of the corresponding process; Mac OS X places all core files in \n/cores\n instead.\n\n\nThe core file will not be generated if:\n\n\n\n\nthe process was set-user-ID and the current user is not the owner of the program file,\n\n\nthe process was set-group-ID and the current user is not the group owner of the file,\n\n\nthe user does not have permission to write in the current working directory,\n\n\nthe file already exists and the user does not have permission to write to it,\n\n\nthe file is too big (see \nRLIMIT_CORE\n limit in \nSection 7.11\n)\n\n\n\n\nThe permissions of the core file (assuming that the file doesn\u2019t already exist) are usually user-read and user-write, although Mac OS X sets only user-read.\n\n\nIn the table, the signals with a description of \"hardware fault\" correspond to implementation-defined hardware faults.\n\n\nDetailed description of signals\n\n\n\n\nSIGABRT\n: generated by calling the \nabort\n function.  The process terminates abnormally.\n\n\nSIGALRM\n:\n\n\nThis signal is generated when a timer set with the \nalarm\n function expires.\n\n\nThis signal is also generated when an interval timer set by the \nsetitimer(2)\n function expires.\n\n\n\n\n\n\nSIGBUS\n: indicates an implementation-defined hardware fault.  Implementations usually generate this signal on certain types of memory faults.\n\n\nSIGCANCEL\n: used internally by the Solaris threads library. It is not meant for general use.\n\n\nSIGCHLD\n: Whenever a process terminates or stops, the \nSIGCHLD\n signal is sent to the parent. By default, this signal is ignored, so the parent must catch this signal if it wants to be notified whenever a child\u2019s status changes. The normal action in the signal-catching function is to call one of the \nwait\n functions to fetch the child\u2019s process ID and termination status. [p317]\n\n\nSIGCONT\n: this job-control signal is sent to a stopped process when it is continued. The default action is to continue a stopped process, but to ignore the signal if the process wasn\u2019t stopped.\n\n\nSIGEMT\n: indicates an implementation-defined hardware fault. Not all platforms support this signal. [p318]\n\n\nSIGFPE\n: signals an arithmetic exception, such as divide by 0, floating-point overflow, and so on. The name is derived from \"floating-point exception\" (\nProgram Error Signals\n).\n\n\nSIGFREEZE\n: defined only by Solaris. \n [p318]\n\n\nSIGHUP\n: this signal is sent to the controlling process (session leader) associated with a controlling terminal if a disconnect is detected by the terminal interface.\n\n\nThis signal is generated for this condition only if the terminal\u2019s \nCLOCAL\n flag is not set. The \nCLOCAL\n flag for a terminal is set if the attached terminal is local. The flag tells the terminal driver to ignore all modem status lines.\n\n\nThe session leader that receives this signal may be in the background (\nFigure 9.7\n). This differs from the normal terminal-generated signals (interrupt, quit, and suspend), which are always delivered to the foreground process group.\n\n\nThis signal is also generated if the session leader terminates. In this case, the signal is sent to each process in the foreground process group.\n\n\nThis signal is commonly used to notify daemon processes (\nChapter 13\n) to reread their configuration files. The reason \nSIGHUP\n is chosen for this task is that a daemon should not have a controlling terminal and would normally never receive this signal.\n\n\n\n\n\n\nSIGILL\n: indicates that the process has executed an illegal hardware instruction.\n\n\n4.3BSD generated this signal from the abort function. \nSIGABRT\n is now used for this purpose.\n\n\n\n\n\n\nSIGINFO\n: This BSD signal is generated by the terminal driver when we type the status key (often Control-T). This signal is sent to all processes in the foreground process group (Figure 9.9). This signal normally causes status information on processes in the foreground process group to be displayed on the terminal. Linux doesn\u2019t provide support for \nSIGINFO\n.\n\n\nSIGINT\n: generated by the terminal driver when we press the interrupt key (often DELETE or Control-C). This signal is sent to all processes in the foreground process group (\nFigure 9.9\n). This signal is often used to terminate a runaway program, especially when it\u2019s generating a lot of unwanted output on the screen.\n\n\nSIGIO\n: indicates an asynchronous I/O event.\n\n\nSIGIOT\n: indicates an implementation-defined hardware fault. \nSIGABRT\n is now used for this purpose. On FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10, \nSIGIOT\n is defined to be the same value as \nSIGABRT\n.\n\n\nSIGJVM1\n and \nSIGJVM2\n: reserved for use by the Java virtual machine on Solaris.\n\n\nSIGKILL\n: one of the two that can\u2019t be caught or ignored. It provides the system administrator with a sure way to kill any process.\n\n\nSIGLOST\n: used to notify a process running on a Solaris NFSv4 client system that a lock could not be reacquired during recovery.\n\n\nSIGPIPE\n: If we write to a pipeline but the reader has terminated, \nSIGPIPE\n is generated. This signal is also generated when a process writes to a socket of type \nSOCK_STREAM\n that is no longer connected.\n\n\nSIGPOLL\n: This signal is marked obsolescent in SUSv4, so it might be removed in a future version of the standard. It can be generated when a specific event occurs on a pollable device.\n\n\nSIGPROF\n: This signal is marked obsolescent in SUSv4, so it might be removed in a future version of the standard. This signal is generated when a profiling interval timer set by the \nsetitimer(2)\n function expires.\n\n\nSIGPWR\n: system dependent, mainly used on a system that has an uninterruptible power supply (UPS).\n\n\nIf power fails, the UPS takes over and the software can usually be notified. Nothing needs to be done at this point, as the system continues running on battery power. But if the battery gets low, the software is usually notified again; at this point, it behooves the system to shut everything down. The process that is notified of the low-battery condition sends the \nSIGPWR\n signal to the \ninit\n process, and \ninit\n handles the system shutdown.\n\n\nSolaris 10 and some Linux distributions have entries in the \ninittab\n file for this purpose: \npowerfail\n and \npowerwait\n (or \npowerokwait\n).\n\n\nThe default action for \nSIGPWR\n as either \"terminate\" or \"ignore\", which depends on the system. The default on Linux is to terminate the process. On Solaris, the signal is ignored by default.\n\n\n\n\n\n\nSIGQUIT\n: generated by the terminal driver when we press the terminal quit key (often Control-backslash). This signal is sent to all processes in the foreground process group (\nFigure 9.9\n). This signal not only terminates the foreground process group (as does \nSIGINT\n), but also generates a \ncore\n file.\n\n\nSIGSEGV\n: indicates that the process has made an invalid memory reference (which is usually a sign that the program has a bug, such as dereferencing an uninitialized pointer). The name SEGV stands for \"segmentation violation\".\n\n\nSIGSTKFLT\n: This signal is defined only by Linux. It showed up in the earliest versions of Linux, where it was intended to be used for stack faults taken by the math coprocessor. This signal is not generated by the kernel, but remains for backward compatibility.\n\n\nSIGSTOP\n: This job-control signal stops a process. It is similar to the interactive stop signal (\nSIGTSTP\n), but \nSIGSTOP\n cannot be caught or ignored.\n\n\nSIGSYS\n: indicates an invalid system call. The process executed a machine instruction that the kernel thought was a system call, but the parameter with the instruction that indicates the type of system call was invalid. For example, if you build a program that uses a new system call and you then try to run the same binary on an older version of the operating system where the system call doesn\u2019t exist. [p320]\n\n\nSIGTERM\n: the termination signal sent by the \nkill(1)\n command by default. Because it can be caught by applications, using \nSIGTERM\n gives programs a chance to terminate gracefully by cleaning up before exiting (in contrast to \nSIGKILL\n, which can\u2019t be caught or ignored).\n\n\nSIGTHAW\n: defined only by Solaris and used to notify processes that need to take special action when the system resumes operation after being suspended.\n\n\nSIGTHR\n: reserved for use by the thread library on FreeBSD. It is defined to have the same value as \nSIGLWP\n.\n\n\nSIGTRAP\n: indicates an implementation-defined hardware fault. The signal name comes from the PDP-11 TRAP instruction. Implementations often use this signal to transfer control to a debugger when a breakpoint instruction is executed.\n\n\nSIGTSTP\n: This interactive stop signal is generated by the terminal driver when we press the terminal suspend key (often Control-Z). This signal is sent to all processes in the foreground process group (\nFigure 9.9\n). [p321]\n\n\nSIGTTIN\n: generated by the terminal driver when a process in a background process group tries to read from its controlling terminal. If either of the following case occurs, the signal is not generated; instead, the read operation fails with errno set to \nEIO\n:\n\n\nThe reading process is ignoring or blocking this signal.\n\n\nThe process group of the reading process is orphaned.\n\n\n\n\n\n\n\n\nSIGTTOU\n: generated by the terminal driver when a process in a background process group tries to write to its controlling terminal. Unlike the case with background reads, a process can choose to allow background writes to the controlling terminal. If background writes are not allowed, then like the \nSIGTTIN\n signal, the signal is not generated if either of the following cases occurs; instead, the read operation fails with errno set to \nEIO\n:\n\n\n\n\nThe writing process is ignoring or blocking this signal\n\n\nThe process group of the writing process is orphaned\n\n\n\n\nRegardless of whether background writes are allowed, certain terminal operations (other than writing), including \ntcsetattr\n, \ntcsendbreak\n, \ntcdrain\n, \ntcflush\n, \ntcflow\n, and \ntcsetpgrp\n can also generate the \nSIGTTOU\n signal.\n\n\n\n\n\n\nSIGURG\n: notifies the process that an urgent condition has occurred. It is optionally generated when \nout-of-band data\n is received on a network connection.\n\n\n\n\nSIGUSR1\n and \nSIGUSR2\n: user-defined signals, for use in application programs.\n\n\nSIGVTALRM\n: generated when a virtual interval timer set by the \nsetitimer(2)\n function expires.\n\n\nSIGWAITING\n: used internally by the Solaris threads library, and is not available for general use.\n\n\nSIGWINCH\n: The kernel maintains the size of the window associated with each terminal and pseudo terminal. A process can get and set the window size with the \nioctl\n function. If a process changes the window size from its previous value using the \nioctl\n set-window-size command, the kernel generates the \nSIGWINCH\n signal for the foreground process group.\n\n\nSIGXCPU\n: generated if the process exceeds its soft CPU time limit. The default action depends on the operating system. The Single UNIX Specification requires that the default action be to terminate the process abnormally.\n\n\nLinux 3.2.0 and Solaris 10 support a default action of terminate with a core file\n\n\nFreeBSD 8.0 and Mac OS X 10.6.8 support a default action of terminate without generating a core file.\n\n\n\n\n\n\nSIGXFSZ\n:  generated if the process exceeds its soft file size limit. The default action depends on the operating system, similar to \nSIGXCPU\n.\n\n\nSIGXRES\n: defined only by Solaris.\n\n\n\n\nsignal\n Function\n\n\nThe simplest interface to the signal features of the UNIX System is the signal function\n\n\n\n\napue_signal.h\n\n\n\n\n\n\n\nImplementations derived from UNIX System V support the \nsignal\n function, which provides the old unreliable-signal semantics. New applications should not use these unreliable signals. 4.4BSD also provides the \nsignal\n function, but it is defined in terms of the \nsigaction\n function, so using it under 4.4BSD provides the newer reliable-signal semantics. Most current systems follow this strategy except Solaris. [p323]\n\n\nBecause the semantics of signal differ among implementations, we must use the \nsigaction\n function instead. We provide an implementation of \nsignal\n that uses \nsigaction\n (later this chapter).\n\n\nArguments:\n\n\n\n\nThe \nsigno\n argument is the name of the signal from \nprevious table\n.\n\n\nThe value of \nfunc\n one of the following:\n\n\nthe constant \nSIG_IGN\n, which tells the system ignore the signal;\n\n\nthe constant \nSIG_DFL\n, which sets the action associated with the signal to its default value;\n\n\nthe address of a function to be called when the signal occurs, which arranges to \"catch\" the signal. This function is called either the \nsignal handler\n or the \nsignal-catching function\n.\n\n\n\n\n\n\n\n\nThe prototype for the \nsignal\n function states that the function requires two arguments and returns a pointer to a function that returns nothing (\nvoid\n):\n\n\n\n\nThe first argument, \nsigno\n, is an integer.\n\n\nThe second argument, \nfunc\n, is a pointer to a function that takes a single integer argument and returns nothing.\n\n\nThe returned function (function whose address is returned as the value of \nsignal\n) takes a single integer argument (the final (\nint\n)).\n\n\n\n\nIn plain English, this declaration says that the signal handler is passed a single integer argument (the signal number) and that it returns nothing. When we call signal to establish the signal handler, the second argument is a pointer to the function.  The return value from \nsignal\n is the pointer to the previous signal handler.\n\n\nThe \nsignal\n function prototype can be made much simpler through the use of the following \ntypedef\n:\n\n\ntypedef\n \nvoid\n \nSigfunc\n(\nint\n);\n\n\n\n\n\n\nThen the prototype becomes:\n\n\nSigfunc\n \n*\nsignal\n(\nint\n,\n \nSigfunc\n \n*\n);\n\n\n\n\n\n\nThis \ntypedef\n is included in \napue.h\n and is used with the functions in this chapter.\n\n\nIf we examine the system\u2019s header \nsignal.h\n, we will probably find declarations of the form:\n\n\n#define SIG_ERR (void (*)())-1\n\n\n#define SIG_DFL (void (*)())0\n\n\n#define SIG_IGN (void (*)())1\n\n\n\n\n\n\nThese constants can be used in place of the \"pointer to a function that takes an integer argument and returns nothing\", the second argument to \nsignal\n, and the return value from \nsignal\n. The three values used for these constants need not be \u22121, 0, and 1. They must be three values that can never be the address of any declarable function. Most UNIX systems use the values shown. (See \nDoubts and Solutions\n for details)\n\n\nExample:\n\n\nThe following code shows a simple signal handler that catches either of the two user-defined signals and prints the signal number.\n\n\n\n\nsigusr.c\n\n\n\n\n#include \napue.h\n\n\n\nstatic\n \nvoid\n \nsig_usr\n(\nint\n);\n   \n/* one handler for both signals */\n\n\n\nint\n\n\nmain\n(\nvoid\n)\n\n\n{\n\n    \nif\n \n(\nsignal\n(\nSIGUSR1\n,\n \nsig_usr\n)\n \n==\n \nSIG_ERR\n)\n\n        \nerr_sys\n(\ncan\nt catch SIGUSR1\n);\n\n    \nif\n \n(\nsignal\n(\nSIGUSR2\n,\n \nsig_usr\n)\n \n==\n \nSIG_ERR\n)\n\n        \nerr_sys\n(\ncan\nt catch SIGUSR2\n);\n\n    \nfor\n \n(\n \n;\n \n;\n \n)\n\n        \npause\n();\n\n\n}\n\n\n\nstatic\n \nvoid\n\n\nsig_usr\n(\nint\n \nsigno\n)\n      \n/* argument is signal number */\n\n\n{\n\n    \nif\n \n(\nsigno\n \n==\n \nSIGUSR1\n)\n\n        \nprintf\n(\nreceived SIGUSR1\n\\n\n);\n\n    \nelse\n \nif\n \n(\nsigno\n \n==\n \nSIGUSR2\n)\n\n        \nprintf\n(\nreceived SIGUSR2\n\\n\n);\n\n    \nelse\n\n        \nerr_dump\n(\nreceived signal %d\n\\n\n,\n \nsigno\n);\n\n\n}\n\n\n\n\n\n\nWe invoke the program in the background and use the \nkill(1)\n command to send it signals. The term \nkill\n in the UNIX System is a misnomer. The \nkill(1)\n command and the \nkill(2)\n function just send a signal to a process or process group. Whether that signal terminates the process depends on which signal is sent and whether the process has arranged to catch the signal.\n\n\nResult:\n\n\n$ ./a.out \n                # start process in background\n\n\n[1] 7216                   # job-control shell prints job number and process ID\n\n\n$ kill -USR1 7216          # send it SIGUSR1\n\n\nreceived SIGUSR1\n\n\n$ kill -USR2 7216          # send it SIGUSR2\n\n\nreceived SIGUSR2\n\n\n$ kill 7216                # now send it SIGTERM\n\n\n[1]+ Terminated ./a.out\n\n\n\n\n\n\nWhen we send the \nSIGTERM\n signal, the process is terminated, since it doesn\u2019t catch the signal, and the default action for the signal is termination.\n\n\nProgram Start-Up\n\n\nWhen a program is executed, the status of all signals is either default or ignore. All signals are set to their default action, unless the process that calls \nexec\n is ignoring the signal. The \nexec\n functions change the disposition of any signals being caught to their default action and leave the status of all other signals alone. The reason is that a signal that is being caught by a process that calls \nexec\n cannot be caught by the same function in the new program, since the address of the signal-catching function in the caller probably has no meaning in the new program file that is executed. [p325]\n\n\nWith a shell that doesn\u2019t support job control, when we execute a process in the background:\n\n\ncc main.c \n\n\n\n\n\n\nThe shell automatically sets the disposition of the interrupt and quit signals in the background process to be ignored. This is done so that if we type the interrupt character, it doesn\u2019t affect the background process. If this weren\u2019t done and we typed the interrupt character, it would terminate not only the foreground process, but also all the background processes.\n\n\nMany interactive programs that catch these two signals have code that looks like:\n\n\nvoid\n \nsig_int\n(\nint\n),\n \nsig_quit\n(\nint\n);\n\n\n\nif\n \n(\nsignal\n(\nSIGINT\n,\n \nSIG_IGN\n)\n \n!=\n \nSIG_IGN\n)\n\n    \nsignal\n(\nSIGINT\n,\n \nsig_int\n);\n\n\nif\n \n(\nsignal\n(\nSIGQUIT\n,\n \nSIG_IGN\n)\n \n!=\n \nSIG_IGN\n)\n\n    \nsignal\n(\nSIGQUIT\n,\n \nsig_quit\n);\n\n\n\n\n\n\nFollowing this approach, the process catches the signal only if the signal is not currently being ignored.\n\n\nThe \nsignal\n function has a limitation: we are not able to determine the current disposition of a signal without changing the disposition. The \nsigaction\n function (discussed later in this chapter) allows us to determine a signal\u2019s disposition without changing it.\n\n\nProcess Creation\n\n\nWhen a process calls \nfork\n, the child inherits the parent\u2019s signal dispositions. Here, since the child starts off with a copy of the parent\u2019s memory image, the address of a signal-catching function has meaning in the child.\n\n\nUnreliable Signals\n\n\nIn earlier versions of the UNIX System, signals were unreliable, which means that signals could get lost: a signal could occur and the process would never know about it. [p326]\n\n\nOne problem with these early versions was that the action for a signal was reset to its default each time the signal occurred. The code that was described usually looked like:\n\n\n    \nint\n \nsig_int\n();\n \n/* my signal handling function */\n\n    \n...\n\n    \nsignal\n(\nSIGINT\n,\n \nsig_int\n);\n \n/* establish handler */\n\n    \n...\n\n\n\nsig_int\n()\n\n\n{\n\n    \nsignal\n(\nSIGINT\n,\n \nsig_int\n);\n \n/* reestablish handler for next time */\n\n    \n...\n \n/* process the signal ... */\n \n.\n\n\n}\n\n\n\n\n\n\nThe problem with this code fragment is that there is a window of time (after the signal has occurred, but before the call to \nsignal\n in the signal handler) when the interrupt signal could occur another time. This second signal would cause the default action to occur, which terminates the process. This is one of those conditions that works correctly most of the time, causing us to think that it is correct, when it isn\u2019t.\n\n\nAnother problem with these earlier systems was that the process was unable to turn a signal off when it didn\u2019t want the signal to occur. All the process could do was ignore the signal. There are times when we would like to tell the system \"prevent the following signals from interrupting me, but remember if they do occur\". The following code catches a signal and sets a flag for the process that indicates that the signal occurred:\n\n\nint\n \nsig_int\n();\n \n/* my signal handling function */\n\n\nint\n \nsig_int_flag\n;\n \n/* set nonzero when signal occurs */\n\n\n\nmain\n()\n\n\n{\n\n    \nsignal\n(\nSIGINT\n,\n \nsig_int\n);\n \n/* establish handler */\n\n    \n...\n\n    \nwhile\n \n(\nsig_int_flag\n \n==\n \n0\n)\n\n        \npause\n();\n \n/* go to sleep, waiting for signal */\n\n    \n...\n\n\n}\n\n\n\nsig_int\n()\n\n\n{\n\n    \nsignal\n(\nSIGINT\n,\n \nsig_int\n);\n \n/* reestablish handler for next time */\n\n    \nsig_int_flag\n \n=\n \n1\n;\n \n/* set flag for main loop to examine */\n\n\n}\n\n\n\n\n\n\nThe process is calling the \npause\n function to put it to sleep until a signal is caught. When the signal is caught, the signal handler just sets the flag \nsig_int_flag\n to a nonzero value. The process is automatically awakened by the kernel after the signal handler returns, notices that the flag is nonzero, and does whatever it needs to do. But there is a window of time when things can go wrong. If the signal occurs after the test of \nsig_int_flag\n but before the call to pause, the process could go to sleep forever (assuming that the signal is never generated again). This occurrence of the signal is lost.\n\n\nInterrupted System Calls\n\n\nIn earlier UNIX systems, if a process caught a signal while the process was blocked in a \"slow\" system call, the system call was interrupted. The system call returned an error and \nerrno\n was set to \nEINTR\n. This was done under the assumption that since a signal occurred and the process caught it, there is a good chance that something has happened that should wake up the blocked system call.\n\n\nSlow system calls\n\n\nThe system calls are divided into two categories: the \"slow\" system calls and all the others. The slow system calls are those that can block forever:\n\n\n\n\nReads that can block the caller forever if data isn\u2019t present with certain file types (pipes, terminal devices, and network devices)\n\n\nWrites that can block the caller forever if the data can\u2019t be accepted immediately by these same file types\n\n\nOpens on certain file types that block the caller until some condition occurs (such as a terminal device open waiting until an attached modem answers the phone)\n\n\nThe \npause\n function (which by definition puts the calling process to sleep until a signal is caught) and the \nwait\n function\n\n\nCertain \nioctl\n operations\n\n\nSome of the interprocess communication functions\n\n\n\n\nThe notable exception to these slow system calls is anything related to disk I/O. Although a read or a write of a disk file can block the caller temporarily (while the disk driver queues the request and then the request is executed), unless a hardware error occurs, the I/O operation always returns and unblocks the caller quickly.\n\n\nHistorically, POSIX.1 semantics gave implementations a choice of how to deal with \nread\ns and \nwrite\ns that have processed partial amounts of data, implementations derived from System V fail the system call, whereas BSD-derived implementations return partial success. With the 2001 version of the POSIX.1 standard, the BSD-style semantics are required. [p328]\n\n\nThe problem with interrupted system calls is that we now have to handle the error return explicitly. assuming a read operation and assuming that we want to restart the read even if it\u2019s interrupted, the typical code sequence would be:\n\n\nagain\n:\n\n    \nif\n \n((\nn\n \n=\n \nread\n(\nfd\n,\n \nbuf\n,\n \nBUFFSIZE\n))\n \n \n0\n)\n \n{\n\n        \nif\n \n(\nerrno\n \n==\n \nEINTR\n)\n\n            \ngoto\n \nagain\n;\n \n/* just an interrupted system call */\n\n        \n/* handle other errors */\n\n    \n}\n\n\n\n\n\n\nAutomatic restarts of interrupted system calls\n\n\nAutomatic restarting of certain interrupted system calls were introducted since 4.2BSD to prevent applications from having to handle interrupted system calls. The system calls that were automatically restarted are:\n\n\n\n\nFunctions that are interrupted by a signal only if they are operating on a slow device:\n\n\nioctl\n\n\nread\n\n\nreadv\n\n\nwrite\n\n\nwritev\n\n\n\n\n\n\nFunctions that are always interrupted when a signal is caught.\n\n\nwait\n\n\nwaitpid\n\n\n\n\n\n\n\n\nSome applications didn\u2019t want the operation restarted if it was interrupted; 4.3BSD allowed the process to disable this feature on a per-signal basis.\n\n\nDifference between the \nsignal\n and \nsigaction\n functions on restarts\n\n\nPOSIX.1 requires an implementation to restart system calls only when the \nSA_RESTART\n flag is in effect for the interrupting signal. This flag is used with the \nsigaction\n function to allow applications to request that interrupted system calls be restarted.\n\n\nHistorically, when using the \nsignal\n function to establish a signal handler, implementations varied with respect to how interrupted system calls were handled. System V never restarted system calls by default. BSD, in contrast, restarted them if the calls were interrupted by signals. On FreeBSD 8.0, Linux 3.2.0, and Mac OS X 10.6.8, when signal handlers are installed with the \nsignal\n function, interrupted system calls will be restarted. By using our own implementation of the \nsignal\n function, we avoid having to deal with these differences. [p329]\n\n\nOne reason 4.2BSD introduced the automatic restart feature is that sometimes we don\u2019t know that the input or output device is a slow device. [p329]\n\n\nThe figure below summarizes the signal functions and their semantics provided by the various implementations.\n\n\n\n\nLater this chapter, we provide our own version of the \nsignal\n function that automatically tries to restart interrupted system calls (other than for the \nSIGALRM\n signal), and \nsignal_intr\n, that tries to never do the restart.\n\n\nReentrant Functions\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\n[p324] on some macro constants in \nsignal.h\n:\n\n\n\n\nThese constants can be used in place of the \"pointer to a function that takes an integer argument and returns nothing\", the second argument to \nsignal\n, and the return value from \nsignal\n. The three values used for these constants need not be \u22121, 0, and 1. They must be three values that can never be the address of any declarable function. Most UNIX systems use the values shown.\n\n\n\n\nWhy is the macro in the form \nSIG_ERR (void (*)())-1\n and the like?\n\n\nSolution:\n\n\nThey are integer that cast into an address which means the \"pointer to a function that takes an integer argument and returns nothing\". \nvoid (*)()\n tells the compiler to ignore type-checking for the parameters. See:\n\n\n\n\nStack Overflow", 
            "title": "Chapter 10. Signals"
        }, 
        {
            "location": "/utlk/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nThis chapter gives an overview of major features of Linux, as well as Unix kernels. This book is based on \nLinux 2.6.11\n source code.\n\n\nLinux Versus Other Unix-Like Kernels\n\n\nSeveral differences between Linux and Unix implementations:\n\n\n\n\nKernel threading\n\n\nPreemptive kernel: Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode\n\n\nMultiprocessor support: Linux 2.6 supports symmetric multiprocessing (SMP)\n\n\nSTREAMS\n is not included in Linux\n\n\n\n\nThe Process/Kernel Model\n\n\n\n\nUsers processes\n\n\nKernel threads:\n\n\nrun in Kernel Mode;\n\n\nare non-interactive;\n\n\ncreated during system startup\n\n\n\n\n\n\nKernel routines can be activated in: \n\n\nsystem call;\n\n\nexception signaled by a process; \n\n\ninterrupt by a peripheral device;\n\n\nkernel thread executed\n\n\n\n\n\n\n\n\nProcess Implementation\n\n\nProcess descriptor\n contains registers:\n\n\n\n\nProgram counter (PC) registers\n\n\nStack pointer (SP) registers\n\n\nGeneral purpose registers\n\n\nFloating point registers\n\n\nProcessor control registers\n\n\nMemory management registers\n\n\n\n\nReentrant Kernels\n\n\nA \nkernel control\n path denotes the sequence of instructions executed by the kernel to handle a system call, an exception, or an interrupt.\n\n\nProcess Address Space\n\n\nSynchronization and Critical Regions\n\n\nSignals and Interprocess Communication\n\n\n\n\nUnix signals\n\n\nSystem V IPC: semaphores, message queues, and shared memory\n\n\n\n\nProcess Management\n\n\n\n\nfork()\n, \n_exit()\n, and \nexec()\n-like system calls\n\n\nwait4()\n\n\nProcess groups and login sessions\n\n\n\n\nMemory Management\n\n\n\n\nVirtual memory acts as a logical layer between the application memory requests and the hardware Memory Management Unit (MMU).\n\n\nKernel Memory Allocator: Linux\u2019s KMA uses a Slab allocator on top of a buddy system.\n\n\nProcess virtual address space\n\n\n\n\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nChatper 1 on Linux Versus Other Unix-Like Kernels [p3]:\n\n\n\n\nLinux uses kernel threads in a very limited way to execute a few kernel functions periodically; however, they do not represent the basic execution context abstraction. \n\n\n\n\nSummary\n\n\nKernel Architecture\n\n\n\n\nThe Linux kernel, as with most Unix kernels, is \nmonolithic\n: each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process. [p11]", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/utlk/ch2/", 
            "text": "Chapter 2. Memory Addressing\n\n\nThis chapter offers details in \nx86\n microprocessors address memory chips and how Linux uses the available addressing circuits.\n\n\nMemory Addresses\n\n\n\n\nLogical address\n\n\nLinear address\n (also known as \nvirtual address\n)\n\n\nPhysical address\n\n\n\n\nMemory Management Unit (MMU) transforms a logical address into a linear address, and the linear address into a physical address.\n\n\n\n\nMemory arbiter: read or write operations on a RAM chip must be performed serially.\n\n\nSegmentation in Hardware\n\n\nThe following sections focus on address translation when \nprotected mode\n is enabled, in Intel microprocessors starting with the 80286 model.\n\n\nSegment Selectors\n\n\nA logical address consists of:\n\n\n\n\nSegment Selector\n (segment identifier): 16-bit\n\n\nOffset: 32-bit\n\n\n\n\nSegmentation registers\n\n\nSegmentation Registers\n hold Segment Selectors.\n\n\n\n\ncs\n: code segment (program instructions); 2-bit field for CPU's Current Privilege Level (CPL), Linux uses only levels 0 and 3 for Kernel Mode and User Mode\n\n\nss\n: stack segment (current program stack)\n\n\nds\n: data segment (global and static data)\n\n\nes\n, \nfs\n, and \ngs\n: general purpose (arbitrary data)\n\n\n\n\nSegment Descriptors\n\n\nEach segment is represented by an 8-byte \nSegment Descriptor\n that describes the segment characteristics. Segment Descriptors are stored either in the \nGlobal Descriptor Table\n (GDT) or in the \nLocal Descriptor Table\n (LDT). The address and size of GDT and LDT are contained in \ngdtr\n and \nldtr\n control registers respectively.\n\n\n\n\nCode Segment Descriptor: included in GDT or LDT\n\n\nData Segment Descriptor: included in GDT or LDT\n\n\nTask State Segment Descriptor (TSSD): refers to a Task State Segment (TSS), a segment used to save the contents of the processor registers; included in GDT only\n\n\nLocal Descriptor Table Descriptor (LDTD): refers to a segment containing an LDT; included in GDT only\n\n\n\n\nFast Access to Segment Descriptors\n\n\nSegmentation registers store only the Segment Selector. The x86 process provides an additional nonprogrammable register for each of the six programmable segmentation registers to speed up the translation of logical addresses into linear addresses. Each nonprogrammable register contains the 8-byte Segment Descriptor.\n\n\nSegment Selector fields [p40]:\n\n\n\n\nindex\n: identifies the Segment Descriptor entry contained in GDT or LDT\n\n\nTI\n (Table Indicator): specifies whether the Segment Descriptor is included in the GDT (\nTI\n = 0) or in the LDT (\nTI\n = 1).\n\n\nRPL\n (Requestor Privilege Level):  specifies the \nCurrent Privilege Level\n (CPL) of the CPU when the corresponding Segment Selector is loaded into the \ncs\n register\n\n\n\n\nSegmentation Unit\n\n\nThe \nsegmentation unit\n performs the following operations to obtain the linear address:\n\n\n\n\n\n\nExamines the \nTI\n field of the Segment Selector to determine which Descriptor Table (GDT or LDT) stores the Segment Descriptor\n\n\nComputes the address of the Segment Descriptor from the \nindex\n field of the Segment Selector\n\n\nAdds the offset of the logical address to the \nBase\n field of the Segment Descriptor\n\n\n\n\nSegmentation in Linux\n\n\nAll Linux processes running in User Mode use the same pair of segments to address instructions and data. This is similar to processes running in Kernel Mode.\n\n\n\n\nuser code segment\n\n\nuser data segment\n\n\nkernel code segment\n\n\nkernel data segment\n\n\n\n\nSegment Selectors are defined by the macros:\n\n\n\n\n__USER_CS\n\n\n__USER_DS\n\n\n__KERNEL_CS\n\n\n__KERNEL_DS\n\n\n\n\nTo address the kernel code segment, for instance, the kernel just loads the value yielded by the \n__KERNEL_CS\n macro into the \ncs\n segmentation register.\n\n\nThe linear addresses associated with such segments all start at 0 and reach the addressing limit of 2\n32\n \u20131. This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses.\n\n\nCPL\n, \nRPL\n and registers\n\n\nThe Current Privilege Level (CPL) of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the \nRPL\n field of the Segment Selector stored in the \ncs\n register. [p42]\n\n\nWhenever the CPL is changed, some segmentation registers (e.g. \nds\n, \nss\n) must be correspondingly updated. [p42-43]\n\n\nImplicit Segment Selector\n\n\nOnly Offset component of its logical address is specified:\n\n\n\n\nss\n: kernel saves a pointer to an instruction or to a data structure\n\n\ncs\n: kernel invokes a function\n\n\nds\n: kernel data structure\n\n\nes\n: user data structure\n\n\n\n\nThe Linux GDT\n\n\nIn multiprocessor systems there is one GDT for every CPU [p43].\n\n\n\n\ncpu_gdt_table\n array: stores GDTs\n\n\ncpu_gdt_descr\n array: addresses and sizes of the GDTs\n\n\n\n\nEach GDT includes 18 segment descriptors and 14 null, unused, or reserved entries. Unused entries are inserted on purpose so that Segment Descriptors usually accessed together are kept in the same 32-byte line of the hardware cache.\n\n\n\n\nFour user and kernel code and data segments\n\n\nTask State Segment (TSS)\n\n\nDefault Local Descriptor Table(LDT), usually shared by all processes\n\n\nThree Thread-Local Storage (TLS) segments: allows multithreaded applications to make use of up to three segments containing data local to each thread. The \nset_thread_area()\n and \nget_thread_area()\n system calls, respectively, create and release a TLS segment for the executing process.\n\n\nThree segments related to Advanced Power Management (APM)\n\n\nFive segments related to Plug and Play (PnP) BIOS services\n\n\nA special TSS segment used by the kernel to handle \"Double fault\" exceptions\n\n\n\n\nThe Linux LDT\n\n\nMost Linux User Mode applications do not make use of a Local Descriptor Table. The kernel defines a default LDT to be shared by most processes. It has five entries but only two are used by the kernel: a \ncall gate\n for \niBCS\n executables, and a call gate for Solaris/x86 executables.\n\n\nIn some cases, processes may require to set up their own LDT, such as applications (such as Wine) that execute segment-oriented Microsoft Windows applications. The \nmodify_ldt()\n system call allows a process to do this.\n\n\nPaging in Hardware\n\n\nThe paging unit translates linear addresses into physical ones. Its key task is to check the requested access type against the access rights of the linear address, and generates a Page Fault exception if memory access is not valid.\n\n\n\n\nPages\n: grouped fixed-length intervals of linear addresses; contiguous linear addresses within a page are mapped into contiguous physical addresses. The term \"page\" to refer both to a set of linear addresses and to the data contained in this group of addresses.\n\n\nPage frames\n (or \nphysical pages\n): RAM partitions from the perspective of the paging unit. Each page frame (storage area) contains a page (block of data), thus the length of a page frame coincides with that of a page.\n\n\nPage table\n: data structures (in main memory) that map linear to physical addresses\n\n\n\n\nRegular Paging\n\n\nThe x86 processors support paging; it is enabled by setting the \nPG\n flag of a control register named \ncr0\n.\n\n\n\n\nDoubts and Solutions\n\n\nSegmentation in Linux [p41]\n\n\n\n\nHowever, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons:", 
            "title": "Chapter 2. Memory Addressing"
        }, 
        {
            "location": "/lkd/ch1/", 
            "text": "Chapter 1. Introduction to the Linux Kernel\n\n\nOverview of Operating Systems and Kernels\n\n\nIn Linux, we can generalize that each processor is doing exactly one of three things at any given moment:\n\n\n\n\nIn user-space, executing user code in a process\n\n\nIn kernel-space, in process context, executing on behalf of a specific process\n\n\nIn kernel-space, in interrupt context, not associated with a process, handling an interrupt\n\n\n\n\nLinux Versus Classic Unix Kernels\n\n\nNotable differences exist between the Linux kernel and classic Unix systems:\n\n\n\n\nLinux supports the dynamic loading of kernel modules.Although the Linux kernel is monolithic, it can dynamically load and unload kernel code on demand.\n\n\nLinux has symmetrical multiprocessor (SMP) support.\n\n\nThe Linux kernel is preemptive.\n\n\nLinux takes an interesting approach to thread support: It does not differentiate between threads and normal processes.To the kernel, all processes are the same (some just happen to share resources).\n\n\nLinux provides an object-oriented device model with device classes, hot-pluggable events, and a user-space device filesystem (sysfs).\n\n\nLinux ignores some common Unix features that the kernel developers consider poorly designed, such as STREAMS, or standards that are impossible to cleanly implement.\n\n\nLinux is free in every sense of the word\n\n\n\n\nLinux Kernel Versions\n\n\nLinux kernels come in two flavors: stable and development. \n\n\n\n\nThe Linux Kernel Development Community\n\n\nThe main forum for this community is the Linux Kernel Mailing List (oft-shortened to \nlkml\n). Subscription information is available at \nhttp://vger.kernel.org\n.", 
            "title": "Chapter 1. Introduction to the Linux Kernel"
        }, 
        {
            "location": "/lkd/ch2/", 
            "text": "Chapter 2. Getting Started with the Kernel\n\n\nObtaining the Kernel Source\n\n\nUsing Git\n\n\n$ \ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git\n\n\n\n\n\nInstalling the Kernel Source\n\n\n$ \ntar xvjf linux-x.y.z.tar.bz2\n\n\n\n\n\nUsing Patches\n\n\nThroughout the Linux kernel community, patches are the \nlingua franca\n of communication. You will distribute your code changes in patches and receive code from others as patches. Incremental patches provide an easy way to move from one kernel tree to the next\n\n\n$ \npatch \u2013p1 \n ../patch-x.y.z\n\n\n\n\n\nThe Kernel Source Tree\n\n\n\n\n\n\n\n\nDirectory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narch\n\n\nArchitecture-specific source\n\n\n\n\n\n\nblock\n\n\nBlock I/O layer\n\n\n\n\n\n\ncrypto\n\n\nCrypto API\n\n\n\n\n\n\nDocumentation\n\n\nKernel source documentation\n\n\n\n\n\n\ndrivers\n\n\nDevice drivers\n\n\n\n\n\n\nfirmware\n\n\nDevice firmware needed to use certain drivers\n\n\n\n\n\n\nfs\n\n\nThe VFS and the individual filesystems\n\n\n\n\n\n\ninclude\n\n\nKernel headers\n\n\n\n\n\n\ninit\n\n\nKernel boot and initialization\n\n\n\n\n\n\nipc\n\n\nInterprocess communication code\n\n\n\n\n\n\nkernel\n\n\nCore subsystems, such as the scheduler\n\n\n\n\n\n\nlib\n\n\nHelper routines\n\n\n\n\n\n\nmm\n\n\nMemory management subsystem and the VM\n\n\n\n\n\n\nnet\n\n\nNetworking subsystem\n\n\n\n\n\n\nsamples\n\n\nSample, demonstrative code\n\n\n\n\n\n\nscripts\n\n\nScripts used to build the kernel\n\n\n\n\n\n\nsecurity\n\n\nLinux Security Module\n\n\n\n\n\n\nsound\n\n\nSound subsystem\n\n\n\n\n\n\nusr\n\n\nEarly user-space code (called initramfs)\n\n\n\n\n\n\ntools\n\n\nTools helpful for developing Linux\n\n\n\n\n\n\nvirt\n\n\nVirtualization infrastructure\n\n\n\n\n\n\n\n\nBuilding the Kernel\n\n\nConfiguring the Kernel\n\n\n$ \nmake config  \n# text-based\n\n\n$ \nmake menuconfig  \n# ncurses-based\n\n\n$ \nmake gconfig  \n# gtk+-based\n\n\n\n\n\n\nCreates a configuration based on the defaults for your architecture:\n\n\n$ \nmake defconfig\n\n\n\n\n\nAfter making changes to your configuration file, or when using an existing configuration\nfile on a new kernel tree, you can validate and update the configuration:\n\n\n$ \nmake oldconfig\n\n\n\n\n\nYou should always run this before building a kernel.\n\n\nAfter the kernel configuration is set, you can build it with a single command:\n\n\n$ \nmake\n\n\n\n\n\nSpawning Multiple Build Jobs\n\n\nTo build the kernel with multiple make jobs, use\n\n\n$ \nmake -jn\n\n\n\n\n\nHere, \nn\n is the number of jobs to spawn. \n\n\nInstalling the New Kernel\n\n\nHow it is installed is architecture- and boot loader-dependent.\n\n\nAs an example, on an x86 system using grub, you would copy \narch/i386/boot/bzImage\n to /boot, name it something like vmlinuz-\nversion\n, and edit \n/boot/grub/grub.conf\n, adding a new entry for the new kernel. \n\n\nInstalling modules is automated and architecture-independent. As root, run:\n\n\n% make modules_install\n\n\n\n\n\n\nA Beast of a Different Nature\n\n\n\n\nThe kernel has access to neither the C library nor the standard C headers.\n\n\nThe kernel is coded in GNU C.\n\n\nThe kernel lacks the memory protection afforded to user-space.\n\n\nThe kernel cannot easily execute floating-point operations.\n\n\nThe kernel has a small per-process fixed-size stack.\n\n\nBecause the kernel has asynchronous interrupts, is preemptive, and supports SMP, synchronization and concurrency are major concerns within the kernel.\n\n\nPortability is important.\n\n\n\n\nNo libc or Standard Headers\n\n\nUnlike a user-space application, the kernel is not linked against the standard C library. The primary reason is speed and size. The full C library\u2014or even a decent subset of it; it is too large and too inefficient for the kernel.\n\n\nMany of the usual libc functions are implemented inside the kernel. For example, the common string manipulation functions are in \nlib/string.c\n. Just include the header file \nlinux/string.h\n and have at them.\n\n\nA set of architecture-specific header files are located in \narch/\narchitecture\n/include/asm\n in the kernel source tree. For example, if compiling for the x86 architecture, your architecture-specific headers are in \narch/x86/include/asm\n. Source code includes these headers via just the \nasm/\n prefix, for example \nasm/ioctl.h\n.\n\n\nprintk()\n\n\nOf the missing functions, the most familiar is \nprintf(\n). The kernel does not have access to \nprintf()\n, but it does provide \nprintk()\n, which works pretty much the same as its more familiar cousin. The \nprintk()\n function copies the formatted string into the kernel log buffer, which is normally read by the syslog program. Usage is similar to \nprintf()\n:\n\n\nprintk\n(\nHello world! A string \n%s\n and an integer \n%d\n\\n\n,\n \nstr\n,\n \ni\n);\n\n\n\n\n\n\nOne notable difference is that \nprintk()\n enables you to specify a priority flag.This flag is used by syslogd to decide where to display kernel messages.\n\n\nprintk\n(\nKERN_ERR\n \nthis is an error!\n\\n\n);\n\n\n\n\n\n\nNote there is no comma between \nKERN_ERR\n and the printed message. The priority flag is a preprocessor-define representing a string literal, which is concatenated onto the printed message during compilation.\n\n\nGNU C\n\n\nThe kernel is not programmed in strict ANSI C. The kernel developers make use of various language extensions available in \ngcc\n. They use both ISO C991 and GNU C extensions to the C language. \n\n\nInline Functions\n\n\nBoth C99 and GNU C support \ninline functions\n. An inline function is inserted inline into each function call site. This eliminates the overhead of function invocation and return (register saving and restore) and allows for potentially greater optimization as the compiler can optimize both the caller and the called function as one. Kernel developers use inline functions for small time-critical functions.\n\n\nAn inline function is declared when the keywords \nstatic\n and inline are used as part of the function definition. For example\n\n\nstatic\n \ninline\n \nvoid\n \nwolf\n(\nunsigned\n \nlong\n \ntail_size\n)\n\n\n\n\n\n\nInline Assembly\n\n\nThe gcc C compiler enables the embedding of assembly instructions in otherwise normal C functions.\n\n\nunsigned\n \nint\n \nlow\n,\n \nhigh\n;\n\n\nasm\n \nvolatile\n(\nrdtsc\n \n:\n \n=a\n \n(\nlow\n),\n \n=d\n \n(\nhigh\n));\n\n\n/* low and high now contain the lower and upper 32-bits of the 64-bit tsc */\n\n\n\n\n\n\nBranch Annotation\n\n\nThe gcc C compiler has a built-in directive that optimizes conditional branches as either very likely taken or very unlikely taken. The kernel wraps the directive in easy-to-use macros, \nlikely()\n and \nunlikely()\n. \n\n\nNo Memory Protection\n\n\nWhen a user-space application attempts an illegal memory access, the kernel can trap the error, send the \nSIGSEGV\n signal, and kill the process. If the kernel attempts an illegal memory access, however, the results are less controlled. Memory violations in the kernel result in an \noops\n, which is a major kernel error. \n\n\nNo (Easy) Use of Floating Point\n\n\nWhen using floating-point instructions kernel normally catches a trap and then initiates the transition from integer to floating point mode. Unlike user-space, the kernel does not have the luxury of seamless support for floating point because it cannot easily trap itself. Using a floating point inside the kernel requires manually saving and restoring the floating point registers. Except in the rare cases, no floating-point operations are in the kernel.\n\n\nSmall, Fixed-Size Stack\n\n\nUser-space has a large stack that can dynamically grow. \n\n\nThe kernel stack is neither large nor dynamic; it is small and fixed in size. The exact size of the kernel\u2019s stack varies by architecture. On x86, the stack size is configurable at compile-time and can be either 4KB or 8KB.\n\n\nSynchronization and Concurrency\n\n\nA number of properties of the kernel allow for concurrent access of shared resources and thus require synchronization to prevent races.\n\n\n\n\nLinux is a preemptive multitasking operating system. Processes are scheduled and rescheduled at the whim of the kernel\u2019s process scheduler.The kernel must synchronize between these tasks.\n\n\nLinux supports symmetrical multiprocessing (SMP).Therefore, without proper protection, kernel code executing simultaneously on two or more processors can concurrently access the same resource.\n\n\nInterrupts occur asynchronously with respect to the currently executing code.  Therefore, without proper protection, an interrupt can occur in the midst of accessing a resource, and the interrupt handler can then access the same resource.\n\n\nThe Linux kernel is preemptive. Therefore, without protection, kernel code can be preempted in favor of different code that then accesses the same resource.\n\n\n\n\nTypical solutions to race conditions include spinlocks and semaphores.\n\n\nImportance of Portability\n\n\nLinux is a portable operating system and should remain one. This means that architecture-independent C code must correctly compile and run on a wide range of systems, and that architecturedependent code must be properly segregated in system-specific directories in the kernel source tree.", 
            "title": "Chapter 2. Getting Started with the Kernel"
        }, 
        {
            "location": "/lkd/ch3/", 
            "text": "Chapter 3. Process Management\n\n\nThis chapter introduces the concept of the \nprocess\n. The process management is a crucial part of any operating system kernel, including Linux. \n\n\nThe Process\n\n\nA process is a program (object code stored on some media) in the midst of execution.\n\n\nBesides the executing program code (\ntext section\n in Unix), processes also include a set of resources:\n\n\n\n\nOpen files \n\n\nPending signals\n\n\nInternal kernel data\n\n\nProcessor state\n\n\nMemory address space with one or more memory mappings\n\n\nThread(s) of execution\n\n\nData section containing global variables\n\n\n\n\nThreads of execution\n\n\nThreads of execution, often shortened to \nthreads\n,  are the objects of activity within the process.\n\n\nEach thread includes:\n\n\n\n\nProgram counter\n\n\nProcess stack\n\n\nSet of processor registers\n\n\n\n\nThe kernel schedules individual threads, not processes. \nLinux does not differentiate between threads and processes. To Linux, a thread is just a special kind of process.\n\n\nVirtualized processor and virtual memory\n\n\nOn modern operating systems, processes provide two virtualizations: a \nvirtualized processor\n and \nvirtual memory\n.\n\n\n\n\nThe virtual processor gives the process the illusion that it alone monopolizes the system, despite possibly sharing the processor among hundreds of other processes. See \nChapter 4. Process Scheduling\n.\n\n\nVirtual memory lets the process allocate and manage memory as if it alone owned all the memory in the system. See \nChapter 12. Memory Management\n\n\n\n\nThreads share the virtual memory abstraction\n, whereas each receives its own virtualized processor.\n\n\nLife of a process\n\n\nA process is an active program and related resources:\n\n\n\n\nTwo or more processes can exist that are executing the \nsame\n program.\n\n\nTwo or more processes can exist that share various resources, such as open files or an address space.\n\n\n\n\nfork, exec, exit and wait\n\n\nIn Linux, the \nfork()\n system call creates a new process by duplicating an existing one.\n\n\n\n\nThe process that calls \nfork()\n is the parent, whereas the new process is the child.\n\n\nThe parent resumes execution and the child starts execution at the same place: where the call to \nfork()\n returns.\n\n\nThe \nfork()\n system call \nreturns from the kernel twice: once in the parent process and again in the newborn child.\n\n\n\n\nThe \nexec()\n family of function calls creates a new address space and loads a new program into the newborn child immediately after a fork. In contemporary Linux kernels, \nfork()\n is actually implemented via the \nclone()\n system call\n, which is discussed in a following section.  \n\n\nThe \nexit()\n system call terminates the process and frees all its resources. A parent process can inquire about the status of a terminated child via the \nwait4()\n system call. A process can wait for the termination of a specific process. \nWhen a process exits, it is placed into a special zombie state that represents terminated processes until the parent calls \nwait()\n or \nwaitpid()\n.\n The kernel implements the \nwait4()\n system call. Linux systems, via the C library, typically provide the \nwait()\n, \nwaitpid()\n, \nwait3()\n, and \nwait4()\n functions.\n\n\nProcess Descriptor and the Task Structure\n\n\nAnother name for a process is a \ntask\n. The Linux kernel internally refers to processes as tasks. In this book, the terms are used interchangeably, though \n\"task\" generally refers to a process from the kernel\u2019s point of view.\n\n\nThe kernel stores the list of processes in a circular doubly linked list called the \ntask list\n.\n\n\nA \nprocess descriptor\n of the type \nstruct task_struct\n (defined in \nlinux/sched.h\n) is an element in the task list. It contains all the information about a specific process.\n\n\nThe \ntask_struct\n is a relatively large data structure, at around 1.7 kilobytes on a 32-bit machine. The process descriptor contains the data that describes the executing program: open files, the process\u2019s address space, pending signals, the process\u2019s state, etc. See the figure below.\n\n\n\n\nAllocating the Process Descriptor\n\n\nThe \ntask_struct\n structure is allocated via the \nslab allocator\n to provide object reuse and cache coloring (see \nChapter 12\n). The structure \nstruct thread_info\n lives at the bottom of the stack (for stacks that grow down) and at the top of the stack (for stacks that grow up)\n\n\n\n\nErrata\n: \"struct thread_struct\" should read \"struct thread_info\"\n\n\nThe \nthread_info\n structure is defined on x86 in \nasm/thread_info.h\n (see below code). Each task\u2019s \nthread_info\n structure is allocated at the end of its stack.The task element of the structure is a pointer to the task\u2019s actual \ntask_struct\n:\n\n\n\n\narch/x86/include/asm/thread_info.h\n\n\n\n\nstruct\n \nthread_info\n \n{\n\n    \nstruct\n \ntask_struct\n \n*\ntask\n;\n\n    \nstruct\n \nexec_domain\n \n*\nexec_domain\n;\n\n    \n__u32\n \nflags\n;\n\n    \n__u32\n \nstatus\n;\n\n    \n__u32\n \ncpu\n;\n\n    \nint\n \npreempt_count\n;\n\n    \nmm_segment_t\n \naddr_limit\n;\n\n    \nstruct\n \nrestart_block\n \nrestart_block\n;\n\n    \nvoid\n \n*\nsysenter_return\n;\n\n    \nint\n \nuaccess_err\n;\n\n\n};\n\n\n\n\n\n\nStoring the Process Descriptor\n\n\nThe \nprocess identification\n (PID) is numerical value, represented by the \nopaque type\n \npid_t\n (typically \nint\n), for the system to identify processes. The default maximum value is only 32,768 (that of a \nshort int\n), although the value optionally can be increased as high as four million (this is controlled in \nlinux/threads.h\n). The kernel stores this value as \npid\n inside each process descriptor. [p26]\n\n\nLarge servers may require many more than 32,768 (maximum value) processes. \nThe lower the value, the sooner the values will wrap around, destroying the useful notion that higher values indicate later-run processes than lower values.\n The administrator may increase the maximum value via \n/proc/sys/kernel/pid_max\n.\n\n\nInside the kernel, tasks are typically referenced directly by a pointer to their \ntask_struct\n structure. In fact, most kernel code that deals with processes works directly with \nstruct task_struct\n. Consequently, it is useful to be able to quickly look up the process descriptor of the currently executing task, which is done via the \ncurrent\n macro. This macro must be independently implemented by each architecture:\n\n\n\n\nSome architectures save a pointer to the \ntask_struct\n structure of the currently running process in a register, enabling for efficient access. \n\n\nOther architectures, such as x86 (which has few registers to waste), make use of the fact that struct \nthread_info\n is stored on the kernel stack to calculate the location of \nthread_info\n and subsequently the \ntask_struct\n.\n\n\n\n\nThe \ncurrent_thread_info()\n function\n\n\nOn x86, \ncurrent\n is calculated by masking out the 13 least-significant bits of the stack pointer to obtain the \nthread_info\n structure. This is done by the \ncurrent_thread_info()\n function (\narch/x86/include/asm/thread_info.h#L184\n). The assembly is shown here:\n\n\nmovl\n \n$\n-\n8192\n,\n \n%\neax\n\n\nandl\n \n%\nesp\n,\n \n%\neax\n\n\n\n\n\n\nThis assumes that the stack size is 8KB. When 4KB stacks are enabled, 4096 is used in lieu of 8192.\n\n\ncurrent\n dereferences the task member of \nthread_info\n to return the \ntask_struct\n:\n\n\n\n\ninclude/asm-generic/current.h\n\n\n\n\ncurrent_thread_info\n()\n-\ntask\n;\n\n\n\n\n\n\nProcess State\n\n\nThe \nstate\n field of the process descriptor describes the current condition of the process.\n\n\n\n\nEach process on the system is in exactly one of five different states. This value is represented by one of five flags:\n\n\n\n\nTASK_RUNNING\n: The process is runnable; it is either currently running or on a runqueue waiting to run. This is the only possible state for a process executing in user-space; it can also apply to a process in kernel-space that is actively running.\n\n\nTASK_INTERRUPTIBLE\n: The process is sleeping (blocked), waiting for some condition to exist. The process also awakes prematurely and becomes runnable if it receives a signal.\n\n\nTASK_UNINTERRUPTIBLE\n: This state is identical to \nTASK_INTERRUPTIBLE\n except that it does not wake up and become runnable if it receives a signal. This is used in situations where the process must wait without interruption or when the event is expected to occur quite quickly. Because the task does not respond to signals in this state, \nTASK_UNINTERRUPTIBLE\n is less often used than \nTASK_INTERRUPTIBLE\n.\n\n\n__TASK_TRACED\n: The process is being traced by another process, such as a debugger, via \nptrace\n.\n\n\n__TASK_STOPPED\n: Process execution has stopped; the task is not running nor is it eligible to run. This occurs if the task receives the \nSIGSTOP\n, \nSIGTSTP\n, \nSIGTTIN\n, or \nSIGTTOU\n signal or if it receives any signal while it is being debugged.\n\n\n\n\nManipulating the Current Process State\n\n\nKernel code often needs to change a process\u2019s state. The preferred mechanism is using:\n\n\nset_task_state\n(\ntask\n,\n \nstate\n);\n \n/* set task \u2018task\u2019 to state \u2018state\u2019 */\n\n\n\n\n\n\nThis function sets the given task to the given state. If applicable, it also provides a memory barrier to force ordering on other processors (only needed on SMP systems). Otherwise, it is equivalent to:\n\n\ntask\n-\nstate\n \n=\n \nstate\n;\n\n\n\n\n\n\nThe method \nset_current_state(state)\n is synonymous to \nset_task_state(current, state)\n. See \nlinux/sched.h\n for the implementation of these and related functions.\n\n\n\n\ninclude/linux/sched.h#L226\n\n\n\n\nProcess Context\n\n\nThe program code is read in from an \nexecutable file\n and executed within the program\u2019s address space.\n\n\n\n\nUser-space\n: Normal program execution occurs in user-space.\n\n\nKernel-space\n: When a program executes a system call or triggers an exception, it enters kernel-space. At this point, the kernel is said to be \"executing on behalf of the process\" and is in \nprocess context\n. When in process context, the \ncurrent\n macro is valid.\n\n\nOther than process context there is \ninterrupt context\n (discussed in \nChapter 7\n. In interrupt context, the system is not running on behalf of a process but is executing an interrupt handler. No process is tied to interrupt handlers.\n\n\n\n\n\n\n\n\nUpon exiting the kernel, the process resumes execution in user-space, unless a higher-priority process has become runnable in the interim, in which case the scheduler is invoked to select the higher priority process.\n\n\nA process can begin executing in kernel-space only through one of the following well-defined interfaces:\n\n\n\n\nSystem calls\n\n\nException handlers\n\n\n\n\nThe Process Family Tree\n\n\nAll processes are descendants of the \ninit\n process (PID 1). The kernel starts init in the last step of the boot process. The init process reads the system \ninitscripts\n and executes more programs, eventually completing the boot process.\n\n\n\n\nEvery process on the system has exactly one \nparent\n.\n\n\nEvery process has zero or more \nchildren\n.\n\n\nProcesses that are all direct children of the same parent are called \nsiblings\n.\n\n\n\n\n\n\n[UTLK p87-88]\n\n\nThe pointers (\nnext\n and \nprev\n) in a \nlist_head\n field store the addresses of other \nlist_head\n fields rather than the addresses of the whole data structures in which the \nlist_head\n structure is included. See figure below: \n\n\n\n\n\n\ninclude/linux/list.h\n\n\n\n\n\n\nThe relationship between processes is stored in the process descriptor.\n\n\nEach \ntask_struct\n (\ninclude/linux/sched.h#L1170\n) has:\n\n\n\n\nparent\n: pointer to the parent's \ntask_struct\n\n\nchildren\n: list of children (\nstruct list_head\n)\n\n\n\n\nTo obtain the process descriptor of a given process's parent:\n\n\nstruct\n \ntask_struct\n \n*\nmy_parent\n \n=\n \ncurrent\n-\nparent\n;\n\n\n\n\n\n\nTo iterate over a process\u2019s children:\n\n\nstruct\n \ntask_struct\n \n*\ntask\n;\n\n\nstruct\n \nlist_head\n \n*\nlist\n;\n\n\n\nlist_for_each\n(\nlist\n,\n \ncurrent\n-\nchildren\n)\n \n{\n\n    \ntask\n \n=\n \nlist_entry\n(\nlist\n,\n \nstruct\n \ntask_struct\n,\n \nsibling\n);\n\n    \n/* task now points to one of current\u2019s children */\n\n\n}\n\n\n\n\n\n\n\n\nlist_for_each\n: \ninclude/linux/list.h#L367\n\n\n\n\nThe \ninit\n task\u2019s process descriptor is statically allocated as \ninit_task\n. The following code will always succeed:\n\n\nstruct\n \ntask_struct\n \n*\ntask\n;\n\n\n\nfor\n \n(\ntask\n \n=\n \ncurrent\n;\n \ntask\n \n!=\n \ninit_task\n;\n \ntask\n \n=\n \ntask\n-\nparent\n)\n\n\n;\n\n\n/* task now points to init */\n\n\n\n\n\n\nYou can follow the process hierarchy from any one process in the system to any other.  Oftentimes, it is desirable simply to iterate over all processes in the system. This is easy because the task list is a circular, doubly linked list.\n\n\nTo obtain the next task in the list, given any valid task, use:\n\n\nlist_entry\n(\ntask\n-\ntasks\n.\nnext\n,\n \nstruct\n \ntask_struct\n,\n \ntasks\n)\n\n\n\n\n\n\nTo obtain the previous task works the same way:\n\n\nlist_entry\n(\ntask\n-\ntasks\n.\nprev\n,\n \nstruct\n \ntask_struct\n,\n \ntasks\n)\n\n\n\n\n\n\n\n\nlist_entry\n: \ninclude/linux/list.h\n\n\n\n\nThese two routines are provided by the macros \nnext_task(task)\n and \nprev_task(task)\n. (See \nDoubts and Solutions\n)\n\n\nThe macro \nfor_each_process(task)\n iterates over the entire task list. On each iteration, task points to the next task in the list:\n\n\nstruct\n \ntask_struct\n \n*\ntask\n;\n\n\n\nfor_each_process\n(\ntask\n)\n \n{\n\n    \n/* this pointlessly prints the name and PID of each task */\n\n    \nprintk\n(\n\u201c\n%\ns\n[\n%\nd\n]\n\\\nn\n\u201d\n,\n \ntask\n-\ncomm\n,\n \ntask\n-\npid\n);\n\n\n}\n\n\n\n\n\n\n\n\nfor_each_process\n: \ninclude/linux/sched.h#L2139\n\n\n\n\nIt is expensive to iterate over every task in a system with many processes; code should have good reason (and no alternative) before doing so.\n\n\nProcess Creation\n\n\nMost operating systems implement a \nspawn\n mechanism to create a new process in a new address space, read in an executable, and begin executing it. Unix separates these steps into two distinct functions: \nfork()\n and \nexec()\n.\n\n\n\n\nfork()\n: creates a child process that is a copy of the current task. It differs from the parent only in its PID, its PPID (parent\u2019s PID), and certain resources and statistics (e.g. pending signals) which are not inherited.\n\n\nexec()\n: loads a new executable into the address space and begins executing it.\n\n\n\n\nCopy-on-Write\n\n\nIf upon \nfork()\n all resources owned by the parent are duplicated and the copy is given to the child, it is naive and inefficient in that it copies much data that might otherwise be shared. Worse still, if the new process were to immediately execute a new image, all that copying would go to waste.\n\n\nIn Linux, \nfork()\n is implemented through the use of copy-on-write pages.\n\n\nCopy-on-write\n (COW) can delay or prevent copying data. Rather than duplicating the process address space, the parent and the child can share a single copy.\n\n\n\n\nIf the data is written to, it is marked and a duplicate is made and each process receives a unique copy. The duplication of resources occurs only when they are written; until then, they are shared read-only.\n\n\nIn the case that the pages are never written (if \nexec()\n is called immediately after \nfork()\n), they never need to be copied.\n\n\n\n\nThe only overhead incurred by \nfork()\n is the duplication of the parent\u2019s page tables and the creation of a unique process descriptor for the child. In the common case that a process executes a new executable image immediately after forking, this optimization prevents the wasted copying of large amounts of data (with the address space, easily tens of megabytes). This is an important optimization because the Unix philosophy encourages quick process execution.\n\n\nForking\n\n\nLinux implements \nfork()\n via the \nclone()\n system call which takes a series of flags that specify which resources the parent and child process should share.\n\n\n\n\nThe \nfork()\n, \nvfork()\n, and \n__clone()\n library calls all invoke the \nclone()\n system call with the requisite flags.\n\n\nThe \nclone()\n system call calls \ndo_fork()\n.\n\n\n\n\nThe bulk of the work in forking is handled by \ndo_fork()\n, which is defined in \nkernel/fork.c\n. \ndo_fork()\n function calls \ncopy_process()\n and then starts the process running. \n\n\n\n\ndo_fork()\n: \nkernel/fork.c#L1354\n\n\ncopy_process()\n: \nkernel/fork.c#L957\n\n\n\n\nThe interesting work is done by \ncopy_process()\n:\n\n\n\n\nIt calls \ndup_task_struct()\n that creates following for the new process with identical values to those of the current task:\n\n\nKernel stack\n\n\nthread_info\n structure\n\n\ntask_struct\n\n\n(At this point, the child and parent process descriptors are identical)\n\n\n\n\n\n\nIt then checks that the new child will not exceed the resource limits on the number of processes for the current user.\n\n\nVarious members of the process descriptor are cleared or set to initial values, \nto differentiate the child from its parent.\n\n\nMembers of the process descriptor not inherited are primarily statistically information.\n\n\nThe bulk of the values in \ntask_struct\n remain unchanged.\n\n\n\n\n\n\nThe child\u2019s state is set to \nTASK_UNINTERRUPTIBLE\n to ensure that it does not yet run.\n\n\nIt calls \ncopy_flags()\n to update the flags member of the \ntask_struct\n (per process flags: \ninclude/linux/sched.h#L1693\n).\n\n\nThe \nPF_SUPERPRIV\n flag, which denotes whether a task used superuser privileges, is cleared\n\n\nThe \nPF_FORKNOEXEC\n flag, which denotes a process that has not called \nexec()\n, is set.\n\n\n\n\n\n\nIt calls \nalloc_pid()\n to assign an available PID to the new task.\n\n\nDepending on the flags passed to \nclone()\n, \ncopy_process()\n either duplicates or shares:\n\n\nOpen files\n\n\nFilesystem information\n\n\nSignal handlers\n\n\nProcess address space\n\n\nNamespace\n\n\n(These resources are typically shared between threads in a given process; otherwise they are unique and thus copied here)\n\n\n\n\n\n\nFinally, \ncopy_process()\n cleans up and returns to the caller \na pointer to the new child\n.\n\n\n\n\nBack in \ndo_fork()\n, if \ncopy_process()\n returns successfully, the new child is woken up and run.\n\n\nDeliberately, the kernel runs the child process first. In the case of the child calling \nexec()\n immediately, this eliminates any copy-on-write overhead that would occur if the parent ran first and began writing to the address space.\n\n\nvfork()\n\n\nThe \nvfork()\n system call has the same effect as \nfork()\n, except that the page table entries of the parent process are not copied. The child executes as the sole thread in the parent\u2019s address space, and the parent is blocked until the child either calls \nexec()\n or exits. The child is not allowed to write to the address space. [p33]\n\n\nToday, with copy-on-write and child-runs-first semantics, the only benefit to \nvfork()\n is not copying the parent page tables entries. [p33]\n\n\nThe \nvfork()\n system call is implemented via a special flag to the \nclone()\n system call:\n\n\n\n\nIn \ncopy_process()\n, the \ntask_struct\n member \nvfork_done\n is set to NULL.\n\n\nIn \ndo_fork()\n, if the special flag was given, \nvfork_done\n is pointed at a specific address.\n\n\nAfter the child is first run, the parent (instead of returning) waits for the child to signal it through the \nvfork_done\n pointer.\n\n\nIn the \nmm_release()\n function, which is used when a task exits a memory address space, \nvfork_done\n is checked to see whether it is NULL. If it is not, the parent is signaled.\n\n\nBack in \ndo_fork()\n, the parent wakes up and returns.\n\n\n\n\nIf this all goes as planned, the child is now executing in a new address space, and the parent is again executing in its original address space. The overhead is lower, but the implementation is not pretty.\n\n\nThe Linux Implementation of Threads\n\n\n\n\nThreads are a programming abstraction that provide multiple threads of execution within the same program in a shared memory address space.\n\n\nThreads can also share open files and other resources.\n\n\nThreads enable \nconcurrent programming\n and, on multiple processor systems, true \nparallelism\n.\n\n\n\n\nLinux has a unique implementation of threads:\n\n\n\n\nTo the Linux kernel, there is no concept of a thread. Linux implements all threads as standard processes.\n\n\nThe kernel does not provide any special scheduling semantics or data structures to represent threads. Instead, a thread is merely a process that shares certain resources with other processes.\n\n\nEach thread has a unique \ntask_struct\n and appears to the kernel as a normal process. Threads just happen to share resources, such as an address space, with other processes.\n\n\n\n\nThis approach to threads contrasts greatly with operating systems such as Microsoft Windows or Sun Solaris, which have explicit kernel support for threads (and sometimes call threads lightweight processes). [p34]\n\n\nCreating Threads\n\n\nThreads are created the same as normal tasks, with the exception that the \nclone()\n system call is passed flags corresponding to the specific resources to be shared:\n\n\nclone\n(\nCLONE_VM\n \n|\n \nCLONE_FS\n \n|\n \nCLONE_FILES\n \n|\n \nCLONE_SIGHAND\n,\n \n0\n);\n\n\n\n\n\n\nThe above code is identical to \nfork()\n except that the address space (\nCLONE_VM\n), filesystem resources (\nCLONE_FS\n), file descriptors (\nCLONE_FILES\n), and signal handlers (\nCLONE_SIGHAND\n) are shared.\n\n\nfork()\n can be implemented as:\n\n\nclone\n(\nSIGCHLD\n,\n \n0\n);\n\n\n\n\n\n\nvfork()\n is implemented as:\n\n\nclone\n(\nCLONE_VFORK\n \n|\n \nCLONE_VM\n \n|\n \nSIGCHLD\n,\n \n0\n);\n\n\n\n\n\n\nThe flags, which are defined in \nlinux/sched.h\n (\ninclude/linux/sched.h#L5\n),  to \nclone()\n specify the behavior of the new process and detail what resources the parent and child will share.\n\n\n\n\n\n\n\n\nFlag\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nCLONE_FILES\n\n\nParent and child share open files.\n\n\n\n\n\n\nCLONE_FS\n\n\nParent and child share filesystem information.\n\n\n\n\n\n\nCLONE_IDLETASK\n\n\nSet PID to zero (used only by the idle tasks).\n\n\n\n\n\n\nCLONE_NEWNS\n\n\nCreate a new namespace for the child.\n\n\n\n\n\n\nCLONE_PARENT\n\n\nChild is to have same parent as its parent.\n\n\n\n\n\n\nCLONE_PTRACE\n\n\nContinue tracing child.\n\n\n\n\n\n\nCLONE_SETTID\n\n\nWrite the TID back to user-space.\n\n\n\n\n\n\nCLONE_SETTLS\n\n\nCreate a new TLS (thread-local storage) for the child.\n\n\n\n\n\n\nCLONE_SIGHAND\n\n\nParent and child share signal handlers and blocked signals.\n\n\n\n\n\n\nCLONE_SYSVSEM\n\n\nParent and child share System V SEM_UNDO semantics.\n\n\n\n\n\n\nCLONE_THREAD\n\n\nParent and child are in the same thread group.\n\n\n\n\n\n\nCLONE_VFORK\n\n\nvfork() was used and the parent will sleep until the child wakes it.\n\n\n\n\n\n\nCLONE_UNTRACED\n\n\nDo not let the tracing process force CLONE_PTRACE on the child.\n\n\n\n\n\n\nCLONE_STOP\n\n\nStart process in the TASK_STOPPED state.\n\n\n\n\n\n\nCLONE_CHILD_CLEARTID\n\n\nClear the TID in the child.\n\n\n\n\n\n\nCLONE_CHILD_SETTID\n\n\nSet the TID in the child.\n\n\n\n\n\n\nCLONE_PARENT_SETTID\n\n\nSet the TID in the parent.\n\n\n\n\n\n\nCLONE_VM\n\n\nParent and child share address space.\n\n\n\n\n\n\n\n\nKernel Threads\n\n\nKernel threads\n are standard processes that exist solely in kernel-space. They are useful for the kernel to perform some operations in the background.\n\n\nDifference from normal threads:\n\n\n\n\nKernel threads do not have an address space. Their \nmm\n pointer, which points at their address space, is \nNULL\n.\n\n\nKernel threads operate only in kernel-space and do not context switch into user-space.\n\n\n\n\nSimilarity with normal threads:\n\n\n\n\nKernel threads are schedulable and preemptable.\n\n\n\n\nLinux delegates several tasks to kernel threads, most notably the \nflush\n tasks and the \nksoftirqd\n task. Use \nps -ef\n command to see them.\n\n\n\n\nKernel threads are created on system boot by other kernel threads. \n\n\nA kernel thread can be created only by another kernel thread. The kernel handles this automatically by forking all new kernel threads off of the \nkthreadd\n kernel process.\n\n\n\n\nThe interfaces of kernel threads defined in \nlinux/kthread.h\n (\ninclude/linux/kthread.h\n)\n\n\nkthread_create()\n spawns a new kernel thread from an existing one:\n\n\nstruct task_struct *kthread_create(int (*threadfn)(void *data),\n                                   void *data,\n                                   const char namefmt[],\n                                   ...)\n\n\n\n\n\nThe new task is created via the \nclone()\n system call by the \nkthread\n kernel process:\n\n\n\n\nThe new process will run the \nthreadfn\n function, which is passed the data argument.\n\n\nThe process will be named \nnamefmt\n, which takes printf-style formatting arguments in the variable argument list.\n\n\nThe process is created in an unrunnable state; it will not start running until explicitly woken up via \nwake_up_process()\n.\n\n\n\n\nA process can be created and made runnable with a single function, \nkthread_run()\n:\n\n\nstruct\n \ntask_struct\n \n*\nkthread_run\n(\nint\n \n(\n*\nthreadfn\n)(\nvoid\n \n*\ndata\n),\n\n                                \nvoid\n \n*\ndata\n,\n\n                                \nconst\n \nchar\n \nnamefmt\n[],\n\n                                \n...)\n\n\n\n\n\n\nThis routine (\nkthread_run()\n), implemented as a macro, simply calls both \nkthread_create()\n and \nwake_up_process()\n:\n\n\n#define kthread_run(threadfn, data, namefmt, ...)                 \\\n\n\n({                                                                \\\n\n\n    struct task_struct *k;                                        \\\n\n\n                                                                  \\\n\n\n    k = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);  \\\n\n\n    if (!IS_ERR(k))                                               \\\n\n\n        wake_up_process(k);                                       \\\n\n\n    k;                                                            \\\n\n\n})\n\n\n\n\n\n\nWhen started, a kernel thread continues to exist until it calls \ndo_exit()\n or another part of the kernel calls \nkthread_stop()\n, passing in the address of the \ntask_struct\n structure returned by \nkthread_create()\n:\n\n\nint\n \nkthread_stop\n(\nstruct\n \ntask_struct\n \n*\nk\n)\n\n\n\n\n\n\nProcess Termination\n\n\nWhen a process terminates, the kernel releases the resources owned by the process and notifies the child\u2019s parent of its demise.\n\n\nSelf-induced process termination occurs when the process calls the \nexit()\n system call, which is either:\n\n\n\n\nExplicitly: the process calls \nexit()\n system call.\n\n\nImplicitly: the process return from the main subroutine of any program. The C compiler places a call to \nexit()\n after \nmain()\n returns.\n\n\n\n\nInvoluntary process termination occurs when the process receives a signal or exception it cannot handle or ignore.\n\n\nRegardless of how a process terminates, the bulk of the work is handled by \ndo_exit()\n, defined in \nkernel/exit.c\n (\nkernel/exit.c#L900\n), which does the following:\n\n\n\n\nIt sets the \nPF_EXITING\n flag in the flags member of the \ntask_struct\n.\n\n\nIt calls \ndel_timer_sync()\n to remove any kernel timers. Upon return, it is guaranteed that no timer is queued and that no timer handler is running.\n\n\nIf BSD process accounting is enabled, \ndo_exit()\n calls \nacct_update_integrals()\n to write out accounting information.\n\n\nIt calls \nexit_mm()\n to release the \nmm_struct\n held by this process. If no other process is using this address space (if the address space is not shared) the kernel then destroys it.\n\n\nIt calls \nexit_sem()\n. If the process is queued waiting for an IPC semaphore, it is dequeued here.\n\n\nIt then calls \nexit_files()\n and \nexit_fs()\n to decrement the usage count of objects related to file descriptors and filesystem data, respectively.\n\n\nIt sets the task\u2019s exit code (stored in the \nexit_code\n member of the \ntask_struct\n) to that provided by \nexit()\n or whatever kernel mechanism forced the termination. \nThe exit code is stored here for optional retrieval by the parent.\n\n\nIt send signals and reparents children:\n\n\nCalls \nexit_notify()\n to send signals to the task\u2019s parent\n\n\nReparents any of the task\u2019s children to another thread in their thread group or the init process\n\n\nSets the task\u2019s exit state (stored in \nexit_state\n in the \ntask_struct\n structure) to \nEXIT_ZOMBIE\n.\n\n\n\n\n\n\nIt calls \nschedule()\n to switch to a new process.\n\n\nBecause the process is now not schedulable, this is the last code the task will ever execute. \ndo_exit()\n never returns.\n\n\n\n\n\n\n\n\nAt this point:\n\n\n\n\nAll objects associated with the task (assuming the task was the sole user) are freed.\n\n\nThe task is not runnable (and no longer has an address space in which to run) and is in the \nEXIT_ZOMBIE\n exit state.\n\n\nThe only memory it occupies is its kernel stack, the \nthread_info\n structure, and the \ntask_struct\n structure.\n\n\nThe task exists solely to provide information to its parent. After the parent retrieves the information, or notifies the kernel that it is uninterested, the remaining memory held by the process is freed and returned to the system for use.\n\n\n\n\nRemoving the Process Descriptor\n\n\nAfter \ndo_exit()\n completes, the process descriptor for the terminated process still exists, but the process is a zombie and is unable to run. \n\n\nCleaning up after a process and removing its process descriptor are separate steps. This enables the system to obtain information about a child process after it has terminated.\n\n\nThe terminated child\u2019s \ntask_struct\n is deallocated after any of the following:\n\n\n\n\nThe parent has obtained information on its terminated child.\n\n\nThe parent has signified to the kernel that it does not care (about the terminated child).\n\n\n\n\nThe \nwait()\n family of functions are implemented via a system call \nwait4()\n.\n\n\nThe standard behavior is to suspend execution of the calling task until one of its children exits, at which time the function returns with the PID of the exited child. On return, a pointer (as an argument to a \nwait()\n function) holds the exit code of the terminated child. [p38]\n\n\nrelease_task()\n is invoked to finally deallocate the process descriptor:\n\n\n\n\nIt calls \n__exit_signal()\n, which calls \n__unhash_process()\n, which in turns calls detach_pid() to remove the process from the pidhash and remove the process from the task list.\n\n\n__exit_signal()\n releases any remaining resources used by the now dead process and finalizes statistics and bookkeeping.\n\n\nIf the task was the last member of a thread group, and the leader is a zombie, then \nrelease_task()\n notifies the zombie leader\u2019s parent.\n\n\nrelease_task()\n calls \nput_task_struct()\n to free the pages containing the process\u2019s kernel stack and \nthread_info\n structure and deallocate the slab cache containing the \ntask_struct\n.\n\n\n\n\nAt this point, the process descriptor and all resources belonging solely to the process have been freed.\n\n\nThe Dilemma of the Parentless Task\n\n\nIf a parent exits before its children, any of its child tasks must be reparented to a new process, otherwise parentless terminated processes would forever remain zombies, wasting system memory.\n\n\nThe solution is to reparent a task\u2019s children on exit to another process in the current thread group, or (if that fails) the init process.\n\n\ndo_exit()\n calls \nexit_notify()\n, which calls \nforget_original_parent()\n, which calls \nfind_new_reaper()\n to perform the reparenting:\n\n\nstatic\n \nstruct\n \ntask_struct\n \n*\nfind_new_reaper\n(\nstruct\n \ntask_struct\n \n*\nfather\n)\n\n\n{\n\n    \nstruct\n \npid_namespace\n \n*\npid_ns\n \n=\n \ntask_active_pid_ns\n(\nfather\n);\n\n    \nstruct\n \ntask_struct\n \n*\nthread\n;\n\n\n    \nthread\n \n=\n \nfather\n;\n\n    \nwhile_each_thread\n(\nfather\n,\n \nthread\n)\n \n{\n\n      \nif\n \n(\nthread\n-\nflags\n \n \nPF_EXITING\n)\n\n          \ncontinue\n;\n\n      \nif\n \n(\nunlikely\n(\npid_ns\n-\nchild_reaper\n \n==\n \nfather\n))\n\n          \npid_ns\n-\nchild_reaper\n \n=\n \nthread\n;\n\n      \nreturn\n \nthread\n;\n\n    \n}\n\n\n    \nif\n \n(\nunlikely\n(\npid_ns\n-\nchild_reaper\n \n==\n \nfather\n))\n \n{\n\n        \nwrite_unlock_irq\n(\ntasklist_lock\n);\n\n        \nif\n \n(\nunlikely\n(\npid_ns\n \n==\n \ninit_pid_ns\n))\n\n        \npanic\n(\nAttempted to kill init!\n);\n\n\n        \nzap_pid_ns_processes\n(\npid_ns\n);\n\n        \nwrite_lock_irq\n(\ntasklist_lock\n);\n\n\n        \n/*\n\n\n        * We can not clear -\nchild_reaper or leave it alone.\n\n\n        * There may by stealth EXIT_DEAD tasks on -\nchildren,\n\n\n        * forget_original_parent() must move them somewhere.\n\n\n        */\n\n        \npid_ns\n-\nchild_reaper\n \n=\n \ninit_pid_ns\n.\nchild_reaper\n;\n\n    \n}\n\n\n    \nreturn\n \npid_ns\n-\nchild_reaper\n;\n\n\n}\n\n\n\n\n\n\nThe above code attempts to find and return another task in the process\u2019s thread group. If another task is not in the thread group, it finds and returns the \ninit\n process.\n\n\nAfter a suitable new parent for the children is found, each child needs to be located and reparented to \nreaper\n:\n\n\nreaper\n \n=\n \nfind_new_reaper\n(\nfather\n);\n\n\nlist_for_each_entry_safe\n(\np\n,\n \nn\n,\n \nfather\n-\nchildren\n,\n \nsibling\n)\n \n{\n\n    \np\n-\nreal_parent\n \n=\n \nreaper\n;\n\n    \nif\n \n(\np\n-\nparent\n \n==\n \nfather\n)\n \n{\n\n        \nBUG_ON\n(\np\n-\nptrace\n);\n\n        \np\n-\nparent\n \n=\n \np\n-\nreal_parent\n;\n\n    \n}\n\n    \nreparent_thread\n(\np\n,\n \nfather\n);\n\n\n}\n\n\n\n\n\n\nptrace_exit_finish()\n is then called to do the same reparenting but to a list of \nptraced\n children:\n\n\nvoid\n \nexit_ptrace\n(\nstruct\n \ntask_struct\n \n*\ntracer\n)\n\n\n{\n\n    \nstruct\n \ntask_struct\n \n*\np\n,\n \n*\nn\n;\n\n    \nLIST_HEAD\n(\nptrace_dead\n);\n\n\n    \nwrite_lock_irq\n(\ntasklist_lock\n);\n\n    \nlist_for_each_entry_safe\n(\np\n,\n \nn\n,\n \ntracer\n-\nptraced\n,\n \nptrace_entry\n)\n \n{\n\n        \nif\n \n(\n__ptrace_detach\n(\ntracer\n,\n \np\n))\n\n        \nlist_add\n(\np\n-\nptrace_entry\n,\n \nptrace_dead\n);\n\n    \n}\n\n    \nwrite_unlock_irq\n(\ntasklist_lock\n);\n\n\n    \nBUG_ON\n(\n!\nlist_empty\n(\ntracer\n-\nptraced\n));\n\n\n    \nlist_for_each_entry_safe\n(\np\n,\n \nn\n,\n \nptrace_dead\n,\n \nptrace_entry\n)\n \n{\n\n    \nlist_del_init\n(\np\n-\nptrace_entry\n);\n\n    \nrelease_task\n(\np\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWhen a task is \nptraced\n, it is temporarily reparented to the debugging process. When the task\u2019s parent exits, however, it must be reparented along with its other siblings. In previous kernels, this resulted in a loop over every process in the system looking for children. The solution is simply to keep a separate list of a process\u2019s children being ptraced, reducing the search for one\u2019s children from every process to just two relatively small lists\n\n\nAfter the process are successfully reparented, there is no risk of stray zombie processes. The \ninit\n process routinely calls \nwait()\n on its children, cleaning up any zombies assigned to it.\n\n\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\n\n\nThese two routines are provided by the macros \nnext_task(task)\n and \nprev_task(task)\n, respectively.\n\n\n\n\nI didn't find any relevant appearance for \nprev_task\n macro in the \nLinux 2.6.34.7 source code\n.", 
            "title": "Chapter 3. Process Management"
        }, 
        {
            "location": "/lkd/ch4/", 
            "text": "Chapter 4. Process Scheduling\n\n\nThis chapter discusses the \nprocess scheduler\n, the kernel subsystem that puts those processes to work.\n\n\nThe process scheduler (or simply the scheduler) divides the finite resource of processor time between the runnable processes on a system. It is responsible for best utilizing the system and giving users the impression that multiple processes are executing simultaneously. [p41]\n\n\nTo best utilize processor time, assuming there are runnable processes, a process should always be running. If there are more \nrunnable\n processes than processors in a system, some processes will not be running at a given moment. These processes are \nwaiting to run\n. Deciding which process runs next, given a set of runnable processes, is the fundamental decision that the scheduler must make.\n\n\nMultitasking\n\n\nA \nmultitasking\n operating system is one that can simultaneously interleave execution of more than one process.\n\n\n\n\nOn single processor machines, this gives the illusion of multiple processes running concurrently.\n\n\nOn multiprocessor machines, this enables processes to actually run concurrently, in parallel, on different processors.\n\n\n\n\nOn either type of machine, it also enables many processes to \nblock\n or \nsleep\n. Although these processes are in memory, they are not \nrunnable\n. These processes utilize the kernel to wait until some event (keyboard input, network data, passage of time, and so on) occurs. [p41]\n\n\nMultitasking operating systems come in two flavors:\n\n\n\n\nCooperative multitasking\n\n\nPreemptive multitasking\n\n\n\n\nPreemptive multitasking\n\n\nLinux, like all Unix variants and most modern operating systems, implements preemptive multitasking. In preemptive multitasking, the scheduler decides\nwhen a process is to cease running and a new process is to begin running.\n\n\n\n\nPreemption\n: the act of involuntarily suspending a running process.\n\n\nTimeslice\n of a process: the time the process runs before it is preempted is usually predetermined.\n\n\nManaging the timeslice enables the scheduler to make global scheduling decisions for the system and prevents any one process from monopolizing the processor.\n\n\nOn many modern operating systems, the timeslice is dynamically calculated as a function of process behavior and configurable system policy.\n\n\nLinux\u2019s unique \"fair\" scheduler does not employ timeslices \nper se\n, to interesting effect.\n\n\n\n\n\n\n\n\nCooperative multitasking\n\n\nIn cooperative multitasking, a process does not stop running until it voluntarily decides to do so. The act of a process voluntarily suspending itself is called \nyielding\n, but the operating system cannot enforce this.\n\n\nThe shortcomings of this approach are manifest:\n\n\n\n\nThe scheduler cannot make global decisions regarding how long processes run;\n\n\nProcesses can monopolize the processor for longer than the user desires;\n\n\nA hung process that never yields can potentially bring down the entire system.\n\n\n\n\n[p42]\n\n\nLinux\u2019s Process Scheduler\n\n\nFrom Linux\u2019s first version in 1991 through the 2.4 kernel series, the Linux scheduler was simple in design. It was easy to understand, but scaled poorly in light of many runnable processes or many processors.\n\n\nDuring the 2.5 kernel development series, the \nO(1) scheduler\n solved the shortcomings of the previous Linux scheduler and introduced powerful new features and performance characteristics. By introducing a constant-time algorithm for timeslice calculation and per-processor runqueues, it rectified the design limitations of the earlier scheduler.\n\n\nHowever, the O(1) scheduler had several pathological failures related to scheduling latency-sensitive applications (interactive processes). Thus, although the O(1) scheduler was ideal for large server workloads, which lack interactive processes, it performed below par on desktop systems, where interactive applications are the \nraison d\u2019\u00eatre\n.\n\n\nBeginning in the 2.6 kernel series, developers introduced new process schedulers aimed at improving the interactive performance of the O(1) scheduler. The most notable of these was the \nRotating Staircase Deadline\n scheduler, which introduced the concept of \nfair scheduling\n, borrowed from queuing theory, to Linux\u2019s process scheduler. This concept was the inspiration for the O(1) scheduler\u2019s eventual replacement in kernel version 2.6.23, the \nCompletely Fair Scheduler\n (CFS).\n\n\nThis chapter discusses the fundamentals of scheduler design and how they apply to the Completely Fair Scheduler and its goals, design, implementation, algorithms, and related system calls. We also discuss the O(1) scheduler because its implementation is a more \"classic\" Unix process scheduler model.", 
            "title": "Chapter 4. Process Scheduling"
        }, 
        {
            "location": "/unp/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nIntroduction\n\n\nThe \nclient\n and \nserver\n organization is used by most network-awared applications. Some complex applications also require \nasynchronous callback\n communication, where the server initiates a message to the client.\n\n\nunp.h\n header\n\n\n\n\nunp.h\n\n\n\n\nA Simple Daytime Client\n\n\n\n\ndaytimetcpcli.c\n\n\n\n\n\n\n\nCreate TCP socket\n\n\nThe \nsocket\n function creates an Internet (\nAF_INET\n) stream (\nSOCK_STREAM\n) socket, which is a fancy name for a TCP socket. The function returns a small integer descriptor to identify the socket.\n\n\nSpecify server's IP address and port\n\n\nThe IP address (\nsin_addr\n) and port number (\nsin_port\n) fields in the Internet socket address structure (\nsockaddr_in\n) must be in specific formats:\n\n\n\n\nhtons\n (host to network short): converts the binary port number\n\n\ninet_pton\n (presentation to numeric): convert the ASCII command-line argument (such as \n206.62.226.35\n when we ran this example) into the proper format.\n\n\n\n\nbzero\n is not an ANSI C function, but is used in this book instead of the ANSI C \nmemset\n function, because \nbzero\n is easier to remember (with only two arguments) than \nmemset\n (with three arguments).\n\n\nEstablish connection with server\n\n\n\n\nconnect\n\n\n\n\nIn the \nunp.h\n header, \nSA\n is defined to be \nstruct sockaddr\n, a generic socket address structure.\n\n\nRead and display server's reply\n\n\nWe must be careful when using TCP because it is a \nbyte-stream\n protocol with no record boundaries. Since we cannot assume that the server's reply will be returned by a single \nread\n, we always need to code the \nread\n in a loop when reading from a TCP socket.\n\n\nTerminate program\n\n\nexit\n terminates the program. Unix always closes all open descriptors when a process terminates.\n\n\nProtocol Independence\n\n\nThe above program is protocol-depdent on IPv4.\n\n\nIt is better to make a program protocol-independent by using the \ngetaddrinfo\n function.\n\n\nError Handling: Wrapper Functions\n\n\nWe can shorten our programs by defining a \nwrapper function\n that performs the actual function call, tests the return value, and terminates on an error.\n\n\nsockfd\n \n=\n \nSocket\n(\nAF_INET\n,\n \nSOCK_STREAM\n,\n \n0\n);\n\n\n\n\n\n\nWith careful C coding, we could use macros instead of functions, providing a little run-time efficiency, but these wrapper functions are rarely the performance bottleneck of a program. This book uses these wrapper functions unless otherwise explicit error needs handling.\n\n\nUnix \nerrno\n Value\n\n\nThe value of \nerrno\n is set by a function only if an error occurs. All of the positive error values are constants with all-uppercase names beginning with \"E,\" and are normally defined in the \nsys/errno.h\n header. No error has a value of 0.\n\n\nStoring errno in a global variable does not work with multiple threads that share all global variables.\n\n\nA Simple Daytime Server\n\n\n\n\ndaytimetcpsrv.c\n\n\n\n\n\n\n\nCreate a TCP socket\n\n\nIdentical to the client code.\n\n\nBind server's well-known port to socket\n\n\n\n\nbind\n: the server's well-known port (13) is bound to the socket by calling \nbind\n\n\nINADDR_ANY\n allows the server to accept a client connection on any interface\n\n\n\n\nConvert socket to listening socket\n\n\n\n\nlisten\n: converts the socket into a listening socket, on which incoming connections from clients will be accepted by the kernel\n\n\nlistenfd\n in the code is called a \nlistening descriptor\n\n\n\n\nAccept client connection, send reply\n\n\n\n\naccept\n\n\nconnfd\n in the code is called a \nconnected descriptor\n for communication with the client. A new descriptor is returned by accept for each client that connects to our server.\n\n\n\n\nThis book uses this code style for infinite loop:\n\n\nfor\n \n(\n \n;\n \n;\n \n)\n \n{\n\n    \n// . . .\n\n\n}\n\n\n\n\n\n\nsnprintf\n function\n\n\n\n\nsnprintf\n instead of \nsprintf\n\n\n\n\nSimilarly:\n\n\n\n\nfgets\n instead of \ngets\n\n\nstrncat\n or \nstrlcat\n instead of \nstrcat\n\n\nstrncpy\n or \nstrlcpy\n instead of a \nstrcpy\n\n\n\n\nTerminate connection\n\n\nclose\n initiates the normal TCP connection termination sequence: a FIN is sent in each direction and each FIN is acknowledged by the other end.\n\n\nThe server implemented in the above server code is:\n\n\n\n\nProtocol-dependent on IPv4\n\n\nHandles only one client at a time. If multiple client connections arrive at about the same time, the kernel queues them, up to some limit, and returns them to \naccept\n one at a time.\n\n\nCalled an \niterative server\n. A \nconcurrent server\n handles multiple clients at the same time.\n\n\n\n\nOSI Model\n\n\nSome terms mentioned:\n\n\n\n\nRaw socket\n: it is possible for an application to bypass the transport layer and use IPv4 or IPv6 directly\n\n\nXTI\n\n\n\n\nSockets provide the interface from the upper three layers of the OSI model into the transport layer:\n\n\n\n\nThe upper three layers handle all the details of the application. The lower four layers know little about the application, but handle all the communication details\n\n\nThe upper three layers form what is called a \nuser process\n while the lower four layers are normally provided as part of the operating system (OS) kernel\n\n\n\n\nBSD Networking History\n\n\nLinux does not fit into the Berkeley-derived classification: Its networking code and sockets API were developed from scratch.\n\n\nUnix Standards\n\n\nBackground on POSIX\n\n\n\n\nPOSIX: Portable Operating System Interface, developed by IEEE and adopted as standards by ISO and IEC (ISO/IEC)\n\n\n\n\nBackground on The Open Group\n\n\n\n\nSingle UNIX Specification\n\n\n\n\nInternet Engineering Task Force (IETF)\n\n\n64-Bit Architectures\n\n\n\n\nILP32\n: integers (I), long integers (L), and pointers (P) occupy 32 bits.\n\n\nLP64\n:only long integers (L) and pointers (P) require 64 bits.\n\n\n\n\nFrom a programming perspective, the LP64 model means we cannot assume that a pointer can be stored in an integer. We must also consider the effect of the LP64 model on existing APIs\n\n\nOn a 32-bit system, \nsize_t\n is a 32-bit value, but on a 64-bit system, it must be a 64-bit value, to take advantage of the larger addressing model. This means a 64-bit system will probably contain a typedef of \nsize_t\n to be an unsigned long.", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/unp/ch2/", 
            "text": "Chapter 2. The Transport Layer: TCP, UDP, and SCTP\n\n\nIntroduction\n\n\nThis chapter focuses on the transport layer: TCP, UDP, and Stream Control Transmission Protocol (SCTP). UDP is a simple, unreliable datagram protocol, while TCP is a sophisticated, reliable byte-stream protocol. SCTP is similar to TCP as a reliable transport protocol, but it also provides message boundaries, transport-level support for multihoming, and a way to minimize head-of-line blocking.\n\n\nThe Big Picture\n\n\nOverview of TCP/IP protocols:\n\n\n\n\n\n\n\n\nProtocol\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIPv4\n\n\nInternet Protocol version 4. IPv4 uses 32-bit addresses and provides packet delivery service for TCP, UDP, SCTP, ICMP, and IGMP.\n\n\n\n\n\n\nIPv6\n\n\nInternet Protocol version 6. IPv6 uses 128-bit addresses.\n\n\n\n\n\n\nTCP\n\n\nTransmission Control Protocol. TCP is a connection-oriented protocol that provides a reliable, full-duplex byte stream to its users\n\n\n\n\n\n\nUDP\n\n\nUser Datagram Protocol. UDP is a connectionless protocol, and UDP sockets are an example of datagram sockets.\n\n\n\n\n\n\nSCTP\n\n\nStream Control Transmission Protocol. SCTP is a connection-oriented protocol that provides a reliable full-duplex association\n\n\n\n\n\n\nICMP\n\n\nInternet Control Message Protocol. ICMP handles error and control information between routers and hosts.\n\n\n\n\n\n\nIGMP\n\n\nInternet Group Management Protocol. IGMP is used with multicasting.\n\n\n\n\n\n\nARP\n\n\nAddress Resolution Protocol. ARP maps an IPv4 address into a hardware address (such as an Ethernet address). ARP is normally used on broadcast networks such as Ethernet, \ntoken ring\n, and \nFDDI\n, and is not needed on point-to-point networks.\n\n\n\n\n\n\nRARP\n\n\nReverse Address Resolution Protocol. RARP maps a hardware address into an IPv4 address. It is sometimes used when a diskless node is booting.\n\n\n\n\n\n\nICMPv6\n\n\nInternet Control Message Protocol version 6. ICMPv6 combines the functionality of ICMPv4, IGMP, and ARP.\n\n\n\n\n\n\nBPF\n\n\nBSD packet filter\n. This interface provides access to the datalink layer. It is normally found on Berkeley-derived kernels.\n\n\n\n\n\n\nDLPI\n\n\nDatalink provider interface\n.\n\n\n\n\n\n\n\n\nUser Datagram Protocol (UDP)\n\n\n\n\nLack of reliability\n\n\nEach UDP datagram has a length\n\n\nConnectionless\n service\n\n\n\n\nTransmission Control Protocol (TCP)\n\n\n\n\nConnection\n: TCP provides connections between clients and servers. A TCP client establishes a connection with a server, exchanges data across the connection, and then terminates the connection.\n\n\nReliability\n: TCP requires acknowledgment when sending data. If an acknowledgment is not received, TCP automatically retransmits the data and waits a longer amount of time.\n\n\nRound-trip time\n (RTT): TCP estimates RTT between a client and server dynamically so that it knows how long to wait for an acknowledgment.\n\n\nSequencing\n: TCP associates a sequence number with every byte (\nsegment\n, unit of data that TCP passes to IP.) it sends. TCP reorders out-of-order segments and discards duplicate segments.\n\n\nFlow control\n\n\nFull-duplex\n: an application can send and receive data in both directions on a given connection at any time.\n\n\n\n\nStream Control Transmission Protocol (SCTP)\n\n\nLike TCP, SCTP provides reliability, sequencing, flow control, and full-duplex data transfer.\n\n\nUnlike TCP, SCTP provides:\n\n\n\n\nAssociation\n instead of \"connection\": An association refers to a communication between two systems, which may involve more than two addresses due to multihoming.\n\n\nMessage-oriented\n: provides sequenced delivery of individual records. Like UDP, the length of a record written by the sender is passed to the receiving application.\n\n\nMultihoming\n: allows a single SCTP endpoint to support multiple IP addresses. This feature can provide increased robustness against network failure.\n\n\n\n\nTCP Connection Establishment and Termination\n\n\nThree-Way Handshake\n\n\n\n\n\n\nServer: \npassive open\n, by calling \nsocket\n, \nbind\n, and \nlisten\n\n\nClient: \nactive open\n, by calling \nconnect\n. The client TCP to send a \"synchronize\" (SYN) segment with no data but it contains client's initial sequence number for the data to be sent on the connection.\n\n\nServer: acknowledges (ACK) client's SYN. The server sends its SYN and the ACK of the client's SYN in a single segment which also contains its own SYN containing the initial sequence number for the data to be sent on the connection.\n\n\nClient: acknowledges the server's SYN.\n\n\n\n\nThe client's initial sequence number as \nJ\n and the server's initial sequence number as \nK\n. The acknowledgment number in an ACK is the next expected sequence number for the end sending the ACK. Since a SYN occupies one byte of the sequence number space, the acknowledgment number in the ACK of each SYN is the initial sequence number plus one.\n\n\nTCP Options\n\n\n\n\nMSS option. The TCP sending the SYN announces its \nmaximum segment size\n (the maximum amount of data that it is willing to accept in each TCP segment)on this connection.\n\n\nWindow scale option. [p38]\n\n\nTimestamp option\n\n\n\n\nTCP Connection Termination\n\n\n\n\nIt takes four segments to terminate a connection:\n\n\n\n\nOne end calls \nclose\n first by sending a FIN segment to mean it is finished sending data. This is called \nactive close\n.\n\n\nThe other end that receives the FIN performs the \npassive close\n. The received FIN is acknowledged by TCP (sending an ACK segment). The receipt of the FIN is also passed to the application as an end-of-file.\n\n\nSometime later, the application that received the end-of-file will close its socket. This causes its TCP to send a FIN.\n\n\nThe TCP on the system that receives this final FIN (the end that did the active close) acknowledges the FIN\n\n\n\n\nA FIN occupies one byte of sequence number space just like a SYN. Therefore, the ACK of each FIN is the sequence number of the FIN plus one.\n\n\nTCP State Transition Diagram\n\n\n\n\nThere are 11 different states defined for a connection and the rules of TCP dictate the transitions from one state to another, based on the current state and the segment received in that state.\n\n\nWatching the Packets\n\n\n\n\nThe client in this example announces an MSS of 536 (\nminimum reassembly buffer size\n) and the server announces an MSS of 1,460 (typical for IPv4 on an Ethernet). It is okay for the MSS to be different in each direction. The acknowledgment of the client's request is sent with the server's reply. This is called \npiggybacking\n and will normally happen when the time it takes the server to process the request and generate the reply is less than around 200 ms. \nWith TCP, there would be eight segments of overhead. If UDP was used, only two packets would be exchanged.\n\n\n\n\nUDP removes all the reliability that TCP provides to the application.\n\n\nUDP avoids the overhead of TCP connection establishment and connection termination.\n\n\n\n\nTIME_WAIT State\n\n\nThe end that performs the active close goes through the TIME_WAIT state. The duration that this endpoint remains in the TIME_WAIT state is twice the \nmaximum segment lifetime\n (MSL), sometimes called 2MSL, which is between 1 and 4 minutes. The MSL is the maximum amount of time that any given IP datagram can live in a network. The IPv4 TTL field  IPv6 hop limit field have a maximum value 255. The assumption is made that a packet with the maximum hop limit of 255 cannot exist in a network for more than MSL seconds. [p43]\n\n\nTCP must handle \nlost duplicates\n (or \nwandering duplicate\n).\n\n\nThere are two reasons for the TIME_WAIT state:\n\n\n\n\nTo implement TCP's full-duplex connection termination reliably. If TCP is performing all the work necessary to terminate both directions of data flow cleanly for a connection (its full-duplex close), then it must correctly handle the loss of any of these four segments.\n\n\nTo allow old duplicate segments to expire in the network. When we successfully establish a TCP connection, all old duplicates from previous \nincarnations\n of the connection have expired in the network.\n\n\n\n\nPort Numbers\n\n\nAll three transport layers (UDP, SCTP and TCP) use 16-bit integer port numbers to differentiate between processes.\n\n\n\n\nThe \nwell-known ports\n: 0 through 1023.\n\n\nThe \nregistered ports\n: 1024 through 49151\n\n\nThe \ndynamic ports\n or \nprivate ports\n, 49152 through 65535. Also called \nephemeral ports\n.\n\n\n\n\n\n\nSome notes from the figure above:\n\n\n\n\nOn Unix, \nreserved port\n is any port less than 1024. These ports can only be assigned to a socket by an appropriately privileged process. All the IANA well-known ports are reserved ports. The server allocating this port must have superuser privileges when it starts.\n\n\nHistorically, Berkeley-derived implementations (starting with 4.3BSD) have allocated \nephemeral ports\n in the range 1024\u20135000. Many newer systems allocate ephemeral ports differently to provide more ephemeral ports, either using the IANA-defined ephemeral range or a larger range\n\n\n\n\nSocket Pair\n\n\n\n\nSocket pair\n: the four-tuple that defines the two endpoints of a TCP connection: the local IP address, local port, foreign IP address, and foreign port. A socket pair uniquely identifies every TCP connection on a network.\n\n\nSocket\n: two values (an IP address and a port number) that identify each endpoint.\n\n\n\n\nTCP Port Numbers and Concurrent Servers\n\n\n[p52-55]\n\n\nBuffer Sizes and Limitations\n\n\nFigures: \nIPv4 Header\n, \nIPv6 Header\n\n\n\n\nMaximum size of an IPv4 datagram: 65,535 bytes (including the header), because of the 16-bit total length field.\n\n\nMaximum size of an IPv6 datagram: 65,575 bytes (including the 40-byte IPv6 header), because of the 16-bit payload length field. IPv6 has a jumbo payload option, which extends the payload length field to 32 bits, but this option is supported only on datalinks with a \nmaximum transmission unit\n (MTU) that exceeds 65,535.\n\n\nMTU\n (maximum transmission unit): dictated by the hardware. Ethernet MTU is 1,500 bytes; Point-to-point links have a configurable MTU.\n\n\nMinimum link MTU for IPv4: 68 bytes. This permits a maximum-sized IPv4 header (20 bytes of fixed header, 40 bytes of options)  and minimum-sized fragment (the fragment offset is in units of 8 bytes) \n[errata]\n\n\nMinimum link MTU for IPv6: 1,280 bytes.\n\n\n\n\n\n\nPath MTU\n: smallest MTU in the path between two hosts. Today, the Ethernet MTU of 1,500 bytes is often the path MTU. The path MTU need not be the same in both directions between any two hosts because routing in the Internet is often asymmetric.\n\n\nFragmentation\n is performed by both IPv4 and IPv6 when the size of an IP datagram to be sent out an interface exceeds the link MTU. The fragments are not normally \nreassembled\n until they reach the final destination.\n\n\nIPv4: hosts perform fragmentation on datagrams that they generate and routers perform fragmentation on datagrams that they forward\n\n\nIPv6: only hosts perform fragmentation on datagrams that they generate; routers do not fragment datagrams that they are forwarding\n\n\nIPv4 header contains fields to handle fragmentation. IPv6 contains an option header with the fragmentation information.\n\n\n\n\n\n\n\"Don't Fragment\" (DF) bit in IPv4 header specifies that this datagram must not be fragmented, either by the sending host or by any router. A router that receives an IPv4 datagram with the DF bit set whose size exceeds the outgoing link's MTU generates an ICMPv4 \"destination unreachable, fragmentation needed but DF bit set\" error message.\n\n\nSince IPv6 routers do not perform fragmentation, there is an implied DF bit with every IPv6 datagram. When an IPv6 router receives a datagram whose size exceeds the outgoing link's MTU, it generates an ICMPv6 \"packet too big\" error message\n\n\nPath MTU discovery\n uses IPv4 DF bit and its implied IPv6 counterpart. Path MTU discovery is optional with IPv4, but IPv6 implementations all either support path MTU discovery or always send using the minimum MTU. [p55]\n\n\n\n\n\n\nMinimum reassembly buffer size\n: the minimum datagram size that we are guaranteed any implementation must support.\n\n\nIPv4: 576 bytes. We have no idea whether a given destination can accept a 577-byte datagram or not. Therefore, many IPv4 applications that use UDP (e.g., DNS, RIP, TFTP, BOOTP, SNMP) prevent applications from generating IP datagrams that exceed this size.\n\n\nIPv6: 1,500 bytes\n\n\n\n\n\n\nTCP has a \nmaximum segment size\n (MSS) that announces to the peer TCP the maximum amount of TCP data that the peer can send per segment. We saw the MSS option on the SYN segments in \nFigure 2.5\n. The goal of the MSS is to tell the peer the actual value of the reassembly buffer size and to try to avoid fragmentation. The MSS is often set to the interface MTU minus the fixed sizes of the IP and TCP headers. On an Ethernet using IPv4, this would be 1,460, and on an Ethernet using IPv6, this would be 1,440. (The TCP header is 20 bytes for both, but the IPv4 header is 20 bytes and the IPv6 header is 40 bytes.)\n\n\nIPv4: The MSS value in the TCP MSS option is a 16-bit field, limiting the value to 65,535. The maximum amount of TCP data in an IPv4 datagram is 65,495 (65,535 minus the 20-byte IPv4 header and minus the 20-byte TCP header).\n\n\nIPv6: the maximum amount of TCP data in an IPv6 datagram without the jumbo payload option is 65,515 (65,535 minus the 20-byte TCP header). The MSS value of 65,535 is considered a special case that designates \"infinity.\" This value is used only if the jumbo payload option is being used, which requires an MTU that exceeds 65,535.\n\n\n\n\n\n\n\n\nTCP Output\n\n\nEvery TCP socket has a send buffer and we can change the size of this buffer with the \nSO_SNDBUF\n socket option. When an application calls \nwrite\n, the kernel copies all the data from the application buffer into the socket send buffer. If there is insufficient room in the socket buffer for all the application's data, the process is put to sleep. This assumes the normal default of a blocking socket. The kernel will not return from the write until the final byte in the application buffer has been copied into the socket send buffer. Therefore, \nthe successful return from a write to a TCP socket only tells us that we can reuse our application buffer. It does not tell us that either the peer TCP has received the data or that the peer application has received the data.\n\n\nTCP takes the data in the socket send buffer and sends it to the peer TCP.\n The peer TCP must acknowledge the data, and as the ACKs arrive from the peer, only then can our TCP discard the acknowledged data from the socket send buffer. TCP must keep a copy of our data until it is acknowledged by the peer.\n\n\nTCP sends the data to IP in MSS-sized or smaller chunks, prepending its TCP header to each segment, where the MSS is the value announced by the peer, or 536 if the peer did not send an MSS option. IP prepends its header, searches the routing table for the destination IP address, and passes the datagram to the appropriate datalink. IP might perform fragmentation before passing the datagram to the datalink, but one goal of the MSS option is to try to avoid fragmentation and newer implementations also use path MTU discovery. Each datalink has an output queue, and if this queue is full, the packet is discarded and an error is returned up the protocol stack [p58]\n\n\nUDP Output\n\n\nUDP socket doesn't have a socket send buffer, since it does not need to keep a copy of the application's data. It has a send buffer size (which we can change with the \nSO_SNDBUF\n socket option), but this is simply an upper limit on the maximum-sized UDP datagram that can be written to the socket. If an application writes a datagram larger than the socket send buffer size, \nEMSGSIZE\n is returned.\n\n\nUDP simply prepends its 8-byte header and passes the datagram to IP. IP determines the outgoing interface by performing the routing function, and then either adds the datagram to the datalink output queue (if it fits within the MTU) or fragments the datagram and adds each fragment to the datalink output queue (see \nUDP and IP Fragmentation in TCPv1\n). If a UDP application sends large datagrams, there is a much higher probability of (IP) fragmentation than with TCP.\n\n\nStandard Internet Services\n\n\nProtocol Usage by Common Internet Applications", 
            "title": "Chapter 2. The Transport Layer: TCP, UDP, and SCTP"
        }, 
        {
            "location": "/unp/ch3/", 
            "text": "Chapter 3. Sockets Introduction\n\n\nIntroduction\n\n\nThis chapter begins the description of the sockets API.\n\n\nSocket Address Structures\n\n\nThe name of socket address structures begin with \nsockaddr_\n and end with a unique suffix for each protocol suite.\n\n\nIPv4 Socket Address Structure\n\n\nAn IPv4 socket address structure, commonly called an \"Internet socket address structure\", is named \nsockaddr_in\n and is defined by including the \nnetinet/in.h\n header.\n\n\nstruct\n \nin_addr\n \n{\n\n  \nin_addr_t\n   \ns_addr\n;\n           \n/* 32-bit IPv4 address */\n\n                                \n/* network byte ordered */\n\n\n};\n\n\n\nstruct\n \nsockaddr_in\n \n{\n\n  \nuint8_t\n         \nsin_len\n;\n      \n/* length of structure (16) */\n\n  \nsa_family_t\n     \nsin_family\n;\n   \n/* AF_INET */\n\n  \nin_port_t\n       \nsin_port\n;\n     \n/* 16-bit TCP or UDP port number */\n\n                                \n/* network byte ordered */\n\n  \nstruct\n \nin_addr\n  \nsin_addr\n;\n     \n/* 32-bit IPv4 address */\n\n                                \n/* network byte ordered */\n\n  \nchar\n            \nsin_zero\n[\n8\n];\n  \n/* unused */\n\n\n};\n\n\n\n\n\n\n\n\nsin_len\n: the length field. We need never set it and need never examine it.\n\n\nThe four socket functions that pass a socket address structure from the process to the kernel, \nbind\n, \nconnect\n, \nsendto\n, and \nsendmsg\n, all go through the \nsockargs\n function in a Berkeley-derived implementation. This function copies the socket address structure from the process and explicitly sets its \nsin_len\n member to the size of the structure that was passed as an argument to these four functions. The five socket functions that pass a socket address structure from the kernel to the process, \naccept\n, \nrecvfrom\n, \nrecvmsg\n, \ngetpeername\n, and \ngetsockname\n, all set the \nsin_len\n member before returning to the process.\n\n\n\n\n\n\nPOSIX requires only three members in the structure: \nsin_family\n, \nsin_addr\n, and \nsin_port\n. Almost all implementations add the \nsin_zero\n member so that all socket address structures are at least 16 bytes in size.\n\n\nThe \nin_addr_t\n datatype must be an unsigned integer type of at least 32 bits, \nin_port_t\n must be an unsigned integer type of at least 16 bits, and \nsa_family_t\n can be any unsigned integer type. The latter is normally an 8-bit unsigned integer if the implementation supports the length field, or an unsigned 16-bit integer if the length field is not supported.\n\n\nBoth the IPv4 address and the TCP or UDP port number are always stored in the structure in \nnetwork byte order\n.\n\n\nThe \nsin_zero\n member is unused. By convention, we always set the entire structure to 0 before filling it in.\n\n\nSocket address structures are used only on a given host: The structure itself is not communicated between different hosts\n\n\n\n\nGeneric Socket Address Structure\n\n\nA socket address structures is always passed by reference when passed as an argument to any socket functions. But any socket function that takes one of these pointers as an argument must deal with socket address structures from any of the supported protocol families.\n\n\nA generic socket address structure in the \nsys/socket.h\n header:\n\n\nstruct\n \nsockaddr\n \n{\n\n  \nuint8_t\n      \nsa_len\n;\n\n  \nsa_family_t\n  \nsa_family\n;\n    \n/* address family: AF_xxx value */\n\n  \nchar\n         \nsa_data\n[\n14\n];\n  \n/* protocol-specific address */\n\n\n};\n\n\n\n\n\n\nThe socket functions are then defined as taking a pointer to the generic socket address structure, as shown here in the ANSI C function prototype for the \nbind\n function:\n\n\nint\n \nbind\n(\nint\n,\n \nstruct\n \nsockaddr\n \n*\n,\n \nsocklen_t\n);\n\n\n\n\n\n\nThis requires that any calls to these functions must cast the \npointer to the \nprotocol-specific socket address structure\n to be a \npointer to a \ngeneric socket address structure\n.\n\n\nFor example:\n\n\nstruct\n \nsockaddr_in\n  \nserv\n;\n      \n/* IPv4 socket address structure */\n\n\n\n/* fill in serv{} */\n\n\n\nbind\n(\nsockfd\n,\n \n(\nstruct\n \nsockaddr\n \n*\n)\n \nserv\n,\n \nsizeof\n(\nserv\n));\n\n\n\n\n\n\nIn Chapter 1 in our unp.h header\n, we define \nSA\n to be the string \nstruct sockaddr\n, just to shorten the code that we must write to cast these pointers.\n\n\n\n\nFrom an application programmer \u2019s point of view, \nthe only use of these generic socket address structures is to cast pointers to protocol-specific structures.\n\n\nFrom the kernel\u2019s perspective, another reason for using pointers to generic socket address structures as arguments is that the kernel must take the caller\u2019s pointer, cast it to a \nstruct sockaddr *\n, and then look at the value of \nsa_family\n to determine the type of the structure.\n\n\n\n\nIPv6 Socket Address Structure\n\n\nThe IPv6 socket address is defined by including the \nnetinet/in.h\n header:\n\n\nstruct\n \nin6_addr\n \n{\n\n  \nuint8_t\n  \ns6_addr\n[\n16\n];\n          \n/* 128-bit IPv6 address */\n\n                                 \n/* network byte ordered */\n\n\n};\n\n\n\n#define SIN6_LEN      \n/* required for compile-time tests */\n\n\n\nstruct\n \nsockaddr_in6\n \n{\n\n  \nuint8_t\n         \nsin6_len\n;\n      \n/* length of this struct (28) */\n\n  \nsa_family_t\n     \nsin6_family\n;\n   \n/* AF_INET6 */\n\n  \nin_port_t\n       \nsin6_port\n;\n     \n/* transport layer port# */\n\n                                 \n/* network byte ordered */\n\n  \nuint32_t\n        \nsin6_flowinfo\n;\n \n/* flow information, undefined */\n\n  \nstruct\n \nin6_addr\n \nsin6_addr\n;\n     \n/* IPv6 address */\n\n                                 \n/* network byte ordered */\n\n  \nuint32_t\n        \nsin6_scope_id\n;\n \n/* set of interfaces for a scope */\n\n\n};\n\n\n\n\n\n\n\n\nThe \nSIN6_LEN\n constant must be defined if the system supports the length member for socket address structures.\n\n\nThe IPv6 family is \nAF_INET6\n, whereas the IPv4 family is \nAF_INET\n\n\nThe members in this structure are ordered so that if the \nsockaddr_in6\n structure is 64-bit aligned, so is the 128-bit \nsin6_addr\n member.\n\n\nThe \nsin6_flowinfo\n member is divided into two fields:\n\n\nThe low-order 20 bits are the flow label\n\n\nThe high-order 12 bits are reserved\n\n\n\n\n\n\nThe \nsin6_scope_id\n identifies the scope zone in which a scoped address is meaningful, most commonly an interface index for a link-local address\n\n\n\n\nNew Generic Socket Address Structure\n\n\nA new generic socket address structure was defined as part of the IPv6 sockets API, to overcome some of the shortcomings of the existing \nstruct sockaddr\n. Unlike the \nstruct sockaddr\n, the new \nstruct sockaddr_storage\n is large enough to hold any socket address type supported by the system. The \nsockaddr_storage\n structure is defined by including the \nnetinet/in.h\n header:\n\n\nstruct\n \nsockaddr_storage\n \n{\n\n  \nuint8_t\n      \nss_len\n;\n       \n/* length of this struct (implementation dependent) */\n\n  \nsa_family_t\n  \nss_family\n;\n    \n/* address family: AF_xxx value */\n\n  \n/* implementation-dependent elements to provide:\n\n\n   * a) alignment sufficient to fulfill the alignment requirements of\n\n\n   *    all socket address types that the system supports.\n\n\n   * b) enough storage to hold any type of socket address that the\n\n\n   *    system supports.\n\n\n   */\n\n\n};\n\n\n\n\n\n\nThe \nsockaddr_storage\n type provides a generic socket address structure that is different from \nstruct sockaddr\n in two ways:\n\n\n\n\nIf any socket address structures that the system supports have alignment requirements, the \nsockaddr_storage\n provides the strictest alignment requirement.\n\n\nThe \nsockaddr_storage\n is large enough to contain any socket address structure that the system supports.\n\n\n\n\nThe fields of the \nsockaddr_storage\n structure are opaque to the user, except for \nss_family\n and \nss_len\n (if present). The \nsockaddr_storage\n must be cast or copied to the appropriate socket address structure for the address given in \nss_family\n to access any other fields.\n\n\nComparison of Socket Address Structures\n\n\nIn this figure, we assume that:\n\n\n\n\nSocket address structures all contain a one-byte length field \n\n\nThe family field also occupies one byte\n\n\nAny field that must be at least some number of bits is exactly that number of bits\n\n\n\n\n\n\nTo handle variable-length structures, whenever we pass a pointer to a socket address structure as an argument to one of the socket functions, we pass its length as another argument. \n\n\nValue-Result Arguments\n\n\nWhen a socket address structure is passed to any socket function, it is always passed by reference (a pointer to the structure is passed). The length of the structure is also passed as an argument. \n\n\nThe way in which the length is passed depends on which direction the structure is being passed:\n\n\n\n\nFrom the \nprocess to the kernel\n\n\nFrom the \nkernel to the process\n\n\n\n\nFrom process to kernel\n\n\nbind\n, \nconnect\n, and \nsendto\n functions pass a socket address structure from the process to the kernel.\n\n\nArumgents to these functions:\n\n\n\n\nThe pointer to the socket address structure\n\n\nThe integer size of the structure\n\n\n\n\nstruct\n \nsockaddr_in\n \nserv\n;\n\n\n\n/* fill in serv{} */\n\n\nconnect\n \n(\nsockfd\n,\n \n(\nSA\n \n*\n)\n \nserv\n,\n \nsizeof\n(\nserv\n));\n\n\n\n\n\n\n\n\nThe datatype for the size of a socket address structure is actually \nsocklen_t\n and not \nint\n, but the POSIX specification recommends that \nsocklen_t\n be defined as \nuint32_t\n.\n\n\nFrom kernel to process\n\n\naccept\n, \nrecvfrom\n, \ngetsockname\n, and \ngetpeername\n functions pass a socket address structure from the kernel to the process.\n\n\nArguments to these functions:\n\n\n\n\nThe pointer to the socket address structure \n\n\nThe pointer to an integer containing the size of the structure.\n\n\n\n\nstruct\n \nsockaddr_un\n  \ncli\n;\n   \n/* Unix domain */\n\n\nsocklen_t\n  \nlen\n;\n\n\n\nlen\n \n=\n \nsizeof\n(\ncli\n);\n         \n/* len is a value */\n\n\ngetpeername\n(\nunixfd\n,\n \n(\nSA\n \n*\n)\n \ncli\n,\n \nlen\n);\n\n\n/* len may have changed */\n\n\n\n\n\n\n\n\nValue-result argument\n (Figure 3.8): the size changes from an integer to be a pointer to an integer because the size is both \na value when the function is called and a result when the function returns.\n\n\n\n\nAs a \nvalue\n: it tells the kernel the size of the structure so that the kernel does not write past the end of the structure when filling it in\n\n\nAs a \nresult\n: it tells the process how much information the kernel actually stored in the structure\n\n\n\n\nFor two other functions that pass socket address structures, \nrecvmsg\n and \nsendmsg\n, the length field is not a function argument but a structure member.\n\n\nIf the socket address structure is fixed-length, the value returned by the kernel will always be that fixed size: 16 for an IPv4 \nsockaddr_in\n and 28 for an IPv6 \nsockaddr_in6\n. But with a variable-length socket address structure (e.g., a Unix domain \nsockaddr_un\n), the value returned can be less than the maximum size of the structure.\n\n\nThough the most common example of a value-result argument is the length of a returned socket address structure, we will encounter other value-result arguments in this text:\n\n\n\n\nThe middle three arguments for the \nselect\n function (Section 6.3)\n\n\nThe length argument for the \ngetsockopt\n function (Section 7.2)\n\n\nThe \nmsg_namelen\n and \nmsg_controllen\n members of the \nmsghdr\n structure, when used with \nrecvmsg\n (Section 14.5)\n\n\nThe \nifc_len\n member of the \nifconf\n structure (Figure 17.2)\n\n\nThe first of the two length arguments for the \nsysctl\n function (Section 18.4)\n\n\n\n\nByte Ordering Functions\n\n\nFor a 16-bit integer that is made up of 2 bytes, there are two ways to store the two bytes in memory:\n\n\n\n\nLittle-endian\n order: low-order byte is at the starting address.\n\n\nBig-endian\n order: high-order byte is at the starting address.\n\n\n\n\n\n\nThe figure shows the most significant bit (MSB) as the leftmost bit of the 16-bit value and the least significant bit (LSB) as the rightmost bit.\n\n\nThe terms \"little-endian\" and \"big-endian\" indicate which end of the multibyte value, the little end or the big end, is stored at the starting address of the value.\n\n\nHost byte order\n refer to the byte ordering used by a given system. The program below prints the host byte order:\n\n\n\n\nbyteorder.c\n\n\n\n\n\n\n\nWe store the two-byte value \n0x0102\n in the short integer and then look at the two consecutive bytes, \nc[0]\n (the address \nA\n) and \nc[1]\n (the address \nA+1\n) to determine the byte order.\n\n\nThe string \nCPU_VENDOR_OS\n is determined by the GNU \nautoconf\n program.\n\n\nfreebsd4 % byteorder\ni386-unknown-freebsd4.8: little-endian\n\nmacosx % byteorder\npowerpc-apple-darwin6.6: big-endian\n\nfreebsd5 % byteorder\nsparc64-unknown-freebsd5.1: big-endian\n\naix % byteorder\npowerpc-ibm-aix5.1.0.0: big-endian\n\nhpux % byteorder\nhppa1.1-hp-hpux11.11: big-endian\n\nlinux % byteorder\ni586-pc-linux-gnu: little-endian\n\nsolaris % byteorder\nsparc-sun-solaris2.9: big-endian\n\n\n\n\n\nNetworking protocols must specify a \nnetwork byte order\n. The sending protocol stack and the receiving protocol stack must agree on the order in which the bytes of these multibyte fields will be transmitted. \nThe Internet protocols use big-endian byte ordering for these multibyte integers.\n\n\nBut, both history and the POSIX specification say that certain fields in the socket address structures must be maintained in network byte order. We use the following four functions to convert between these two byte orders:\n\n\n\n\n\n\n\nh\n stands for \nhost\n\n\nn\n stands for \nnetwork\n\n\ns\n stands for \nshort\n (16-bit value, e.g. TCP or UDP port number)\n\n\nl\n stands for \nlong\n (32-bit value, e.g. IPv4 address)\n\n\n\n\nWhen using these functions, we do not care about the actual values (big-endian or little-endian) for the host byte order and the network byte order. What we must do is call the appropriate function to convert a given value between the host and network byte order. On those systems that have the same byte ordering as the Internet protocols (big-endian), these four functions are usually defined as null macros.\n\n\nWe use the term \"byte\" to mean an 8-bit quantity since almost all current computer systems use 8-bit bytes. Most Internet standards use the term \noctet\n instead of byte to mean an 8-bit quantity.\n\n\nBit ordering is an important convention in Internet standards, such as the the first 32 bits of the IPv4 header from RFC 791:\n\n\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL |Type of Service|           Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n\n\n\nThis represents four bytes in the order in which they appear on the wire; the leftmost bit is the most significant. However, the numbering starts with zero assigned to the most significant bit. \n\n\nByte Manipulation Functions\n\n\nTwo types functions differ in whether they deal with null-terminated C strings:\n\n\n\n\nThe functions that operate on multibyte fields, without interpreting the data, and without assuming that the data is a null-terminated C string. These types of functions deal with socket address structures to manipulate fields such as IP addresses, which can contain bytes of 0, but are not C character strings. \n\n\nThe functions whose names begin with \nb\n (for byte) (from 4.2BSD)\n\n\nThe functions whose names begin with \nmem\n (for memory) (from ANSI C)\n\n\n\n\n\n\nThe functions that deal with null-terminated C character strings (beginning with \nstr\n (for string), defined by including the \nstring.h\n header)\n\n\n\n\n\n\n\nThe memory pointed to by the \nconst\n pointer is read but not modified by the function.\n\n\n\n\nbzero\n sets the specified number of bytes to 0 in the destination. We often use this function to initialize a socket address structure to 0.\n\n\nbcopy\n moves the specified number of bytes from the source to the destination. \n\n\nbcmp\n compares two arbitrary byte strings. The return value is zero if the two byte strings are identical; otherwise, it is nonzero\n\n\n\n\n\n\n\n\n\nmemset\n sets the specified number of bytes to the value \nc\n in the destination\n\n\nmemcpy\n is similar to \nbcopy\n, but the order of the two pointer arguments is swapped\n\n\nmemcmp\n compares two arbitrary byte strings \n\n\n\n\nNote:\n\n\n\n\n\n\nOne way to remember the order of the two pointers for \nmemcpy\n is to remember that they are written in the same left-to-right order as an assignment statement in C:\n\n\ndest = src;\n\n\n\n\n\n\n\n\n\nOne way to remember the order of the final two arguments to \nmemset\n is to realize that all of the ANSI C \nmemXXX\n functions require a length argument, and it is always the final argument. The comparison is done assuming the two unequal bytes are \nunsigned chars\n.\n\n\n\n\n\n\ninet_aton\n, \ninet_addr\n, and \ninet_ntoa\n Functions\n\n\nThese functions convert Internet addresses between ASCII strings (what humans prefer to use) and network byte ordered binary values (values that are stored in socket address structures).\n\n\n\n\n\n\n\ninet_aton\n: converts the C character string pointed to by \nstrptr\n into its 32-bit binary network byte ordered value, which is stored through the pointer \naddrptr\n\n\ninet_addr\n: does the same conversion, returning the 32-bit binary network byte ordered value as the return value. It is deprecated and any new code should use \ninet_aton\n instead\n\n\ninet_ntoa\n: converts a 32-bit binary network byte ordered IPv4 address into its corresponding dotted-decimal string.\n\n\nThe string pointed to by the return value of the function resides in static memory.\n This means the function is not reentrant, which we will discuss in Section 11.18.\n\n\nThis function takes a structure as its argument, not a pointer to a structure. (Functions that take actual structures as arguments are rare. It is more common to pass a pointer to the structure.)\n\n\n\n\n\n\n\n\ninet_pton\n and \ninet_ntop\n Functions\n\n\nThese two functions are new with IPv6 and work with both IPv4 and IPv6 addresses. We use these two functions throughout the text. The letters \"p\" and \"n\" stand for \npresentation\n and \nnumeric\n. The presentation format for an address is often an ASCII string and the numeric format is the binary value that goes into a socket address structure.\n\n\n\n\n\nArguments:\n\n\n\n\nfamily\n: is either \nAF_INET\n or \nAF_INET6\n. If \nfamily\n is not supported, both functions return an error with \nerrno\n set to \nEAFNOSUPPORT\n.\n\n\n\n\nFunctions:\n\n\n\n\ninet_pton\n: converts the string pointed to by \nstrptr\n, storing the binary result through the pointer \naddrptr\n. If successful, the return value is 1. If the input string is not a valid presentation format for the specified \nfamily\n, 0 is returned.\n\n\ninet_ntop\n does the reverse conversion, from numeric (\naddrptr\n) to presentation (\nstrptr\n).\n\n\nlen\n argument is the size of the destination. To help specify this size, the following two definitions are defined by including the \nnetinet/in.h\n header. \n\n\nIf \nlen\n is too small to hold the resulting presentation format, including the terminating null, a null pointer is returned and \nerrno\n is set to \nENOSPC\n.\n\n\nThe \nstrptr\n argument to \ninet_ntop\n cannot be a null pointer. The caller must allocate memory for the destination and specify its size. On success, this pointer is the return value of the function.\n\n\n\n\n\n\n\n\nSize definitions in \nnetinet/in.h\n header for the \nlen\n argument:\n\n\n#define INET_ADDRSTRLEN       16       \n/* for IPv4 dotted-decimal */\n\n\n#define INET6_ADDRSTRLEN      46       \n/* for IPv6 hex string */\n\n\n\n\n\n\nThe following figure summarizes the five functions on address conversion functions:\n\n\n\n\nEven if your system does not yet include support for IPv6, you can start using these newer functions by replacing calls of the form.\n\n\nReplacing \ninet_addr\n to \ninet_pton\n\n\nReplace:\n\n\nfoo\n.\nsin_addr\n.\ns_addr\n \n=\n \ninet_addr\n(\ncp\n);\n\n\n\n\n\n\nwith\n\n\ninet_pton\n(\nAF_INET\n,\n \ncp\n,\n \nfoo\n.\nsin_addr\n);\n\n\n\n\n\n\nReplacing \ninet_ntoa\n to \ninet_ntop\n\n\nReplace:\n\n\nptr = inet_ntoa(foo.sin_addr);\n\n\n\n\n\nwith\n\n\nchar\n \nstr\n[\nINET_ADDRSTRLEN\n];\n\n\nptr\n \n=\n \ninet_ntop\n(\nAF_INET\n,\n \nfoo\n.\nsin_addr\n,\n \nstr\n,\n \nsizeof\n(\nstr\n));\n\n\n\n\n\n\nSimple definitions of \ninet_pton\n and \ninet_ntop\n that support IPv4\n\n\n\n\nlibfree/inet_pton_ipv4.c\n\n\n\n\nint\n\n\ninet_pton\n(\nint\n \nfamily\n,\n \nconst\n \nchar\n \n*\nstrptr\n,\n \nvoid\n \n*\naddrptr\n)\n\n\n{\n\n    \nif\n \n(\nfamily\n \n==\n \nAF_INET\n)\n \n{\n\n        \nstruct\n \nin_addr\n  \nin_val\n;\n\n\n        \nif\n \n(\ninet_aton\n(\nstrptr\n,\n \nin_val\n))\n \n{\n\n            \nmemcpy\n(\naddrptr\n,\n \nin_val\n,\n \nsizeof\n(\nstruct\n \nin_addr\n));\n\n            \nreturn\n \n(\n1\n);\n\n        \n}\n\n        \nreturn\n(\n0\n);\n\n    \n}\n\n    \nerrno\n \n=\n \nEAFNOSUPPORT\n;\n\n    \nreturn\n \n(\n-\n1\n);\n\n\n}\n\n\n\n\n\n\n\n\ninet_ntop_ipv4.c\n\n\n\n\nconst\n \nchar\n \n*\n\n\ninet_ntop\n(\nint\n \nfamily\n,\n \nconst\n \nvoid\n \n*\naddrptr\n,\n \nchar\n \n*\nstrptr\n,\n \nsize_t\n \nlen\n)\n\n\n{\n\n    \nconst\n \nu_char\n \n*\np\n \n=\n \n(\nconst\n \nu_char\n \n*\n)\n \naddrptr\n;\n\n\n    \nif\n \n(\nfamily\n \n==\n \nAF_INET\n)\n \n{\n\n        \nchar\n    \ntemp\n[\nINET_ADDRSTRLEN\n];\n\n\n        \nsnprintf\n(\ntemp\n,\n \nsizeof\n(\ntemp\n),\n \n%d.%d.%d.%d\n,\n\n                 \np\n[\n0\n],\n \np\n[\n1\n],\n \np\n[\n2\n],\n \np\n[\n3\n]);\n\n        \nif\n \n(\nstrlen\n(\ntemp\n)\n \n=\n \nlen\n)\n \n{\n\n            \nerrno\n \n=\n \nENOSPC\n;\n\n            \nreturn\n \n(\nNULL\n);\n\n        \n}\n\n        \nstrcpy\n(\nstrptr\n,\n \ntemp\n);\n\n        \nreturn\n \n(\nstrptr\n);\n\n    \n}\n\n    \nerrno\n \n=\n \nEAFNOSUPPORT\n;\n\n    \nreturn\n \n(\nNULL\n);\n\n\n}\n\n\n\n\n\n\nsock_ntop\n and Related Functions\n\n\nA basic problem with \ninet_ntop\n is that it requires the caller to pass a pointer to a binary address. This address is normally contained in a socket address structure, requiring the caller to know the format of the structure and the address family.\n\n\nFor IPv4:\n\n\nstruct\n \nsockaddr_in\n   \naddr\n;\n\n\ninet_ntop\n(\nAF_INET\n,\n \naddr\n.\nsin_addr\n,\n \nstr\n,\n \nsizeof\n(\nstr\n));\n\n\n\n\n\n\nFor IPv6:\n\n\nstruct\n \nsockaddr_in6\n   \naddr6\n;\n\n\ninet_ntop\n(\nAF_INET6\n,\n \naddr6\n.\nsin6_addr\n,\n \nstr\n,\n \nsizeof\n(\nstr\n));\n\n\n\n\n\n\nThis (above) makes our code protocol-dependent.\n\n\nTo solve this, we will write our own function named \nsock_ntop\n that takes a pointer to a socket address structure, looks inside the structure, and calls the appropriate function to return the presentation format of the address.\n\n\n\n\n\nsockaddr\n points to a socket address structure whose length is \naddrlen\n. The function uses its own static buffer to hold the result and a pointer to this buffer is the return value. Notice that \nusing static storage for the result prevents the function from being \nre-entrant\n or \nthread-safe\n.\n\n\nPresentation format of \nsock_ntop\n\n\n\n\nIPv4: dotted-decimal form, followed by a terminator (colon), followed by the decimal port number, followed by a null character\n\n\nThe buffer size must be at least \nINET_ADDRSTRLEN\n plus 6 bytes for IPv4 (16 + 6 = 22)\n\n\n\n\n\n\nIPv6: hex string form of an IPv6 address surrounded by brackets, followed by a terminator (colon), followed by the decimal port number, followed by a\nnull character. Hence, the buffer size must be at least INET_ADDRSTRLEN plus 6 bytes\n\n\nThe buffer size must be at least \nINET6_ADDRSTRLEN\n plus 8 bytes for IPv6 (46 + 8 = 54)\n\n\n\n\n\n\n\n\nsock_ntop\n definition\n\n\n\n\nlib/sock_ntop.c\n\n\n\n\nThe source code for only the \nAF_INET\n case:\n\n\nchar\n \n*\n\n\nsock_ntop\n(\nconst\n \nstruct\n \nsockaddr\n \n*\nsa\n,\n \nsocklen_t\n \nsalen\n)\n\n\n{\n\n    \nchar\n        \nportstr\n[\n8\n];\n\n    \nstatic\n \nchar\n \nstr\n[\n128\n];\n       \n/* Unix domain is largest */\n\n\n    \nswitch\n \n(\nsa\n-\nsa_family\n)\n \n{\n\n    \ncase\n \nAF_INET\n:\n \n{\n\n        \nstruct\n \nsockaddr_in\n  \n*\nsin\n \n=\n \n(\nstruct\n \nsockaddr_in\n \n*\n)\n \nsa\n;\n\n\n        \nif\n \n(\ninet_ntop\n(\nAF_INET\n,\n \nsin\n-\nsin_addr\n,\n \nstr\n,\n \nsizeof\n(\nstr\n))\n \n==\n \nNULL\n)\n\n            \nreturn\n(\nNULL\n);\n\n        \nif\n \n(\nntohs\n(\nsin\n-\nsin_port\n)\n \n!=\n \n0\n)\n \n{\n\n            \nsnprintf\n(\nportstr\n,\n \nsizeof\n(\nportstr\n),\n \n:%d\n,\n \nntohs\n(\nsin\n-\nsin_port\n));\n\n            \nstrcat\n(\nstr\n,\n \nportstr\n);\n\n        \n}\n\n        \nreturn\n(\nstr\n);\n\n    \n}\n\n  \n/* ... */\n\n\n\n\n\n\nRelated functions\n\n\nThere are a few other functions that we define to operate on socket address structures,\nand these will simplify the portability of our code between IPv4 and IPv6.\n\n\n\n\n\n\n\nsock_bind_wild\n: binds the wildcard address and an ephemeral port to a socket. \n\n\nsock_cmp_addr\n: compares the address portion of two socket address structures.\n\n\nsock_cmp_port\n: compares the port number of two socket address structures.\n\n\nsock_get_port\n: returns just the port number.\n\n\nsock_ntop_host\n: converts just the host portion of a socket address structure to presentation format (not the port number)\n\n\nsock_set_addr\n: sets just the address portion of a socket address structure to the value pointed to by \nptr\n.\n\n\nsock_set_port\n: sets just the port number of a socket address structure.\n\n\nsock_set_wild\n: sets the address portion of a socket address structure to the wildcard\n\n\n\n\nreadn\n, \nwriten\n, and \nreadline\n Functions\n\n\nStream sockets (e.g., TCP sockets) exhibit a behavior with the \nread\n and \nwrite\n functions that differs from normal file I/O. A \nread\n or \nwrite\n on a stream socket might input or output fewer bytes than requested, but this is not an error condition. \nThe reason is that buffer limits might be reached for the socket in the kernel. All that is required to input or output the remaining bytes is for the caller to invoke the \nread\n or \nwrite\n function again.\n This scenario is always a possibility on a stream socket with \nread\n, but is normally seen with \nwrite\n only if the socket is nonblocking.\n\n\n\n\n\n\n\nlib/readn.c\n\n\nlib/writen.c\n\n\ntest/readline1.c\n\n\nlib/readline.c\n\n\n\n\n#include    \nunp.h\n\n\n\nssize_t\n                     \n/* Read \nn\n bytes from a descriptor. */\n\n\nreadn\n(\nint\n \nfd\n,\n \nvoid\n \n*\nvptr\n,\n \nsize_t\n \nn\n)\n\n\n{\n\n    \nsize_t\n  \nnleft\n;\n\n    \nssize_t\n \nnread\n;\n\n    \nchar\n    \n*\nptr\n;\n\n\n    \nptr\n \n=\n \nvptr\n;\n\n    \nnleft\n \n=\n \nn\n;\n\n    \nwhile\n \n(\nnleft\n \n \n0\n)\n \n{\n\n        \nif\n \n(\n \n(\nnread\n \n=\n \nread\n(\nfd\n,\n \nptr\n,\n \nnleft\n))\n \n \n0\n)\n \n{\n\n            \nif\n \n(\nerrno\n \n==\n \nEINTR\n)\n\n                \nnread\n \n=\n \n0\n;\n      \n/* and call read() again */\n\n            \nelse\n\n                \nreturn\n(\n-\n1\n);\n\n        \n}\n \nelse\n \nif\n \n(\nnread\n \n==\n \n0\n)\n\n            \nbreak\n;\n              \n/* EOF */\n\n\n        \nnleft\n \n-=\n \nnread\n;\n\n        \nptr\n   \n+=\n \nnread\n;\n\n    \n}\n\n    \nreturn\n(\nn\n \n-\n \nnleft\n);\n      \n/* return \n= 0 */\n\n\n}\n\n\n\n\n\n\nOur three functions look for the error \nEINTR\n (the system call was interrupted by a caught signal) and continue reading or writing if the error occurs. We handle the error here, instead of forcing the caller to call \nreadn\n or \nwriten\n again, since the purpose of these three functions is to prevent the caller from having to handle a short count.\n\n\nIn Section 14.3, we will mention that the \nMSG_WAITALL\n flag can be used with the \nrecv\n function to replace the need for a separate \nreadn\n function.\n\n\nIn \ntest/readline1.c\n, our \nreadline\n function calls the system\u2019s \nread\n function once for every byte of data. This is very inefficient, and why we\u2019ve commented the code to state it is \"PAINFULLY SLOW\".\n\n\nOur advice is to think in terms of buffers and not lines. Write your code to read buffers of data, and if a line is expected, check the buffer to see if it contains that line.\n\n\nlib/readline.c\n shows a faster version of the readline function, which uses its own buffering rather than stdio buffering. Most importantly, the state of readline\u2019s internal buffer is exposed, so callers have visibility into exactly what has been received.\n\n\nIn \nlib/readline.c\n, the internal function \nmy_read\n reads up to \nMAXLINE\n characters at a time and then returns them, one at a time. The only change to the \nreadline\n function itself is to call \nmy_read\n instead of read. A new function, \nreadlinebuf\n, exposes the internal buffer state so that callers can check and see if more data was received beyond a single line.\n\n\nUnfortunately, by using \nstatic\n variables in \nreadline.c\n to maintain the state information across successive calls, the functions are not \nre-entrant\n or \nthread-safe\n.", 
            "title": "Chapter 3. Sockets Introduction"
        }, 
        {
            "location": "/unp/ch4/", 
            "text": "Chapter 4. Elementary TCP Sockets", 
            "title": "Chapter 4. Elementary TCP Sockets"
        }, 
        {
            "location": "/unp/ch5/", 
            "text": "Chapter 5. TCP Client/Server Example\n\n\nIntroduction\n\n\nWe will now use the elementary functions from the previous chapter to write a complete TCP client/server example. Our simple example is an echo server that performs the following steps:\n\n\n\n\nThe client reads a line of text from its standard input and writes the line to the server.\n\n\nThe server reads the line from its network input and echoes the line back to the client.\n\n\nThe client reads the echoed line and prints it on its standard output.\n\n\n\n\nThe figure below depcits this simple client/server:\n\n\n\n\nDespite two arrows between the client and server in the above figure, it is really a \nfull-duplex\n TCP connection. \nfgets\n and \nfputs\n functions are from the standard I/O library. \nwriten\n and \nreadline\n functions were shown in \nSection 3.9\n.\n\n\nThe echo client/server is a valid, simple example of a network application. To expand this example into your own application, all you need to do is change what the server does with the input it receives from its clients.\n\n\nBesides running the client/server in normal mode (type in a line and watch it echo), we examine lots of boundary conditions:\n\n\n\n\nWhat happens when the client and server are started?\n\n\nWhat happens when the client terminates normally?\n\n\nWhat happens to the client if the server process terminates before the client is done?\n\n\nWhat happens to the client if the server host crashes?\n\n\n\n\nIn all these examples, we have \"hard-coded\" protocol-specific constants such as addresses and ports. There are two reasons for this:\n\n\n\n\nWe must understand exactly what needs to be stored in the protocol-specific address structures\n\n\nWe have not yet covered the library functions that can make this more portable\n\n\n\n\nTCP Echo Server: \nmain\n Function\n\n\nOur TCP client and server follow the flow of functions that we diagrammed in \nFigure 4.1\n. The below code is the concurrent server program:\n\n\n\n\ntcpcliserv/tcpserv01.c\n\n\n\n\n#include    \nunp.h\n\n\n\nint\n\n\nmain\n(\nint\n \nargc\n,\n \nchar\n \n**\nargv\n)\n\n\n{\n\n    \nint\n                 \nlistenfd\n,\n \nconnfd\n;\n\n    \npid_t\n               \nchildpid\n;\n\n    \nsocklen_t\n           \nclilen\n;\n\n    \nstruct\n \nsockaddr_in\n  \ncliaddr\n,\n \nservaddr\n;\n\n\n    \nlistenfd\n \n=\n \nSocket\n(\nAF_INET\n,\n \nSOCK_STREAM\n,\n \n0\n);\n\n\n    \nbzero\n(\nservaddr\n,\n \nsizeof\n(\nservaddr\n));\n\n    \nservaddr\n.\nsin_family\n      \n=\n \nAF_INET\n;\n\n    \nservaddr\n.\nsin_addr\n.\ns_addr\n \n=\n \nhtonl\n(\nINADDR_ANY\n);\n\n    \nservaddr\n.\nsin_port\n        \n=\n \nhtons\n(\nSERV_PORT\n);\n\n\n    \nBind\n(\nlistenfd\n,\n \n(\nSA\n \n*\n)\n \nservaddr\n,\n \nsizeof\n(\nservaddr\n));\n\n\n    \nListen\n(\nlistenfd\n,\n \nLISTENQ\n);\n\n\n    \nfor\n \n(\n \n;\n \n;\n \n)\n \n{\n\n        \nclilen\n \n=\n \nsizeof\n(\ncliaddr\n);\n\n        \nconnfd\n \n=\n \nAccept\n(\nlistenfd\n,\n \n(\nSA\n \n*\n)\n \ncliaddr\n,\n \nclilen\n);\n\n\n        \nif\n \n(\n \n(\nchildpid\n \n=\n \nFork\n())\n \n==\n \n0\n)\n \n{\n    \n/* child process */\n\n            \nClose\n(\nlistenfd\n);\n    \n/* close listening socket */\n\n            \nstr_echo\n(\nconnfd\n);\n   \n/* process the request */\n\n            \nexit\n(\n0\n);\n\n        \n}\n\n        \nClose\n(\nconnfd\n);\n          \n/* parent closes connected socket */\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe above code does the following:\n\n\n\n\nCreate socket, bind server's well-known port\n\n\nA TCP socket is created.\n\n\nAn Internet socket address structure is filled in with the wildcard address (\nINADDR_ANY\n) and the server's well-known port (\nSERV_PORT\n, which is defined as 9877 in our \nunp.h\n header). Binding the wildcard address tells the system that we will accept a connection destined for any local interface, in case the system is multihomed. Our choice of the TCP port number is based on \nFigure 2.10\n in \nSection 2.9\n. It should be greater than 1023 (we do not need a reserved port), greater than 5000 (to avoid conflict with the ephemeral ports allocated by many Berkeley-derived implementations), less than 49152 (to avoid conflict with the \"correct\" range of ephemeral ports), and it should not conflict with any registered port.  [p122]\n\n\nThe socket is converted into a listening socket by \nlisten\n.\n\n\n\n\n\n\nWait for client connection to complete\n\n\nThe server blocks in the call to \naccept\n, waiting for a client connection to complete.\n\n\n\n\n\n\nConcurrent server\n\n\nFor each client, \nfork\n spawns a child, and the child handles the new client. The child closes the listening socket and the parent closes the connected socket. (\nSection 4.8\n)\n\n\n\n\n\n\n\n\nTCP Echo Server: \nstr_echo\n Function\n\n\nThe function \nstr_echo\n performs the server processing for each client: It reads data from the client and echoes it back to the client.\n\n\n\n\nlib/str_echo.c\n\n\n\n\n#include    \nunp.h\n\n\n\nvoid\n\n\nstr_echo\n(\nint\n \nsockfd\n)\n\n\n{\n\n    \nssize_t\n     \nn\n;\n\n    \nchar\n        \nbuf\n[\nMAXLINE\n];\n\n\n\nagain\n:\n\n    \nwhile\n \n(\n \n(\nn\n \n=\n \nread\n(\nsockfd\n,\n \nbuf\n,\n \nMAXLINE\n))\n \n \n0\n)\n\n        \nWriten\n(\nsockfd\n,\n \nbuf\n,\n \nn\n);\n\n\n    \nif\n \n(\nn\n \n \n0\n \n \nerrno\n \n==\n \nEINTR\n)\n\n        \ngoto\n \nagain\n;\n\n    \nelse\n \nif\n \n(\nn\n \n \n0\n)\n\n        \nerr_sys\n(\nstr_echo: read error\n);\n\n\n}\n\n\n\n\n\n\nThe above code does the following:\n\n\n\n\nRead a buffer and echo the buffer\n\n\nread\n reads data from the socket and the line is echoed back to the client by \nwriten\n. If the client closes the connection (the normal scenario), \nthe receipt of the client's FIN causes the child's read to return 0.\n This causes the \nstr_echo\n function to return, which terminates the child.\n\n\n\n\n\n\n\n\nTCP Echo Client: \nmain\n Function\n\n\n\n\ntcpcliserv/tcpcli01.c\n\n\n\n\n#include    \nunp.h\n\n\n\nint\n\n\nmain\n(\nint\n \nargc\n,\n \nchar\n \n**\nargv\n)\n\n\n{\n\n    \nint\n                 \nsockfd\n;\n\n    \nstruct\n \nsockaddr_in\n  \nservaddr\n;\n\n\n    \nif\n \n(\nargc\n \n!=\n \n2\n)\n\n        \nerr_quit\n(\nusage: tcpcli \nIPaddress\n);\n\n\n    \nsockfd\n \n=\n \nSocket\n(\nAF_INET\n,\n \nSOCK_STREAM\n,\n \n0\n);\n\n\n    \nbzero\n(\nservaddr\n,\n \nsizeof\n(\nservaddr\n));\n\n    \nservaddr\n.\nsin_family\n \n=\n \nAF_INET\n;\n\n    \nservaddr\n.\nsin_port\n \n=\n \nhtons\n(\nSERV_PORT\n);\n\n    \nInet_pton\n(\nAF_INET\n,\n \nargv\n[\n1\n],\n \nservaddr\n.\nsin_addr\n);\n\n\n    \nConnect\n(\nsockfd\n,\n \n(\nSA\n \n*\n)\n \nservaddr\n,\n \nsizeof\n(\nservaddr\n));\n\n\n    \nstr_cli\n(\nstdin\n,\n \nsockfd\n);\n     \n/* do it all */\n\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\nThe above code does the following:\n\n\n\n\nCreate socket, fill in Internet socket address structure\n\n\nA TCP socket is created and an Internet socket address structure is filled in with the server's IP address and port number. The server's IP address is taken from the command-line argument and the server's well-known port (\nSERV_PORT\n) is from our \nunp.h\n header.\n\n\n\n\n\n\nConnect to server\n\n\nconnect\n establishes the connection with the server. The function \nstr_cli\n handles the rest of the client processing.\n\n\n\n\n\n\n\n\nTCP Echo Client: \nstr_cli\n Function\n\n\nThe \nstr_cli\n function handles the client processing loop: It reads a line of text from standard input, writes it to the server, reads back the server's echo of the line, and outputs the echoed line to standard output.\n\n\n\n\nlib/str_cli.c\n\n\n\n\n#include    \nunp.h\n\n\n\nvoid\n\n\nstr_cli\n(\nFILE\n \n*\nfp\n,\n \nint\n \nsockfd\n)\n\n\n{\n\n    \nchar\n    \nsendline\n[\nMAXLINE\n],\n \nrecvline\n[\nMAXLINE\n];\n\n\n    \nwhile\n \n(\nFgets\n(\nsendline\n,\n \nMAXLINE\n,\n \nfp\n)\n \n!=\n \nNULL\n)\n \n{\n\n\n        \nWriten\n(\nsockfd\n,\n \nsendline\n,\n \nstrlen\n(\nsendline\n));\n\n\n        \nif\n \n(\nReadline\n(\nsockfd\n,\n \nrecvline\n,\n \nMAXLINE\n)\n \n==\n \n0\n)\n\n            \nerr_quit\n(\nstr_cli: server terminated prematurely\n);\n\n\n        \nFputs\n(\nrecvline\n,\n \nstdout\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe above code does the following:\n\n\n\n\nRead a line, write to server\n\n\nfgets\n reads a line of text and \nwriten\n sends the line to the server.\n\n\n\n\n\n\nRead echoed line from server, write to standard output\n\n\nreadline\n reads the line echoed back from the server and \nfputs\n writes it to standard output.\n\n\n\n\n\n\nReturn to main\n\n\nThe loop terminates when \nfgets\n returns a null pointer, which occurs when it encounters either an end-of-file (EOF) or an error. Our \nFgets\n wrapper function checks for an error and aborts if one occurs, so \nFgets\n returns a null pointer only when an end-of-file is encountered.\n\n\n\n\nNormal Startup\n\n\nAlthough the TCP example is small, it is essential that we understand:\n\n\n\n\nHow the client and server start and end,\n\n\nWhat happens when something goes wrong:\n\n\nthe client host crashes,\n\n\nthe client process crashes,\n\n\nnetwork connectivity is lost\n\n\n\n\n\n\n\n\nOnly by understanding these boundary conditions, and their interaction with the TCP/IP protocols, can we write robust clients and servers that can handle these conditions.\n\n\nStart the server in the background\n\n\nFirst, we start the server in the background:\n\n\nlinux % tcpserv01 \n\n[1] 17870\n\n\n\n\n\nWhen the server starts, it calls \nsocket\n, \nbind\n, \nlisten\n, and \naccept\n, blocking in the call to accept.\n\n\nRun \nnetstat\n\n\nBefore starting the client, we run the \nnetstat\n program to verify the state of the server's listening socket.\n\n\nlinux % netstat -a\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address       Foreign Address      State\ntcp        0      0 *:9877              *:*                  LISTEN\n\n\n\n\n\nThis command shows the status of all sockets on the system. We must specify the \n-a\n flag to see listening sockets.\n\n\nIn the output, a socket is in the LISTEN state with a wildcard for the local IP address and a local port of 9877. \nnetstat\n prints an asterisk for an IP address of 0 (\nINADDR_ANY\n, the wildcard) or for a port of 0.\n\n\nStart the client on the same host\n\n\nWe then start the client on the same host, specifying the server's IP address of 127.0.0.1 (the loopback address). We could have also specified the server's normal (nonloopback) IP address.\n\n\nlinux % tcpcli01 127.0.0.1\n\n\n\n\n\nThe client calls \nsocket\n, and \nconnect\n which causes TCP's three-way handshake. When the three-way handshake completes, \nconnect\n returns in the client and \naccept\n returns in the server. The connection is established. The following steps then take place:\n\n\n\n\nThe client calls \nstr_cli\n, which will block in the call to \nfgets\n.\n\n\nWhen \naccept\n returns in the server, it calls \nfork\n and the child calls \nstr_echo\n. This function calls \nreadline\n, which calls \nread\n, which blocks while waiting for a line to be sent from the client.\n\n\nThe server parent, on the other hand, calls \naccept\n again, and blocks while waiting for the next client connection.\n\n\n\n\nNotes from the previous three steps:\n\n\n\n\nAll three processes are asleep (blocked): client, server parent, and server child.\n\n\nWe purposely list the client step first, and then the server steps when the three-way handshake completes. This is because \naccept\n returns one-half of the RTT after \nconnect\n returns (see \nFigure 2.5\n):\n\n\nOn the client side, \nconnect\n returns when the second segment of the handshake is received\n\n\nOn the server side, \naccept\n does not return until the third segment of the handshake is received\n\n\n\n\n\n\n\n\nRun \nnetstat\n after connection completes\n\n\nSince we are running the client and server on the same host, \nnetstat\n now shows two additional lines of output, corresponding to the TCP connection:\n\n\nlinux % netstat -a\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address           Foreign Address          State\ntcp        0      0 local host:9877         localhost:42758          ESTABLISHED\ntcp        0      0 local host:42758        localhost:9877           ESTABLISHED\ntcp        0      0 *:9877                  *:*                      LISTEN\n\n\n\n\n\n\n\nThe first ESTABLISHED line corresponds to the server child's socket, since the local port is 9877.\n\n\nThe second ESTABLISHED lines is the client's socket, since the local port is 42758\n\n\n\n\nIf we were running the client and server on different hosts, the client host would display only the client's socket, and the server host would display only the two server sockets.\n\n\nRun \nps\n to check process status and relationship\n\n\nlinux % ps -t pts/6 -o pid,ppid,tty,stat,args,wchan\n  PID  PPID TT       STAT COMMAND          WCHAN\n22038 22036 pts/6    S    -bash            wait4\n17870 22038 pts/6    S    ./tcpserv01      wait_for_connect\n19315 17870 pts/6    S    ./tcpserv01      tcp_data_wait\n19314 22038 pts/6    S    ./tcpcli01 127.0 read_chan\n\n\n\n\n\nVery specific arguments to \nps\n are used:\n\n\n\n\nThe TT column (\npts/6\n): client and server are run from the same window, pseudo-terminal number 6.\n\n\nThe PID and PPID columns show the parent and child relationships.\n\n\nThe first \ntcpserv01\n line is the parent and the second tcpserv01 line is the child since the PPID of the child is the parent's PID.\n\n\nThe PPID of the parent is the shell (bash).\n\n\n\n\n\n\nThe STAT column for all three of our network processes is \"S\", meaning the process is sleeping (waiting for something).\n\n\nThe WCHAN column specifies the condition when a process is asleep.\n\n\nLinux prints \nwait_for_connect\n when a process is blocked in either \naccept\n or \nconnect\n, \ntcp_data_wait\n when a process is blocked on socket input or output, or \nread_chan\n when a process is blocked on terminal I/O.\n\n\nIn \nps(1)\n, WCHAN column indicates the name of the kernel function in which the process is sleeping, a \"-\" if the process is running, or a \"*\" if the process is multi-threaded and ps is not displaying threads.\n\n\n\n\n\n\n\n\nNormal Termination\n\n\nAt this point, the connection is established and whatever we type to the client is echoed back.\n\n\nlinux % tcpcli01 127.0.0.1   # we showed this line earlier\n\n\nhello, world                 # we now type this\n\n\nhello, world                 # and the line is echoed\n\n\ngood bye\n\n\ngood bye\n\n\n^D                           # Control-D is our terminal EOF character\n\n\n\n\n\n\nIf we immediately execute netstat, we have:\n\n\nlinux % netstat -a | grep 9877\n\n\ntcp        0      0 *:9877               *:*               LISTEN\n\n\ntcp        0      0 localhost:42758      localhost:9877    TIME_WAIT\n\n\n\n\n\n\nThis time we pipe the output of netstat into \ngrep\n, printing only the lines with our server's well-known port:\n\n\n\n\nThe client's side of the connection (since the local port is 42758) enters the TIME_WAIT state\n\n\nThe listening server is still waiting for another client connection.\n\n\n\n\nThe following steps are involved in the normal termination of client and server:\n\n\n\n\nWhen we type our EOF character, \nfgets\n returns a null pointer and the function \nstr_cli\n (\nSection 5.5\n) returns.\n\n\nstr_cli\n returns to the client \nmain\n function (\nSection 5.5\n), which terminates by calling \nexit\n.\n\n\nPart of process termination is the closing of all open descriptors, so the client socket is closed by the kernel. This sends a FIN to the server, to which the server TCP responds with an ACK. This is the first half of the TCP connection termination sequence. At this point, the server socket is in the CLOSE_WAIT state and the client socket is in the FIN_WAIT_2 state (\nFigure 2.4\n and \nFigure 2.5\n)\n\n\nWhen the server TCP receives the FIN, the server child is blocked in a call to \nread\n (\nSection 3.8\n), and \nread\n then returns 0. This causes the \nstr_echo\n function to return to the server child main. [Errata] [p128]\n\n\nThe server child terminates by calling exit. (\nSection 5.2\n)\n\n\nAll open descriptors in the server child are closed.\n\n\nThe closing of the connected socket by the child causes the final two segments of the TCP connection termination to take place: a FIN from the server to the client, and an ACK from the client.\n\n\n\n\n\n\nFinally, the \nSIGCHLD\n signal is sent to the parent when the server child terminates.\n\n\nThis occurs in this example, but we do not catch the signal in our code, and the default action of the signal is to be ignored. Thus, the child enters the zombie state. We can verify this with the \nps\n command.\n\n\n\n\n\n\n\n\nlinux % ps -t pts/6 -o pid,ppid,tty,stat,args,wchan\n\n\n  PID  PPID TT       STAT COMMAND          WCHAN\n\n\n22038 22036 pts/6    S    -bash            read_chan\n\n\n17870 22038 pts/6    S    ./tcpserv01      wait_for_connect\n\n\n19315 17870 pts/6    Z    [tcpserv01 \ndefu do_exit\n\n\n\n\n\n\nThe STAT of the child is now \nZ\n (for zombie).\n\n\nWe need to clean up our zombie processes and doing this requires dealing with Unix signals. The next section will give an overview of signal handling.\n\n\nPOSIX Signal Handling\n\n\nA \nsignal\n is a notification to a process that an event has occurred. Signals are sometimes called \nsoftware interrupts\n. Signals usually occur asynchronously, which means that a process doesn't know ahead of time exactly when a signal will occur.\n\n\nSignals can be sent:\n\n\n\n\nBy one process to another process (or to itself)\n\n\nBy the kernel to a process.\n\n\nFor example, whenever a process terminates, the kernel send a \nSIGCHLD\n signal to the parent of the terminating process.\n\n\n\n\n\n\n\n\nEvery signal has a \ndisposition\n, which is also called the \naction\n associated with the signal. We set the disposition of a signal by calling the \nsigaction\n function and we have three choices for the disposition:\n\n\n\n\n\n\nCatching a signal\n. We can provide a function called a \nsignal handler\n that is called whenever a specific signal occurs. The two signals \nSIGKILL\n and \nSIGSTOP\n cannot be caught. Our function is called with a single integer argument that is the signal number and the function returns nothing. Its function prototype is therefore:\n\n\nvoid handler (int signo);\n\n\n\n\n\nFor most signals, we can call \nsigaction\n and specify the signal handler to catch it. A few signals, \nSIGIO\n, \nSIGPOLL\n, and \nSIGURG\n, all require additional actions on the part of the process to catch the signal.\n\n\n\n\n\n\nIgnoring a signal\n. We can ignore a signal by setting its disposition to \nSIG_IGN\n. The two signals SIGKILL and SIGSTOP cannot be ignored.\n\n\n\n\nSetting the default disposition for a signal\n. This can be done by setting its disposition to \nSIG_DFL\n. The default is normally to terminate a process on receipt of a signal, with certain signals also generating a core image of the process in its current working directory. There are a few signals whose default disposition is to be ignored: \nSIGCHLD\n and \nSIGURG\n (sent on the arrival of out-of-band data) are two that we will encounter in this text.\n\n\n\n\nsignal\n Function\n\n\nThe POSIX way to establish the disposition of a signal is to call the \nsigaction\n function, which is complicated in that one argument to the function is a structure (\nstruct sigaction\n) that we must allocate and fill in.\n\n\nAn easier way to set the disposition of a signal is to call the \nsignal\n function. The first argument is the signal name and the second argument is either a pointer to a function or one of the constants \nSIG_IGN\n or \nSIG_DFL\n.\n\n\nHowever, \nsignal\n is an historical function that predates POSIX. Different implementations provide different signal semantics when it is called, providing backward compatibility, whereas POSIX explicitly spells out the semantics when \nsigaction\n is called.\n\n\nThe solution is to define our own function named \nsignal\n that just calls the POSIX \nsigaction\n function. This provides a simple interface with the desired POSIX semantics. We include this function in our own library, along with our \nerr\n_XXX functions and our wrapper functions. [p130]\n\n\n\n\nlib/signal.c\n\n\n\n\n#include    \nunp.h\n\n\n\nSigfunc\n \n*\n\n\nsignal\n(\nint\n \nsigno\n,\n \nSigfunc\n \n*\nfunc\n)\n\n\n{\n\n    \nstruct\n \nsigaction\n    \nact\n,\n \noact\n;\n\n\n    \nact\n.\nsa_handler\n \n=\n \nfunc\n;\n\n    \nsigemptyset\n(\nact\n.\nsa_mask\n);\n\n    \nact\n.\nsa_flags\n \n=\n \n0\n;\n\n    \nif\n \n(\nsigno\n \n==\n \nSIGALRM\n)\n \n{\n\n\n#ifdef  SA_INTERRUPT\n\n        \nact\n.\nsa_flags\n \n|=\n \nSA_INTERRUPT\n;\n   \n/* SunOS 4.x */\n\n\n#endif\n\n    \n}\n \nelse\n \n{\n\n\n#ifdef  SA_RESTART\n\n        \nact\n.\nsa_flags\n \n|=\n \nSA_RESTART\n;\n     \n/* SVR4, 44BSD */\n\n\n#endif\n\n    \n}\n\n    \nif\n \n(\nsigaction\n(\nsigno\n,\n \nact\n,\n \noact\n)\n \n \n0\n)\n\n        \nreturn\n(\nSIG_ERR\n);\n\n    \nreturn\n(\noact\n.\nsa_handler\n);\n\n\n}\n\n\n/* end signal */\n\n\n\nSigfunc\n \n*\n\n\nSignal\n(\nint\n \nsigno\n,\n \nSigfunc\n \n*\nfunc\n)\n    \n/* for our signal() function */\n\n\n{\n\n    \nSigfunc\n \n*\nsigfunc\n;\n\n\n    \nif\n \n(\n \n(\nsigfunc\n \n=\n \nsignal\n(\nsigno\n,\n \nfunc\n))\n \n==\n \nSIG_ERR\n)\n\n        \nerr_sys\n(\nsignal error\n);\n\n    \nreturn\n(\nsigfunc\n);\n\n\n}\n\n\n\n\n\n\nSimplify function prototype using \ntypedef\n\n\nThe normal function prototype for \nsignal\n is complicated by the level of nested parentheses.\n\n\nvoid\n \n(\n*\nsignal\n \n(\nint\n \nsigno\n,\n \nvoid\n \n(\n*\nfunc\n)\n \n(\nint\n)))\n \n(\nint\n);\n\n\n\n\n\n\nTo simplify this, we define the \nSigfunc\n type in our \nunp.h\n header as\n\n\ntypedef\n    \nvoid\n    \nSigfunc\n(\nint\n);\n\n\n\n\n\n\nstating that signal handlers are functions with an integer argument and the function returns nothing (\nvoid\n). The function prototype then becomes\n\n\nSigfunc\n \n*\nsignal\n \n(\nint\n \nsigno\n,\n \nSigfunc\n \n*\nfunc\n);\n\n\n\n\n\n\nA pointer to a signal handling function is the second argument to the function, as well as the return value from the function.\n\n\nSet handler\n\n\nThe \nsa_handler\n member of the \nsigaction\n structure is set to the \nfunc\n argument.\n\n\nSet signal mask for handler\n\n\nPOSIX allows us to specify a set of signals that will be blocked when our signal handler is called. Any signal that is blocked cannot be delivered to a process. We set the \nsa_mask\n member to the empty set, which means that no additional signals will be blocked while our signal handler is running. \nPOSIX guarantees that the signal being caught is always blocked while its handler is executing.\n\n\nSet \nSA_RESTART\n flag\n\n\nSA_RESTART\n is an optional flag. When the flag is set, a system call interrupted by this signal will be automatically restarted by the kernel.\n\n\nIf the signal being caught is not \nSIGALRM\n, we specify the \nSA_RESTART\n flag, if defined. This is because the purpose of generating the \nSIGALRM\n signal is normally to place a timeout on an I/O operation, in which case, we want the blocked system call to be interrupted by the signal. [p131]\n\n\nCall \nsigaction\n\n\nWe call \nsigaction\n and then \nreturn the old action for the signal as the return value of the signal function.\n\n\nThroughout this text, we will use the \nsignal\n function from the above definition.", 
            "title": "Chapter 5. TCP Client/Server Example"
        }, 
        {
            "location": "/icnd1/part1/", 
            "text": "Part I: Networking Fundamentals\n\n\nChapter 1. Introduction to Computer Networking\n\n\nChapter 2. The TCP/IP and OSI Networking Models\n\n\nTCP/IP Networking Model\n\n\nA \nnetworking model\n (\nnetworking architecture\n or \nnetworking blueprint\n), refers to a comprehensive set of documents that define everything that should happen for a computer network to work.\n\n\nThe TCP/IP model both defines and references a large collection of protocols that allow computers to communicate. TCP/IP uses documents called \nRequests for Comments\n (RFC).\n\n\nData Encapsulation Terminology\n\n\n\n\n\n\nCreate and encapsulate the application data with any required application layer headers.\n\n\nEncapsulate the data supplied by the application layer inside a transport layer header. \n\n\nEncapsulate the data supplied by the transport layer inside an Internet layer (IP) header.\n\n\nEncapsulate the data supplied by the Internet layer inside a data link layer header and trailer. This is the only layer that uses both a \nheader\n and a \ntrailer\n.\n\n\nTransmit the bits.\n\n\n\n\nOSI Networking Model\n\n\n\n\nDescribing Protocols by Referencing the OSI Layers\n\n\nNetworking documents often describe TCP/IP protocols and standards by referencing OSI layers, both by layer number and layer name. For instance, a common description of a LAN switch is \u201clayer 2 switch,\u201d with \u201clayer 2\u201d referring to OSI layer 2.\n\n\n\n\n\n\n\n\nLayer Name\n\n\nProtocols and Specifications\n\n\nDevices\n\n\n\n\n\n\n\n\n\n\nApplication, presentation, session (Layers 5\u20137)\n\n\nTelnet, HTTP, FTP, SMTP, POP3, VoIP, SNMP\n\n\nFirewall, intrusion detection systems, hosts\n\n\n\n\n\n\nTransport (Layer 4)\n\n\nTCP, UDP\n\n\nHosts, firewalls\n\n\n\n\n\n\nNetwork (Layer 3)\n\n\nIP\n\n\nRouter\n\n\n\n\n\n\nData link (Layer 2)\n\n\nEthernet (IEEE 802.3), HDLC, Frame Relay, PPP\n\n\nLAN switch, wireless access point, cable modem, DSL modem\n\n\n\n\n\n\nPhysical (Layer 1)\n\n\nRJ-45, EIA/TIA-232, V.35, Ethernet (IEEE 802.3)\n\n\nLAN hub, LAN repeater, cables\n\n\n\n\n\n\n\n\nOSI Layering Concepts and Benefits\n\n\n[p41]\n\n\n\n\nLess complex\n\n\nStandard interfaces\n\n\nEasier to learn\n\n\nEasier to develop\n\n\nMultivendor interoperability\n\n\nModular engineering\n\n\n\n\nOSI Encapsulation Terminology\n\n\n\n\nThe TCP/IP model uses terms such as \nsegment\n, \npacket\n, and \nframe\n to refer to various layers and their respective encapsulated data. OSI uses a more generic term: \nprotocol data unit\n (PDU).\n\n\nChapter 3. Fundamentals of LANs\n\n\nAn Overview of Modern Ethernet LANs\n\n\nTypes of cabling:\n\n\n\n\nUnshielded Twisted-Pair\n (UTP)\n\n\nFiber-optic\n\n\n\n\nMost IEEE standards define a different variation of Ethernet at the physical layer. \nFor the data link layer:\n\n\n\n\n802.3 Media Access Control (MAC) sublayer\n\n\n802.2 Logical Link Control (LLC) sublayer\n\n\n\n\n[p52]\n\n\n\n\n\n\n\n\nCommon Name\n\n\nSpeed\n\n\nAlternative Name\n\n\nName of IEEE Standard\n\n\nCable Type, Maximum Length\n\n\n\n\n\n\n\n\n\n\nEthernet\n\n\n10 Mbps\n\n\n10BASE-T\n\n\nIEEE 802.3\n\n\nCopper, 100 m\n\n\n\n\n\n\nFast Ethernet\n\n\n100 Mbps\n\n\n100BASE-TX\n\n\nIEEE 802.3u\n\n\nCopper, 100 m\n\n\n\n\n\n\nGigabit Ethernet\n\n\n1000 Mbps\n\n\n1000BASE-LX, 1000BASE-SX\n\n\nIEEE 802.3z\n\n\nFiber, 550 m (SX) 5 km (LX)\n\n\n\n\n\n\nGigabit Ethernet\n\n\n1000 Mbps\n\n\n1000BASE-T\n\n\nIEEE 802.3ab\n\n\n100 m\n\n\n\n\n\n\n\n\nThe term Ethernet is often used to mean \"all types of Ethernet\", but in some cases it is used to mean \"10BASE-T Ethernet\"\n\n\nA Brief History of Ethernet\n\n\n\n\nCarrier sense multiple access with collision detection (CSMA/CD) algorithm\n\n\n\n\nRepeaters\n\n\nRepeaters\n extended the length of LANs by cleaning up the electrical signal and repeating it (a Layer 1 function) but without interpreting the meaning of the electrical signal. [p56]\n\n\nBuilding 10BASE-T Networks with Hubs\n\n\nHubs\n are essentially repeaters with multiple physical ports. It simply regenerates the electrical signal that comes in one port and sends the same signal out every other port.\n\n\nEthernet UTP Cabling\n\n\nTransmitting Data Using Twisted Pairs\n\n\nUTP cabling consists of matched pairs of wires that are indeed twisted together, with current on the two wires in opposite directions.\n\n\nUTP Cabling Pinouts for \n10BASE-T and 100BASE-TX\n\n\n10BASE-T and 100BASE-TX Ethernet define that one pair should be used to send data in one direction, with the other pair used to send data in the other direction.\n\n\nThe wires in the UTP cable must be connected to the correct \npin positions\n in the RJ-45 connectors in order for communication to work correctly. \n\n\n[p62-64]\n\n\nThe following applies to 10BASE-T and 100BASE-TX only:\n\n\n\n\nEthernet \nstraight-through cable\n: both ends of the cable use the same EIA/TIA pinout standard on each end of the cable. A straight-through cable is used when the devices on the ends of the cable use opposite pins when they transmit data.\n\n\nEthernet \ncrossover cable\n:  two devices both use the same pins to transmit and the pinouts of the cable are set up to swap the wire pair\n\n\n\n\n\n\n\n\n\n\nDevices That Transmit on 1,2 and Receive on 3,6\n\n\nDevices That Transmit on 3,6 and Receive on 1,2\n\n\n\n\n\n\n\n\n\n\nPC NICs\n\n\nHubs\n\n\n\n\n\n\nRouters\n\n\nSwitches\n\n\n\n\n\n\nWireless Access Point (Ethernet interface)\n\n\n\u2014\n\n\n\n\n\n\nNetworked printers (printers that connect directly to the LAN)\n\n\n\u2014\n\n\n\n\n\n\n\n\n1000BASE-T Cabling\n\n\n1000BASE-T differs from 10BASE-T and 100BASE-TX as far as the cabling and pinouts:\n\n\n\n\nReequires four wire pairs\n\n\nTransmits and receives on each of the four wire pairs simultaneously\n\n\nHas no concept of straight-through and crossover cables\n\n\n\n\nImproving Performance by Using Switches Instead of Hubs\n\n\nCSMA/CD logic helps prevent collisions and also defines how to act when a collision does occur:\n\n\n\n\nA device with a frame to send listens until the Ethernet is not busy.\n\n\nWhen the Ethernet is not busy, the sender(s) begin(s) sending the frame.\n\n\nThe sender(s) listen(s) to make sure that no collision occurred.\n\n\nIf a collision occurs, the devices that had been sending a frame each send a jamming signal to ensure that all stations recognize the collision.\n\n\nAfter the jamming is complete, each sender randomizes a timer and waits that long before trying to resend the collided frame. When each random timer expires, the process starts over with Step 1.\n\n\n\n\nIncreasing Available Bandwidth Using Switches\n\n\nThe term \ncollision domain\n defines the set of devices whose frames could collide. For example, all devices connected to the hub are in the same collision domain. To avoid collisions, and to recover when they occur, devices in the same collision domain use CSMA/CD.\n\n\nSwitches\n significantly reduce, or even eliminate, the number of collisions on a LAN:\n\n\n\n\nSwitches interpret the bits in the received frame so that they can typically send the frame out the one required port, rather than all other ports\n\n\nIf a switch needs to forward multiple frames out the same port, the switch buffers the frames in memory, sending one at a time, thereby avoiding collisions\n\n\n\n\nThe switch\u2019s logic requires that the switch look at the Ethernet header, which is considered a Layer 2 feature. As a result, switches are considered to operate as a Layer 2 device, whereas hubs are Layer 1 devices.\n\n\nBuffering (temporarily holds the frame in memory) also helps prevent collisions.\n\n\nSwitch features provide significant performance improvements:\n\n\n\n\nIf only one device is cabled to each port of a switch, no collisions can occur.\n\n\nDevices connected to one switch port do not share their bandwidth with devices connected to another switch port. Each has its own separate bandwidth, meaning that a switch with 100-Mbps ports has 100 Mbps of bandwidth \nper port\n.\n\n\n\n\nShared Ethernet vs. Switched Ethernet\n\n\n\n\nShared Ethernet\n: bandwidth is shared among the devices on the LAN because they must take turns using the LAN because of the CSMA/CD algorithm. A hub with 24 100-Mbps Ethernet devices connected to it allows for a theoretical maximum of 100 Mbps of bandwidth\n\n\nSwitched Ethernet\n: bandwidth does not have to be shared, allowing for far greater performance. A switch with 24 100-Mbps Ethernet devices connected to it supports 100 Mbps for each port, or 2400 Mbps (2.4 Gbps) theoretical maximum bandwidth.\n\n\n\n\nDoubling Performance by Using Full-Duplex Ethernet\n\n\nIn an Ethernet network using hubs, CSMA/CD imposes \nhalf-duplex\n logic on each device, meaning that only one device can send at a time. LAN switches with only one device cabled to each port of the switch allow the use of \nfull-duplex\n operation; Ethernet card can send and receive concurrently.\n\n\nEthernet Data-Link Protocols\n\n\nEthernet Addressing\n\n\n\n\n\n\n\n\nLAN Addressing Term or Feature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMAC\n\n\nMedia Access Control. 802.3 (Ethernet) defines the MAC sublayer of IEEE Ethernet.\n\n\n\n\n\n\nEthernet address, NIC address, LAN address\n\n\nOther names often used instead of MAC address. These terms describe the 6-byte address of the LAN interface card.\n\n\n\n\n\n\nBurned-in address\n\n\nThe 6-byte address assigned by the vendor making the card.\n\n\n\n\n\n\nUnicast address\n\n\nA term for a MAC that represents a single LAN interface.\n\n\n\n\n\n\nBroadcast address\n\n\nAn address that means \u201call devices that reside on this LAN right now.\u201d (FFFF.FFFF.FFFF)\n\n\n\n\n\n\nMulticast address\n\n\nOn Ethernet, a multicast address implies some subset of all devices currently on the Ethernet LAN. (0100.5exx.xxxx, any value can be used in the last half)\n\n\n\n\n\n\n\n\nEthernet Framing\n\n\nFraming\n defines the meaning of the bits transmitted and received over a network.\n\n\n\n\n\n\nData\n field holds Layer 3 packets (L3 PDU)\n\n\nMaximum transmission unit\n (MTU) defines the maximum Layer 3 packet that can be sent over a medium. 1500 bytes is the largest IP MTU allowed over an Ethernet.\n\n\n\n\nIdentifying the Data Inside an Ethernet Frame\n\n\nType/Length\n filed:\n\n\n\n\nLength\n field: with a value less than hex 0600 (decimal 1536); another field is needed to identify the type of L3 PDU inside the frame.\n\n\nType\n field: value of hexadecimal 0800 (decimal 2048) implies an IP packet\n\n\n\n\nError Detection\n\n\nErrors (bit changes) occur due to electrical interference. Trailer containing a \nFrame Check Sequence\n (FCS) field used for error detection.\n\n\nChapter 4. Fundamentals of WANs\n\n\nThe WAN topics in this chapter describe mainly how enterprise networks use WANs to connect remote sites.\n\n\nOSI Layer 1 for Point-to-Point WANs\n\n\n\n\nLeased line\n or \nleased circuit\n: WAN cable, line or point-to-point connection that is paid for use\n\n\nTelephone company (telco), or public telephone and telegraph (PTT)\n\n\nService provider\n: a company that provides any form of WAN connectivity, including Internet services.\n\n\n\n\nRouters provide the capability to connect many different types of OSI Layer 1 and Layer 2 technologies. A router is connected to each end of a WAN connection.\n\n\n\n\n\n\nCentral Office (CO): a building where the telco locates the devices used to create its own network\n\n\nChannel service unit/data service (\nCSU/DSU\n)\n\n\ndemarc\n (\ndemarcation point\n): he point at which the telco\u2019s responsibility is on one side and the customer\u2019s responsibility is on the other\n\n\nCustomer premises equipment\n (CPE): devices that are at the customer site\n\n\n\n\nWAN Cabling Standards\n\n\n[p84]\n\n\nClock Rates, Synchronization, DCE, and DTE\n\n\n[p86]\n\n\n\n\nSynchronization: various devices need to synchronize their clocks so that they run at exactly the same speed to make a link work\n\n\nData communications equipment (DCE): device that provides clocking, typically the CSU/DSU\n\n\nData terminal equipment (DTE): device receiving clocking, typically the router\n\n\n\n\nLink Speeds\n\n\n\n\n\n\n\n\nName(s) of Line\n\n\nBit Rate\n\n\n\n\n\n\n\n\n\n\nDS0\n\n\n64 kbps\n\n\n\n\n\n\nDS1 (T1)\n\n\n1.544 Mbps (24 DS0s, plus 8 kbps overhead)\n\n\n\n\n\n\nDS3 (T3)\n\n\n44.736 Mbps (28 DS1s, plus management overhead)\n\n\n\n\n\n\nE1\n\n\n2.048 Mbps (32 DS0s)\n\n\n\n\n\n\nE3\n\n\n34.368 Mbps (16 E1s, plus management overhead)\n\n\n\n\n\n\nJ1 (Y1)\n\n\n2.048 Mbps (32 DS0s; Japanese standard)\n\n\n\n\n\n\n\n\nOSI Layer 2 for Point-to-Point WANs\n\n\nHDLC\n\n\n\n\nHigh-Level Data Link Control\n (HDLC) defines framing to:\n\n\n\n\nDelivers data across the link \n\n\nCheck for errors\n\n\nIdentify the packet type\n\n\n\n\nPoint-to-Point Protocol\n\n\nPoint-to-Point Protocol (PPP) behaves much like HDLC. The framing looks identical to the Cisco proprietary HDLC framing. PPP has become the most popular and feature-rich of WAN data link layer protocols. [p91]\n\n\nPoint-to-Point WAN Summary\n\n\nWAN Terminology [p91-92]\n\n\n\n\nSynchronous: The imposition of time ordering on a bit stream\n\n\nClock source: The device to which the other devices on the link adjust their speed when using synchronous links\n\n\nCSU/DSU: Used on digital links as an interface to the telephone company in the United States. Routers typically use a short cable from a serial interface to a CSU/DSU, which is attached to the line from the telco\n\n\nTelco\n\n\nFour-wire circuit: A line from the telco with four wires, composed of two twisted-pair wires. Each pair is used to send in one direction, so a four-wire circuit allows full-duplex communication.\n\n\nT1\n\n\nE1\n\n\n\n\nAll the following terms may be used to refer to a point-to-point leased line:\n\n\n\n\nleased line\n\n\nleased circuit\n\n\nlink\n\n\nserial link\n\n\nserial line\n\n\npoint-to-point link\n\n\ncircuit\n\n\n\n\nFrame Relay and Packet-Switching Services\n\n\nPacket-switching service\n: a company can connect a large number of routers using a single serial link from each router into the packet-switching service. Once connected, each router can send packets to all the other routers\u2014much like all the devices connected to an Ethernet hub or switch can send data directly to each other.\n\n\nTwo types of packet-switching service are very popular today:\n\n\n\n\nFrame Relay: much more common\n\n\nAsynchronous Transfer Mode (ATM)\n\n\n\n\nChapter 5. Fundamentals of IPv4 Addressing and Routing\n\n\n\n\nRouting: the process of forwarding packets (Layer 3 PDUs).\n\n\nLogical addressing: enables the routing process to identify a packet\u2019s source and destination.\n\n\nRouting protocol: aids routers by dynamically learning about the groups of addresses in the network, which in turn allows the routing (forwarding) process to work well.\n\n\nOther utilities: The network layer also relies on other utilities: Domain Name System (DNS), Dynamic Host Configuration Protocol (DHCP), Address Resolution Protocol (ARP), and ping.\n\n\n\n\nPath selection\n sometimes is used to mean:\n\n\n\n\nRouting protocol\n\n\nRouting (forwarding) of packets\n\n\n\n\nOverview of Network Layer Functions\n\n\nToday, the only Layer 3 protocol that is used widely is the TCP/IP network layer protocol, specifically, IP.  IP does not require any overhead agreements or messages before sending a packet, making IP a connectionless protocol, with no error recovery.\n\n\nRouting (Forwarding)\n\n\nRouting focuses on the end-to-end logic of forwarding data.\n\n\nThe routing table for any particular network layer protocol contains a list of network layer address groupings. Instead of a single entry in the routing table per individual destination network layer address, there is one routing table entry per group.\n\n\nNetwork Layer Interaction with the Data Link Layer\n\n\nThe routing process forwards the packet, and only the packet, end-to-end through the network, discarding data-link headers and trailers along the way.\n\n\nRouters build new data-link headers and trailers and because the new headers contain data-link addresses, the PCs and routers must decide what data-link addresses to use. The Address Resolution Protocol (ARP) is used to dynamically learn the data-link address of an IP host connected to a LAN.\n\n\nRouting as covered so far has two main concepts:\n\n\n\n\nThe process of routing forwards Layer 3 packets, also called Layer 3 protocol data units (L3 PDU), based on the destination Layer 3 address in the packet.\n\n\nThe routing process uses the data link layer to encapsulate the Layer 3 packets into Layer 2 frames for transmission across each successive data link.", 
            "title": "ICND1 Part I: Networking Fundamentals"
        }, 
        {
            "location": "/icnd1/part1/#chapter-1-introduction-to-computer-networking", 
            "text": "", 
            "title": "Chapter 1. Introduction to Computer Networking"
        }, 
        {
            "location": "/icnd1/part1/#chapter-2-the-tcpip-and-osi-networking-models", 
            "text": "TCP/IP Networking Model  A  networking model  ( networking architecture  or  networking blueprint ), refers to a comprehensive set of documents that define everything that should happen for a computer network to work.  The TCP/IP model both defines and references a large collection of protocols that allow computers to communicate. TCP/IP uses documents called  Requests for Comments  (RFC).  Data Encapsulation Terminology    Create and encapsulate the application data with any required application layer headers.  Encapsulate the data supplied by the application layer inside a transport layer header.   Encapsulate the data supplied by the transport layer inside an Internet layer (IP) header.  Encapsulate the data supplied by the Internet layer inside a data link layer header and trailer. This is the only layer that uses both a  header  and a  trailer .  Transmit the bits.   OSI Networking Model   Describing Protocols by Referencing the OSI Layers  Networking documents often describe TCP/IP protocols and standards by referencing OSI layers, both by layer number and layer name. For instance, a common description of a LAN switch is \u201clayer 2 switch,\u201d with \u201clayer 2\u201d referring to OSI layer 2.     Layer Name  Protocols and Specifications  Devices      Application, presentation, session (Layers 5\u20137)  Telnet, HTTP, FTP, SMTP, POP3, VoIP, SNMP  Firewall, intrusion detection systems, hosts    Transport (Layer 4)  TCP, UDP  Hosts, firewalls    Network (Layer 3)  IP  Router    Data link (Layer 2)  Ethernet (IEEE 802.3), HDLC, Frame Relay, PPP  LAN switch, wireless access point, cable modem, DSL modem    Physical (Layer 1)  RJ-45, EIA/TIA-232, V.35, Ethernet (IEEE 802.3)  LAN hub, LAN repeater, cables     OSI Layering Concepts and Benefits  [p41]   Less complex  Standard interfaces  Easier to learn  Easier to develop  Multivendor interoperability  Modular engineering   OSI Encapsulation Terminology   The TCP/IP model uses terms such as  segment ,  packet , and  frame  to refer to various layers and their respective encapsulated data. OSI uses a more generic term:  protocol data unit  (PDU).", 
            "title": "Chapter 2. The TCP/IP and OSI Networking Models"
        }, 
        {
            "location": "/icnd1/part1/#chapter-3-fundamentals-of-lans", 
            "text": "An Overview of Modern Ethernet LANs  Types of cabling:   Unshielded Twisted-Pair  (UTP)  Fiber-optic   Most IEEE standards define a different variation of Ethernet at the physical layer. \nFor the data link layer:   802.3 Media Access Control (MAC) sublayer  802.2 Logical Link Control (LLC) sublayer   [p52]     Common Name  Speed  Alternative Name  Name of IEEE Standard  Cable Type, Maximum Length      Ethernet  10 Mbps  10BASE-T  IEEE 802.3  Copper, 100 m    Fast Ethernet  100 Mbps  100BASE-TX  IEEE 802.3u  Copper, 100 m    Gigabit Ethernet  1000 Mbps  1000BASE-LX, 1000BASE-SX  IEEE 802.3z  Fiber, 550 m (SX) 5 km (LX)    Gigabit Ethernet  1000 Mbps  1000BASE-T  IEEE 802.3ab  100 m     The term Ethernet is often used to mean \"all types of Ethernet\", but in some cases it is used to mean \"10BASE-T Ethernet\"  A Brief History of Ethernet   Carrier sense multiple access with collision detection (CSMA/CD) algorithm   Repeaters  Repeaters  extended the length of LANs by cleaning up the electrical signal and repeating it (a Layer 1 function) but without interpreting the meaning of the electrical signal. [p56]  Building 10BASE-T Networks with Hubs  Hubs  are essentially repeaters with multiple physical ports. It simply regenerates the electrical signal that comes in one port and sends the same signal out every other port.  Ethernet UTP Cabling  Transmitting Data Using Twisted Pairs  UTP cabling consists of matched pairs of wires that are indeed twisted together, with current on the two wires in opposite directions.  UTP Cabling Pinouts for  10BASE-T and 100BASE-TX  10BASE-T and 100BASE-TX Ethernet define that one pair should be used to send data in one direction, with the other pair used to send data in the other direction.  The wires in the UTP cable must be connected to the correct  pin positions  in the RJ-45 connectors in order for communication to work correctly.   [p62-64]  The following applies to 10BASE-T and 100BASE-TX only:   Ethernet  straight-through cable : both ends of the cable use the same EIA/TIA pinout standard on each end of the cable. A straight-through cable is used when the devices on the ends of the cable use opposite pins when they transmit data.  Ethernet  crossover cable :  two devices both use the same pins to transmit and the pinouts of the cable are set up to swap the wire pair      Devices That Transmit on 1,2 and Receive on 3,6  Devices That Transmit on 3,6 and Receive on 1,2      PC NICs  Hubs    Routers  Switches    Wireless Access Point (Ethernet interface)  \u2014    Networked printers (printers that connect directly to the LAN)  \u2014     1000BASE-T Cabling  1000BASE-T differs from 10BASE-T and 100BASE-TX as far as the cabling and pinouts:   Reequires four wire pairs  Transmits and receives on each of the four wire pairs simultaneously  Has no concept of straight-through and crossover cables   Improving Performance by Using Switches Instead of Hubs  CSMA/CD logic helps prevent collisions and also defines how to act when a collision does occur:   A device with a frame to send listens until the Ethernet is not busy.  When the Ethernet is not busy, the sender(s) begin(s) sending the frame.  The sender(s) listen(s) to make sure that no collision occurred.  If a collision occurs, the devices that had been sending a frame each send a jamming signal to ensure that all stations recognize the collision.  After the jamming is complete, each sender randomizes a timer and waits that long before trying to resend the collided frame. When each random timer expires, the process starts over with Step 1.   Increasing Available Bandwidth Using Switches  The term  collision domain  defines the set of devices whose frames could collide. For example, all devices connected to the hub are in the same collision domain. To avoid collisions, and to recover when they occur, devices in the same collision domain use CSMA/CD.  Switches  significantly reduce, or even eliminate, the number of collisions on a LAN:   Switches interpret the bits in the received frame so that they can typically send the frame out the one required port, rather than all other ports  If a switch needs to forward multiple frames out the same port, the switch buffers the frames in memory, sending one at a time, thereby avoiding collisions   The switch\u2019s logic requires that the switch look at the Ethernet header, which is considered a Layer 2 feature. As a result, switches are considered to operate as a Layer 2 device, whereas hubs are Layer 1 devices.  Buffering (temporarily holds the frame in memory) also helps prevent collisions.  Switch features provide significant performance improvements:   If only one device is cabled to each port of a switch, no collisions can occur.  Devices connected to one switch port do not share their bandwidth with devices connected to another switch port. Each has its own separate bandwidth, meaning that a switch with 100-Mbps ports has 100 Mbps of bandwidth  per port .   Shared Ethernet vs. Switched Ethernet   Shared Ethernet : bandwidth is shared among the devices on the LAN because they must take turns using the LAN because of the CSMA/CD algorithm. A hub with 24 100-Mbps Ethernet devices connected to it allows for a theoretical maximum of 100 Mbps of bandwidth  Switched Ethernet : bandwidth does not have to be shared, allowing for far greater performance. A switch with 24 100-Mbps Ethernet devices connected to it supports 100 Mbps for each port, or 2400 Mbps (2.4 Gbps) theoretical maximum bandwidth.   Doubling Performance by Using Full-Duplex Ethernet  In an Ethernet network using hubs, CSMA/CD imposes  half-duplex  logic on each device, meaning that only one device can send at a time. LAN switches with only one device cabled to each port of the switch allow the use of  full-duplex  operation; Ethernet card can send and receive concurrently.  Ethernet Data-Link Protocols  Ethernet Addressing     LAN Addressing Term or Feature  Description      MAC  Media Access Control. 802.3 (Ethernet) defines the MAC sublayer of IEEE Ethernet.    Ethernet address, NIC address, LAN address  Other names often used instead of MAC address. These terms describe the 6-byte address of the LAN interface card.    Burned-in address  The 6-byte address assigned by the vendor making the card.    Unicast address  A term for a MAC that represents a single LAN interface.    Broadcast address  An address that means \u201call devices that reside on this LAN right now.\u201d (FFFF.FFFF.FFFF)    Multicast address  On Ethernet, a multicast address implies some subset of all devices currently on the Ethernet LAN. (0100.5exx.xxxx, any value can be used in the last half)     Ethernet Framing  Framing  defines the meaning of the bits transmitted and received over a network.    Data  field holds Layer 3 packets (L3 PDU)  Maximum transmission unit  (MTU) defines the maximum Layer 3 packet that can be sent over a medium. 1500 bytes is the largest IP MTU allowed over an Ethernet.   Identifying the Data Inside an Ethernet Frame  Type/Length  filed:   Length  field: with a value less than hex 0600 (decimal 1536); another field is needed to identify the type of L3 PDU inside the frame.  Type  field: value of hexadecimal 0800 (decimal 2048) implies an IP packet   Error Detection  Errors (bit changes) occur due to electrical interference. Trailer containing a  Frame Check Sequence  (FCS) field used for error detection.", 
            "title": "Chapter 3. Fundamentals of LANs"
        }, 
        {
            "location": "/icnd1/part1/#chapter-4-fundamentals-of-wans", 
            "text": "The WAN topics in this chapter describe mainly how enterprise networks use WANs to connect remote sites.  OSI Layer 1 for Point-to-Point WANs   Leased line  or  leased circuit : WAN cable, line or point-to-point connection that is paid for use  Telephone company (telco), or public telephone and telegraph (PTT)  Service provider : a company that provides any form of WAN connectivity, including Internet services.   Routers provide the capability to connect many different types of OSI Layer 1 and Layer 2 technologies. A router is connected to each end of a WAN connection.    Central Office (CO): a building where the telco locates the devices used to create its own network  Channel service unit/data service ( CSU/DSU )  demarc  ( demarcation point ): he point at which the telco\u2019s responsibility is on one side and the customer\u2019s responsibility is on the other  Customer premises equipment  (CPE): devices that are at the customer site   WAN Cabling Standards  [p84]  Clock Rates, Synchronization, DCE, and DTE  [p86]   Synchronization: various devices need to synchronize their clocks so that they run at exactly the same speed to make a link work  Data communications equipment (DCE): device that provides clocking, typically the CSU/DSU  Data terminal equipment (DTE): device receiving clocking, typically the router   Link Speeds     Name(s) of Line  Bit Rate      DS0  64 kbps    DS1 (T1)  1.544 Mbps (24 DS0s, plus 8 kbps overhead)    DS3 (T3)  44.736 Mbps (28 DS1s, plus management overhead)    E1  2.048 Mbps (32 DS0s)    E3  34.368 Mbps (16 E1s, plus management overhead)    J1 (Y1)  2.048 Mbps (32 DS0s; Japanese standard)     OSI Layer 2 for Point-to-Point WANs  HDLC   High-Level Data Link Control  (HDLC) defines framing to:   Delivers data across the link   Check for errors  Identify the packet type   Point-to-Point Protocol  Point-to-Point Protocol (PPP) behaves much like HDLC. The framing looks identical to the Cisco proprietary HDLC framing. PPP has become the most popular and feature-rich of WAN data link layer protocols. [p91]  Point-to-Point WAN Summary  WAN Terminology [p91-92]   Synchronous: The imposition of time ordering on a bit stream  Clock source: The device to which the other devices on the link adjust their speed when using synchronous links  CSU/DSU: Used on digital links as an interface to the telephone company in the United States. Routers typically use a short cable from a serial interface to a CSU/DSU, which is attached to the line from the telco  Telco  Four-wire circuit: A line from the telco with four wires, composed of two twisted-pair wires. Each pair is used to send in one direction, so a four-wire circuit allows full-duplex communication.  T1  E1   All the following terms may be used to refer to a point-to-point leased line:   leased line  leased circuit  link  serial link  serial line  point-to-point link  circuit   Frame Relay and Packet-Switching Services  Packet-switching service : a company can connect a large number of routers using a single serial link from each router into the packet-switching service. Once connected, each router can send packets to all the other routers\u2014much like all the devices connected to an Ethernet hub or switch can send data directly to each other.  Two types of packet-switching service are very popular today:   Frame Relay: much more common  Asynchronous Transfer Mode (ATM)", 
            "title": "Chapter 4. Fundamentals of WANs"
        }, 
        {
            "location": "/icnd1/part1/#chapter-5-fundamentals-of-ipv4-addressing-and-routing", 
            "text": "Routing: the process of forwarding packets (Layer 3 PDUs).  Logical addressing: enables the routing process to identify a packet\u2019s source and destination.  Routing protocol: aids routers by dynamically learning about the groups of addresses in the network, which in turn allows the routing (forwarding) process to work well.  Other utilities: The network layer also relies on other utilities: Domain Name System (DNS), Dynamic Host Configuration Protocol (DHCP), Address Resolution Protocol (ARP), and ping.   Path selection  sometimes is used to mean:   Routing protocol  Routing (forwarding) of packets   Overview of Network Layer Functions  Today, the only Layer 3 protocol that is used widely is the TCP/IP network layer protocol, specifically, IP.  IP does not require any overhead agreements or messages before sending a packet, making IP a connectionless protocol, with no error recovery.  Routing (Forwarding)  Routing focuses on the end-to-end logic of forwarding data.  The routing table for any particular network layer protocol contains a list of network layer address groupings. Instead of a single entry in the routing table per individual destination network layer address, there is one routing table entry per group.  Network Layer Interaction with the Data Link Layer  The routing process forwards the packet, and only the packet, end-to-end through the network, discarding data-link headers and trailers along the way.  Routers build new data-link headers and trailers and because the new headers contain data-link addresses, the PCs and routers must decide what data-link addresses to use. The Address Resolution Protocol (ARP) is used to dynamically learn the data-link address of an IP host connected to a LAN.  Routing as covered so far has two main concepts:   The process of routing forwards Layer 3 packets, also called Layer 3 protocol data units (L3 PDU), based on the destination Layer 3 address in the packet.  The routing process uses the data link layer to encapsulate the Layer 3 packets into Layer 2 frames for transmission across each successive data link.", 
            "title": "Chapter 5. Fundamentals of IPv4 Addressing and Routing"
        }, 
        {
            "location": "/icnd2/part1/", 
            "text": "Part I: LAN Switching\n\n\nChapter 1. Virtual LANs", 
            "title": "ICND2 Part I: LAN Switching"
        }, 
        {
            "location": "/icnd2/part1/#chapter-1-virtual-lans", 
            "text": "", 
            "title": "Chapter 1. Virtual LANs"
        }, 
        {
            "location": "/tcpv1/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nSome terms [p1]:\n\n\n\n\nGateways\n: later called routers\n\n\nCatenet\n (\"concatenated\" network): obsolete term, later called internetwork\n\n\n\n\nThis chapter provides an overview of the Internet architecture and TCP/IP protocol suite.\n\n\nArchitectural Principles\n\n\nDesign and Implementation\n\n\nThe Architecture and Protocols of the TCP/IP Suite\n\n\nInternets, Intranets, and Extranets", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/tcpv1/ch2/", 
            "text": "Chapter 2. The Internet Address Architecture", 
            "title": "Chapter 2. The Internet Address Architecture"
        }, 
        {
            "location": "/tcpv1/ch10/", 
            "text": "Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation\n\n\nIP Fragmentation\n\n\nIP employs \nfragmentation\n and \nreassembly\n. Fragmentation in IPv4 can take place at the original sending host and at any intermediate routers along the end-to-end path. Note that datagram fragments can themselves be fragmented. Fragmentation in IPv6 is somewhat different because \nonly the source is permitted to perform fragmentation\n.\n\n\nWhen an IP datagram is fragmented, it is not reassembled until it reaches its final destination, because:\n\n\n\n\nNot performing reassembly within the network alleviates the forwarding software (or hardware) in routers from implementing this feature\n\n\nDifferent fragments of the same datagram may follow different paths to their common destination\n\n\n\n\nExample: UDP/IPv4 Fragmentation\n\n\nAn UDP application may wish to avoid IP fragmentation, because when the size of the resulting datagram exceeds the link\u2019s MTU, the IP datagram is split across multiple IP packets, which can lead to performance issues because \nif any fragment is lost, the entire datagram is lost.\n\n\n\n\nA single UDP datagram with 2992 UDP payload bytes is fragmented into three UDP/ IPv4 packets (no options). The UDP header that contains the source and destination port numbers appears only in the first fragment (a complicating factor for firewalls and NATs). Fragmentation is controlled by the \nIdentification\n, \nFragment Offset\n, and \nMore Fragments\n (MF) fields in the IPv4 header.\n\n\nThe original UDP datagram included 2992 bytes of application (UDP payload) data and 8 bytes of UDP header, resulting in an IPv4 Total Length field value of 3020 bytes (IP header is 20-byte). When this datagram was fragmented into three packets, 40 extra bytes were created (20 bytes for each of the newly created IPv4 fragment headers). Thus, the total number of bytes sent is 3060. [p489]\n\n\nFields:\n\n\n\n\nIdentification\n: its value (set by the original sender) is copied to each fragment and is used to group them together when they arrive\n\n\nFragment Offset\n: the offset of the first byte of the fragment payload byte in the original IPv4 datagram (in 8-byte units)\n\n\nMF\n: indicates whether more fragments in the datagram should be expected and is 0 only in the final fragment\n\n\n\n\nIf one fragment is lost, the entire datagram is lost, since IP itself has no error correction mechanism of its own. Mechanisms such as timeout and retransmission are left as the responsibility of the higher layers. \nFor this reason, fragmentation is often avoided.\n\n\nWe can use our \nsock\n program and increase the size of the datagram until fragmentation occurs. On an Ethernet, the maximum amount of data in a frame is ordinarily 1500 bytes, which leaves at most 1472 bytes for application data to avoid fragmentation, assuming 20 bytes for the IPv4 header and 8 bytes for the UDP header.\n\n\nWe will run our sock program with data sizes of 1471, 1472, 1473, and 1474 bytes. We expect the last two to cause fragmentation:\n\n\n[p490-492]\n\n\nLinux% sock -u -i -n1 -w1471 10.0.0.3 discard\nLinux% sock -u -i -n1 -w1472 10.0.0.3 discard \nLinux% sock -u -i -n1 -w1473 10.0.0.3 discard\nLinux% sock -u -i -n1 -w1474 10.0.0.3 discard\n\n\n\n\n\n1 23:42:43.562452 10.0.0.5.46530 \n 10.0.0.3.9:\n        udp 1471 (DF) (ttl 64, id 61350, len 1499)\n2 23:42:50.267424 10.0.0.5.46531 \n 10.0.0.3.9:\n        udp 1472 (DF) (ttl 64, id 62020, len 1500)\n3 23:42:57.814555 10.0.0.5 \n 10.0.0.3:\n        udp (frag 37671:1@1480) (ttl 64, len 21)\n4 23:42:57.814715 10.0.0.5.46532 \n 10.0.0.3.9:\n        udp 1473 (frag 37671:1480@0+) (ttl 64, len 1500)\n5 23:43:04.368677 10.0.0.5 \n 10.0.0.3:\n        udp (frag 37672:2@1480) (ttl 64, len 22)\n6 23:43:04.368838 10.0.0.5.46535 \n 10.0.0.3.9:\n        udp 1474 (frag 37672:1480@0+) (ttl 64, len 1500)\n\n\n\n\n\nOne observation that may be surprising is that the fragments with larger offsets are delivered \nprior\n to the first fragments. In effect, \nthe sender has intentionally reordered the fragments.\n This behavior can be beneficial. If the last fragment is delivered first, the receiving host is able to ascertain the maximum amount of buffer space it will require in order to reassemble the entire datagram.", 
            "title": "Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation"
        }, 
        {
            "location": "/tcpv1/headers/", 
            "text": "Headers\n\n\nIPv4 Header\n\n\n\n\nIPv6 Header\n\n\n\n\nUDP Header\n\n\n\n\nTCP Header", 
            "title": "Headers"
        }, 
        {
            "location": "/tcpv1/headers/#headers", 
            "text": "IPv4 Header   IPv6 Header   UDP Header   TCP Header", 
            "title": "Headers"
        }, 
        {
            "location": "/htae/", 
            "text": "Hacking: The Art of Exploitation, 2nd Edition\n\n\n0x200 Programming", 
            "title": "HTAE"
        }, 
        {
            "location": "/htae/#0x200-programming", 
            "text": "", 
            "title": "0x200 Programming"
        }, 
        {
            "location": "/golang/", 
            "text": "Golang\n\n\nStructs\n\n\nVisibility\n\n\nThe naming of the struct type and its fields adheres to the visibility rule. It is possible that an exported struct type has a mix of fields: some exported, others not.\n\n\nFactory methods\n\n\nForce using factory methods on a private type [TWTG p233]:\n\n\nwrong\n \n:=\n \nnew\n(\nmatrix\n.\nmatrix\n)\n    \n// will NOT compile (matrix is private)\n\n\nright\n \n:=\n \nmatrix\n.\nNewMatrix\n(\n...\n)\n   \n// the ONLY way to instantiate a matrix\n\n\n\n\n\n\nStructs with tags\n\n\nOnly the package \nreflect\n can access tag content. \nreflect.TypeOf()\n on a variable gives the right type; if this is a struct type, it can be indexed by \nField\n, and then the \nTag\n property can be used. For example:\n\n\n\n\nstruct_tag.go\n\n\n\n\nAnonymous fields and embedded structs\n\n\nConflicting names [TWTG p239]\n\n\n\n\nAn outer name hides an inner name. This provides a way to override a field or method.\n\n\nIf the same name appears twice at the same level, it is an error if the name is used by the program.\n\n\n\n\nMethods\n\n\n\n\nReceiver type\n\n\nMethod set: collection of all the methods on a given type \nT\n (or \n*T\n)\n\n\nNo method overloading\n\n\nA method and the type on which it acts must be defined in the same package\n\n\nPointer or value as receiver: if for a type \nT\n a method \nMeth()\n exists on \n*T\n and \nt\n is a variable of type \nT\n, then \nt.Meth()\n is automatically translated to \n(\nt).Meth()\n [TWTG p246]\n\n\n\n\nMethods on embedded types and inheritance\n\n\n\n\nOverriding: \nmethod4.go\n [TWTG p250]\n\n\nEmbedding multiple anonymous types: \nmult_inheritance.go\n [TWTG p253-254]\n\n\n\n\nEmbed functionality in a type\n\n\n\n\nAggregation (or composition): include a named field of the type of the wanted functionality, \nembed_func1.go\n\n\nEmbedding: \nembed_func2.go\n\n\n\n\nFormat specifiers\n\n\nString()\n-method on a type [TWTG p259]:\n\n\n\n\n%T\n: complete type specification\n\n\n%#v\n complete output of the instance with its fields\n\n\n\n\nInterfaces\n\n\nInterfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.\n\n\n\n\nA type doesn\u2019t have to state explicitly that it implements an interface: interfaces are satisfied implicitly. Multiple types can implement the same interface.\n\n\nA type that implements an interface can also have other functions. \n\n\nA type can implement many interfaces.\n\n\nAn interface type can contain a reference to an instance of any of the types that implement the interface (an interface has what is called a dynamic type)\n\n\n\n\nThe interface variable both contains the value of the receiver instance and a pointer to the appropriate method in a method table.\n\n\n\n\ninterfaces_poly.go\n\n\n\n\nInterface embedding interfaces\n\n\nAn interface can contain the name of one or more other interface(s), which is equivalent to explicitly enumerating the methods of the embedded interface in the containing interface. [TWTG p270]\n\n\nDetect and convert the type of an interface variable: type assertions\n\n\nWe can test if \nvarI\n (interface variable) contains at a certain moment a variable of type \nT\n with the type assertion test [TWTG p271]:\n\n\nif\n \nv\n,\n \nok\n \n:=\n \nvarI\n.(\nT\n);\n \nok\n \n{\n\n    \n// checked type assertion\n\n\n}\n\n\n\n\n\n\n\n\ntype_interfaces.go\n\n\n\n\nThe type switch\n\n\n\n\nType switch\n\n\n\n\n\n\n\nTesting if a value implements an interface\n\n\nv\n is a value and we want to test whether it implements the \nStringer\n interface:\n\n\nif\n \nsv\n,\n \nok\n \n:=\n \nv\n.(\nStringer\n);\n \nok\n \n{\n\n    \nfmt\n.\nPrintf\n(\n\u201c\nv\n \nimplements\n \nString\n():\n \n%\ns\n\\\nn\n\u201d\n,\n \nsv\n.\nString\n());\n \n// note: sv, not v\n\n\n}\n\n\n\n\n\n\nWriting functions so that they accept an interface variable as a parameter makes them more general. Use interfaces to make code more generally applicable.\n\n\nVariables of interface type\n\n\nA variable of interface type stores a pair: the concrete value assigned to the variable, and that value's type descriptor.\n\n\n\n\nThe representation of an interface\n\n\n\n\nUsing method sets with interfaces\n\n\n\n\nPointer methods can be called with pointers.\n\n\nValue methods can be called with values.\n\n\nValue-receiver methods can be called with pointer values because they can be dereferenced first.\n\n\nPointer-receiver methods \ncannot\n be called with values, however, because the value stored inside an interface has no address.\n\n\n\n\nExamples:\n\n\n\n\nmethodset2.go\n\n\nsort.go\n\n\nsortmain.go\n\n\n\n\nEmpty Interface\n\n\nA variable of empty interface type \ninterface{}\n can through assignment receive a variable of any type.\n\n\nInterface Slice\n\n\n\n\nInterface slice\n\n\n\n\nInterface to interface\n\n\nAn interface value can also be assigned to another interface value, as long as the underlying value implements the necessary methods. \n\n\n\n\n\nReflection\n\n\nReflection is the ability of a program to examine its own structure, particularly through the types; it\u2019s a form of \nmetaprogramming\n. \nreflect\n can be used to investigate types and variables at runtime, e.g. its size, its methods, and it can also call these methods \"dynamically\".\n\n\n\n\nreflect.TypeOf\n\n\nreflect.ValueOf\n\n\n\n\n\n\n\n\n\nv.Kind()\n: returns a constant indicating the type\n\n\nv.Interface()\n: recovers the (interface) value\n\n\n\n\nExample:\n\n\n\n\nreflect1.go\n\n\n\n\nSetting a value through reflection\n\n\n\n\nSettability\n: a \nValue\n can be changed only if it is addressable and was not obtained by the use of unexported struct fields, \nreflect2.go\n\n\n\n\nReflection on structs\n\n\n\n\nreflect_struct.go\n\n\n\n\nPrintf\n and reflection\n\n\nPrintf\n uses the reflection package to unpack it and discover the argument list, \nprint.go\n\n\nInterfaces and dynamic typing\n\n\n\n\nIn Go there are no classes: data (structures, or more general types) and methods are treated \northogonally\n, they are much more \nloosely coupled\n.\n\n\nThere is no requirement for explicitly declaring that a type satisfies an interface. This allows interfaces to be defined and used without having to modify existing code.\n\n\nTypes implementing an interface can be passed to any function which takes that interface as an argument. This resembles much more the \nduck typing\n in dynamic languages.\n\n\nExtraction of an interface reduces thereby the number of types and methods needed [TWTG p301]: \nmulti_interfaces_poly.go\n\n\nIf a type must implement a new interface, the type itself doesn\u2019t have to be changed, you must only make the new method(s) on the type. [TWTG p303]\n\n\n\n\n\n\nEmpty interface and function overloading [TWTG p304]\n\n\nInheritance of interfaces:\n\n\nA type includes (embeds) another type (which implements one or more interfaces) as a pointer, then the type can use all of the interfaces-methods. [TWTG p304]\n\n\nA type can also inherit from multiple interfaces providing something like \nmultiple inheritance\n. [TWTG p305]\n\n\n\n\n\n\n\n\nSummary of object-orientedness of Go\n\n\n[TWTG p306]\n\n\n\n\nEncapsulation (data hiding): visibility rule\n\n\nPackage scope\n: lowercase\n\n\nExported\n: uppercase\n\n\n\n\n\n\nInheritance: embedding one or multiple types\n\n\nPolymorphism: a variable of a type can be assigned to a variable of any interface it implements. Types and interfaces are loosely coupled; multiple inheritance is possible through implementing multiple interfaces\n\n\n\n\nHigher order functions\n\n\n[TWTG p306-309]\n\n\n\n\nReferences\n\n\n\n\n[TWTG] \nThe Way To Go: A Thorough Introduction To The Go Programming Language\n\n\n[EG] \nEffective Go\n\n\n[TGB] \nThe Go Blog", 
            "title": "Go"
        }, 
        {
            "location": "/golang/#golang", 
            "text": "Structs  Visibility  The naming of the struct type and its fields adheres to the visibility rule. It is possible that an exported struct type has a mix of fields: some exported, others not.  Factory methods  Force using factory methods on a private type [TWTG p233]:  wrong   :=   new ( matrix . matrix )      // will NOT compile (matrix is private)  right   :=   matrix . NewMatrix ( ... )     // the ONLY way to instantiate a matrix   Structs with tags  Only the package  reflect  can access tag content.  reflect.TypeOf()  on a variable gives the right type; if this is a struct type, it can be indexed by  Field , and then the  Tag  property can be used. For example:   struct_tag.go   Anonymous fields and embedded structs  Conflicting names [TWTG p239]   An outer name hides an inner name. This provides a way to override a field or method.  If the same name appears twice at the same level, it is an error if the name is used by the program.   Methods   Receiver type  Method set: collection of all the methods on a given type  T  (or  *T )  No method overloading  A method and the type on which it acts must be defined in the same package  Pointer or value as receiver: if for a type  T  a method  Meth()  exists on  *T  and  t  is a variable of type  T , then  t.Meth()  is automatically translated to  ( t).Meth()  [TWTG p246]   Methods on embedded types and inheritance   Overriding:  method4.go  [TWTG p250]  Embedding multiple anonymous types:  mult_inheritance.go  [TWTG p253-254]   Embed functionality in a type   Aggregation (or composition): include a named field of the type of the wanted functionality,  embed_func1.go  Embedding:  embed_func2.go   Format specifiers  String() -method on a type [TWTG p259]:   %T : complete type specification  %#v  complete output of the instance with its fields   Interfaces  Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.   A type doesn\u2019t have to state explicitly that it implements an interface: interfaces are satisfied implicitly. Multiple types can implement the same interface.  A type that implements an interface can also have other functions.   A type can implement many interfaces.  An interface type can contain a reference to an instance of any of the types that implement the interface (an interface has what is called a dynamic type)   The interface variable both contains the value of the receiver instance and a pointer to the appropriate method in a method table.   interfaces_poly.go   Interface embedding interfaces  An interface can contain the name of one or more other interface(s), which is equivalent to explicitly enumerating the methods of the embedded interface in the containing interface. [TWTG p270]  Detect and convert the type of an interface variable: type assertions  We can test if  varI  (interface variable) contains at a certain moment a variable of type  T  with the type assertion test [TWTG p271]:  if   v ,   ok   :=   varI .( T );   ok   { \n     // checked type assertion  }    type_interfaces.go   The type switch   Type switch    Testing if a value implements an interface  v  is a value and we want to test whether it implements the  Stringer  interface:  if   sv ,   ok   :=   v .( Stringer );   ok   { \n     fmt . Printf ( \u201c v   implements   String ():   % s \\ n \u201d ,   sv . String ());   // note: sv, not v  }   Writing functions so that they accept an interface variable as a parameter makes them more general. Use interfaces to make code more generally applicable.  Variables of interface type  A variable of interface type stores a pair: the concrete value assigned to the variable, and that value's type descriptor.   The representation of an interface   Using method sets with interfaces   Pointer methods can be called with pointers.  Value methods can be called with values.  Value-receiver methods can be called with pointer values because they can be dereferenced first.  Pointer-receiver methods  cannot  be called with values, however, because the value stored inside an interface has no address.   Examples:   methodset2.go  sort.go  sortmain.go   Empty Interface  A variable of empty interface type  interface{}  can through assignment receive a variable of any type.  Interface Slice   Interface slice   Interface to interface  An interface value can also be assigned to another interface value, as long as the underlying value implements the necessary methods.    Reflection  Reflection is the ability of a program to examine its own structure, particularly through the types; it\u2019s a form of  metaprogramming .  reflect  can be used to investigate types and variables at runtime, e.g. its size, its methods, and it can also call these methods \"dynamically\".   reflect.TypeOf  reflect.ValueOf     v.Kind() : returns a constant indicating the type  v.Interface() : recovers the (interface) value   Example:   reflect1.go   Setting a value through reflection   Settability : a  Value  can be changed only if it is addressable and was not obtained by the use of unexported struct fields,  reflect2.go   Reflection on structs   reflect_struct.go   Printf  and reflection  Printf  uses the reflection package to unpack it and discover the argument list,  print.go  Interfaces and dynamic typing   In Go there are no classes: data (structures, or more general types) and methods are treated  orthogonally , they are much more  loosely coupled .  There is no requirement for explicitly declaring that a type satisfies an interface. This allows interfaces to be defined and used without having to modify existing code.  Types implementing an interface can be passed to any function which takes that interface as an argument. This resembles much more the  duck typing  in dynamic languages.  Extraction of an interface reduces thereby the number of types and methods needed [TWTG p301]:  multi_interfaces_poly.go  If a type must implement a new interface, the type itself doesn\u2019t have to be changed, you must only make the new method(s) on the type. [TWTG p303]    Empty interface and function overloading [TWTG p304]  Inheritance of interfaces:  A type includes (embeds) another type (which implements one or more interfaces) as a pointer, then the type can use all of the interfaces-methods. [TWTG p304]  A type can also inherit from multiple interfaces providing something like  multiple inheritance . [TWTG p305]     Summary of object-orientedness of Go  [TWTG p306]   Encapsulation (data hiding): visibility rule  Package scope : lowercase  Exported : uppercase    Inheritance: embedding one or multiple types  Polymorphism: a variable of a type can be assigned to a variable of any interface it implements. Types and interfaces are loosely coupled; multiple inheritance is possible through implementing multiple interfaces   Higher order functions  [TWTG p306-309]   References   [TWTG]  The Way To Go: A Thorough Introduction To The Go Programming Language  [EG]  Effective Go  [TGB]  The Go Blog", 
            "title": "Golang"
        }, 
        {
            "location": "/bash/", 
            "text": "Bash\n\n\n\n\nReferences\n\n\n\n\nThe GNU Bash Reference Manual\n\n\nBash Hackers Wiki", 
            "title": "Bash"
        }, 
        {
            "location": "/bash/#bash", 
            "text": "References   The GNU Bash Reference Manual  Bash Hackers Wiki", 
            "title": "Bash"
        }, 
        {
            "location": "/c/", 
            "text": "C\n\n\n\n\nIf you think like a computer, writing C actually makes sense. \n\n Linus Torvalds \n\n\n\n\nFirst-class ADT\n\n\nBad:\n\n\n/* Include guards and include files omitted. */\n\n\n\n#define MAX_NO_OF_ORDERS 42\n\n\n\n/* Internal representation of a customer. */\n\n\n\ntypedef\n \nstruct\n\n\n\n{\n\n    \nconst\n \nchar\n*\n \nname\n;\n\n    \nAddress\n \naddress\n;\n\n    \nsize_t\n \nnoOfOrders\n;\n\n    \nOrder\n \norders\n[\nMAX_NO_OF_ORDERS\n];\n\n\n}\n \nCustomer\n;\n\n\n\nvoid\n \ninitCustomer\n(\nCustomer\n*\n \ntheCustomer\n,\n\n                  \nconst\n \nchar\n*\n \nname\n,\n\n                  \nconst\n \nAddress\n*\n \naddress\n);\n\n\n\nvoid\n \nplaceOrder\n(\nCustomer\n \n*\ncustomer\n,\n \nconst\n \nOrder\n*\n \norder\n);\n\n\n\n/* A lot of other related functions... */\n\n\n\n\n\n\nGood:\n\n\n\n\n1_FirstClassADT\n\n\n\n\nInformation hiding\n\n\nThe First-class ADT pattern will eliminate dependency problems. Thuis pattern provides a method that separates interface from implementation.\n\n\nIncomplete Types\n\n\nThe C standard (C99) allows us to declare objects of incomplete types in a context where their sizes aren\u2019t needed. \n\n\nIn the following code:\n\n\n/* Pointer to an incomplete type */\n\n\ntypedef\n \nstruct\n \nCustomer\n*\n \nCustomerPtr\n;\n\n\n\n\n\n\nInstances of this pointer will serve as a handle for the clients of a first-class ADT. This mechanism enforces the constraint on clients to use the provided interface functions (\nCustomer.h\n) because there is no way a client can access a field in the \nCustomer\n structure (the C language \ndoes not allow an incomplete type to be de-referenced\n). The type is considered complete as soon as the compiler detects a subsequent specifier (\nCustomer.c\n), with the same tag, and a declaration list containing the members.\n\n\nCopy Semantics\n\n\nClients only use a handle, which is declared as a pointer, to the ADT. Copies of a handle are simply pointer assignment.\n\n\nDependencies managed\n\n\nInternals of the data structure are encapsulated in the implementation and clients cannot access them. \n\n\nConsequences\n\n\nPros:\n\n\n\n\nImproved encapsulation\n\n\nLoose coupling\n\n\nControlled construction and destruction\n\n\n\n\nCons:\n\n\n\n\nExtra level of indirection\n\n\nIncreased dynamic memory usage\n\n\n\n\n\n\nReferences\n\n\n\n\n[PIC]: \nPatterns in C", 
            "title": "C"
        }, 
        {
            "location": "/c/#c", 
            "text": "If you think like a computer, writing C actually makes sense.   Linus Torvalds    First-class ADT  Bad:  /* Include guards and include files omitted. */  #define MAX_NO_OF_ORDERS 42  /* Internal representation of a customer. */  typedef   struct  { \n     const   char *   name ; \n     Address   address ; \n     size_t   noOfOrders ; \n     Order   orders [ MAX_NO_OF_ORDERS ];  }   Customer ;  void   initCustomer ( Customer *   theCustomer , \n                   const   char *   name , \n                   const   Address *   address );  void   placeOrder ( Customer   * customer ,   const   Order *   order );  /* A lot of other related functions... */   Good:   1_FirstClassADT   Information hiding  The First-class ADT pattern will eliminate dependency problems. Thuis pattern provides a method that separates interface from implementation.  Incomplete Types  The C standard (C99) allows us to declare objects of incomplete types in a context where their sizes aren\u2019t needed.   In the following code:  /* Pointer to an incomplete type */  typedef   struct   Customer *   CustomerPtr ;   Instances of this pointer will serve as a handle for the clients of a first-class ADT. This mechanism enforces the constraint on clients to use the provided interface functions ( Customer.h ) because there is no way a client can access a field in the  Customer  structure (the C language  does not allow an incomplete type to be de-referenced ). The type is considered complete as soon as the compiler detects a subsequent specifier ( Customer.c ), with the same tag, and a declaration list containing the members.  Copy Semantics  Clients only use a handle, which is declared as a pointer, to the ADT. Copies of a handle are simply pointer assignment.  Dependencies managed  Internals of the data structure are encapsulated in the implementation and clients cannot access them.   Consequences  Pros:   Improved encapsulation  Loose coupling  Controlled construction and destruction   Cons:   Extra level of indirection  Increased dynamic memory usage    References   [PIC]:  Patterns in C", 
            "title": "C"
        }, 
        {
            "location": "/iptables/", 
            "text": "iptables\n\n\n\n\nReferences\n\n\n\n\n[ITT]: \nIptables Tutorial 1.2.2", 
            "title": "iptables"
        }, 
        {
            "location": "/iptables/#iptables", 
            "text": "References   [ITT]:  Iptables Tutorial 1.2.2", 
            "title": "iptables"
        }, 
        {
            "location": "/nginx/", 
            "text": "Nginx\n\n\n\n\nReferences\n\n\n\n\n[ND]: \nnginx documentation\n\n\n[NTAG]: \nNGINX and NGINX Plus Tutorial and Admin Guide", 
            "title": "Nginx"
        }, 
        {
            "location": "/nginx/#nginx", 
            "text": "References   [ND]:  nginx documentation  [NTAG]:  NGINX and NGINX Plus Tutorial and Admin Guide", 
            "title": "Nginx"
        }, 
        {
            "location": "/vim/", 
            "text": "Vim\n\n\n\n\nReferences\n\n\n\n\n[LVVE]: Learning the vi and Vim Editors, 7th Edition\n\n\n[LVHW]: \nLearn Vimscript the Hard Way", 
            "title": "Vim"
        }, 
        {
            "location": "/vim/#vim", 
            "text": "References   [LVVE]: Learning the vi and Vim Editors, 7th Edition  [LVHW]:  Learn Vimscript the Hard Way", 
            "title": "Vim"
        }
    ]
}