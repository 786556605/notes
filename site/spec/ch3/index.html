<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/spec/ch3/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 3. Operating Systems - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../lkd/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch5/">Chapter 5. System Calls</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch6/">Chapter 6. Kernel Data Structures</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch7/">Chapter 7. Interrupts and Interrupt Handlers</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch8/">Chapter 8. Bottom Halves and Deferring Work</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch9/">Chapter 9. An Introduction to Kernel Synchronization</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch10/">Chapter 10. Kernel Synchronization Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch11/">Chapter 11. Timers and Time Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch12/">Chapter 12. Memory Management</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch13/">Chapter 13. The Virtual Filesystem</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch14/">Chapter 14. The Block I/O Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch15/">Chapter 15. The Process Address Space</a>
                        </li>
                      
                        <li>
                            <a href="../../lkd/ch16/">Chapter 16. The Page Cache and Page Writeback</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/spec/ch3.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-3-operating-systems">Chapter 3. Operating Systems</a></li>
        
    
        <li class="main "><a href="#terminology">Terminology</a></li>
        
    
        <li class="main "><a href="#background">Background</a></li>
        
            <li><a href="#kernel">Kernel</a></li>
        
            <li><a href="#stacks">Stacks</a></li>
        
            <li><a href="#interrupts-and-interrupt-threads">Interrupts and Interrupt Threads</a></li>
        
            <li><a href="#interrupt-priority-level">Interrupt Priority Level</a></li>
        
            <li><a href="#processes">Processes</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-3-operating-systems"><strong>Chapter 3. Operating Systems</strong><a class="headerlink" href="#chapter-3-operating-systems" title="Permanent link">&para;</a></h3>
<p>An understanding of the operating system and its kernel is essential for systems
performance analysis, such as:</p>
<ul>
<li>How system calls are being performed,</li>
<li>How CPUs are scheduling threads,</li>
<li>How limited memory could be affecting performance,</li>
<li>How a file system processes I/O.</li>
</ul>
<p>This chapter has two parts:</p>
<ul>
<li><strong>Background</strong> introduces terminology and operating system fundamentals.</li>
<li><strong>Kernels</strong> summarizes Linux and Solaris-based kernels.</li>
</ul>
<h3 id="terminology">Terminology<a class="headerlink" href="#terminology" title="Permanent link">&para;</a></h3>
<p>The following is the core operating system terminology in this book:</p>
<ul>
<li><strong>Operating system</strong>: This refers to the software and files that are installed on a system so that it can boot and execute programs. It includes the kernel, administration tools, and system libraries.</li>
<li><strong>Kernel</strong>: the program that manages the system, including devices (hardware), memory, and CPU scheduling. It runs in a privileged CPU mode that allows direct access to hardware, called <strong>kernel mode</strong>.</li>
<li><strong>Process</strong>: an OS abstraction and environment for executing a program. The program normally runs in <strong>user mode</strong>, with access to kernel mode (e.g., for performing device I/O) via <strong>system calls</strong> or <strong>traps</strong>.</li>
<li><strong>Thread</strong>: an executable context that can be scheduled to run on a CPU. The kernel has multiple threads, and a process contains one or more.</li>
<li><strong>Task</strong>: a Linux runnable entity, which can refer to a process (with a single thread), a thread from a multithreaded process, or kernel threads.</li>
<li><strong>Kernel-space</strong>: the memory address space for the kernel.</li>
<li><strong>User-space</strong>: the memory address space for processes.</li>
<li><strong>User-land</strong>: user-level programs and libraries (/usr/bin, /usr/lib, . . .).</li>
<li><strong>Context switch</strong>: a kernel routine that switches a CPU to operate in a different address space (context).</li>
<li><strong>System call (syscall)</strong>: a well-defined protocol for user programs to request the kernel to perform privileged operations, including device I/O.</li>
<li><strong>Processor</strong>: a physical chip containing one or more CPUs.</li>
<li><strong>Trap</strong>: a signal sent to the kernel, requesting a system routine (privileged action). Trap types include system calls, processor exceptions, and interrupts.</li>
<li><strong>Interrupt</strong>: a signal sent by physical devices to the kernel, usually to request servicing of I/O. An interrupt is a type of trap.</li>
</ul>
<h3 id="background">Background<a class="headerlink" href="#background" title="Permanent link">&para;</a></h3>
<p>The following sections describe operating system concepts and kernel internals.</p>
<h4 id="kernel">Kernel<a class="headerlink" href="#kernel" title="Permanent link">&para;</a></h4>
<p>The kernel manages CPU scheduling, memory, file systems, network protocols, and system devices (disks, network interfaces, etc.). It provides access to devices and kernel services via system calls. The role of the kernel is shown in the following figure:</p>
<p><a href="../figure_3.1.png" title="Figure 3.1 Role of the operating system kernel"><img alt="Figure 3.1 Role of the operating system kernel" src="../figure_3.1.png" /></a></p>
<ul>
<li>System libraries are often used to provide a richer and easier programming interface than the system calls alone.<ul>
<li>It is pictured as a broken ring to show that applications can call system calls directly (if permitted by the operating system). [p87]</li>
</ul>
</li>
<li>Applications include all running user-level software, including databases, web servers, administration tools, and operating system shells.</li>
</ul>
<h5 id="kernel-execution"><strong>Kernel Execution</strong><a class="headerlink" href="#kernel-execution" title="Permanent link">&para;</a></h5>
<p>The kernel is a large program, which primarily executes on demand, when a user-level program makes a system call or a device sends an interrupt. <u>Some kernel threads operate asynchronously for housekeeping, which may include the kernel clock routine and memory management tasks, but these try to be lightweight and consume very little CPU resources.</u></p>
<ul>
<li>Workloads that perform frequent I/O frequently execute in kernel context.</li>
<li>Workloads that are compute-intensive are left alone as much as possible by the kernel, so they can run uninterrupted on-CPU.</li>
</ul>
<p>It may be tempting to think that the kernel cannot affect the performance of these workloads, but there are many cases where it does. The most obvious is CPU contention, when other threads are competing for CPU resources and the kernel scheduler needs to decide which will run and which will wait. The kernel also chooses which CPU a thread will run on and can choose CPUs with warmer hardware caches or better memory locality for the process, to significantly improve performance.</p>
<h5 id="clock"><strong>Clock</strong><a class="headerlink" href="#clock" title="Permanent link">&para;</a></h5>
<p>A core component of the original Unix kernel is the <code>clock()</code> routine, executed from a timer interrupt. It has historically been executed at 60, 100, or 1,000 times per second (250 for Linux 2.6.13) and each execution is called a <em>tick</em>. Its functions include:</p>
<ul>
<li>Updating the system time</li>
<li>Expiring timers and time slices for thread scheduling</li>
<li>Maintaining CPU statistics</li>
<li>Executing <em>callouts</em> (scheduled kernel routines)</li>
</ul>
<p>Some performance issues with the clock are improved in later kernels, including:</p>
<ul>
<li><strong>Tick latency</strong>: For 100 Hz clocks, up to 10 ms of additional latency may be encountered for a timer as it waits to be processed on the next tick. This has been fixed using high-resolution real-time interrupts, so that execution occurs immediately without waiting.</li>
<li><strong>Tick overhead</strong>: Modern processors have dynamic power features, which can power down parts during idle periods. The clock routine interrupts this process, which for idle systems can consume power needlessly. Linux has implemented <a href="https://www.kernel.org/doc/Documentation/timers/highres.txt">dynamic ticks</a>, so that when the system is idle, the timer routine (clock) does not fire.</li>
</ul>
<p>Modern kernels have moved much functionality out of the clock routine to on-demand interrupts, in an effort to create a <em>tickless kernel</em>. This includes Linux, where the clock routine (which is the <em>system timer interrupt</em>) performs little work other than updating the system clock and jiffies counter (<em>jiffies</em> is a Linux unit of time, similar to <em>ticks</em>).</p>
<h5 id="kernel-mode"><strong>Kernel Mode</strong><a class="headerlink" href="#kernel-mode" title="Permanent link">&para;</a></h5>
<p>The <strong>kernel mode</strong> is a special CPU mode, where the kernel is running. This mode allows full access to devices and the execution of privileged instructions. The kernel arbitrates device access to support multitasking, preventing processes and users from accessing each other's data unless explicitly allowed.</p>
<p>User programs (processes) run in <strong>user mode</strong>, where they request privileged operations (e.g. I/O) from the kernel via system calls. To perform a system call, execution will <em>mode-switch</em> from user to kernel mode, and then execute with the higher privilege level.</p>
<p><a href="../figure_3.2.png" title="Figure 3.2 System call execution modes"><img alt="Figure 3.2 System call execution modes" src="../figure_3.2.png" /></a></p>
<p>Each mode has its own software execution state including a stack and registers. The execution of privileged instructions in user mode causes <strong>exceptions</strong>, which are then properly handled by the kernel.</p>
<p>The switch between these modes takes time (CPU cycles), which adds a small amount of overhead for each I/O. Some services, such as NFS, have been implemented as kernel-mode software (instead of a user-mode daemon), so that they can perform I/O from and to devices without needing to switch to user mode.</p>
<p>If the system call blocks during execution, the process may switch off CPU and be replaced by another: a <strong>context-switch</strong>.</p>
<h4 id="stacks">Stacks<a class="headerlink" href="#stacks" title="Permanent link">&para;</a></h4>
<p>A stack contains the execution ancestry for a thread in terms of functions and registers. <u>Stacks are used by CPUs for efficient processing of function execution in native software.</u></p>
<p>When a function is called:</p>
<ol>
<li>The current set of CPU registers (which store the state of the CPU) is saved to the stack.</li>
<li>A new stack frame is added to the top for the current execution of the thread.</li>
</ol>
<p>When a function ends the execution and returns, it calls a "return" CPU instruction, which removes the current stack and returns execution to the previous one, restoring its state.</p>
<p>Stack inspection is an invaluable tool for debugging and performance analysis. Stacks show the call path to current execution, which often answers <em>why</em> something is executing.</p>
<h5 id="how-to-read-a-stack"><strong>How to Read a Stack</strong><a class="headerlink" href="#how-to-read-a-stack" title="Permanent link">&para;</a></h5>
<p>The following example kernel stack (from Linux) shows the path taken for TCP transmission, as printed by a debugging tool:</p>
<div class="codehilite"><pre>kernel`tcp_sendmsg+0x1
kernel`inet_sendmsg+0x64
kernel`sock_aio_write+0x13a
kernel`do_sync_write+0xd2
kernel`security_file_permission+0x2c
kernel`rw_verify_area+0x61
kernel`vfs_write+0x16d
kernel`sys_write+0x4a
kernel`sys_rt_sigprocmask+0x84
kernel`system_call_fastpath+0x16
</pre></div>


<p>The top of the stack is shown as the first line. In this example, <code>tcp_sendmsg</code> is the name of the function currently executing. To the left and right of the function name are details typically included by debuggers:</p>
<ul>
<li>The kernel module location (<code>kernel</code>).</li>
<li>The instruction offset (<code>0x1</code>, which refers to the address of the instruction within the function).</li>
</ul>
<p>The function that called <code>tcp_sendmsg()</code>, its parent, is <code>inet_sendmsg</code>.</p>
<ul>
<li>By reading down the stack, the full ancestry can be seen: function, parent, grandparent, and so on.</li>
<li>By reading bottom-up, you can follow the path of execution to the current function: how we got here.</li>
</ul>
<p>[p90]</p>
<h5 id="user-and-kernel-stacks"><strong>User and Kernel Stacks</strong><a class="headerlink" href="#user-and-kernel-stacks" title="Permanent link">&para;</a></h5>
<p>While executing a system call, a process thread has two stacks: a user-level stack and a kernel-level stack. This is shown in the figure below:</p>
<p><a href="../figure_3.3.png" title="Figure 3.3 User and kernel stacks"><img alt="Figure 3.3 User and kernel stacks" src="../figure_3.3.png" /></a></p>
<p>The user-level stack of the blocked thread does not change for the duration of a system call, as the thread is using a separate kernel-level stack while executing in kernel context. An exception is signal handlers, which may borrow a user-level stack depending on their configuration.</p>
<h4 id="interrupts-and-interrupt-threads">Interrupts and Interrupt Threads<a class="headerlink" href="#interrupts-and-interrupt-threads" title="Permanent link">&para;</a></h4>
<p>Besides responding to system calls, the kernel also responds to service requests from devices, called <strong>interrupts</strong>, which is shown in the figure below:</p>
<p><a href="../figure_3.4.png" title="Figure 3.4 Interrupt processing"><img alt="Figure 3.4 Interrupt processing" src="../figure_3.4.png" /></a></p>
<p>An <a href="https://en.wikipedia.org/wiki/Interrupt_handler"><strong>interrupt service routine</strong></a> (or <strong>interrupt handler</strong>) is registered to process the device interrupt. It is designed to operate as quickly as possible, to reduce the effects of interrupting active threads. If an interrupt needs to perform work, especially if it may block on locks, it can be processed by an interrupt thread that can be scheduled by the kernel.</p>
<ul>
<li>On Linux, device drivers are modeled as two halves, with the top half handling the interrupt quickly, and scheduling work to a bottom half to be processed later.<ul>
<li>The top half runs in <em>interrupt-disabled</em> mode to postpone the delivery of new interrupts, which can cause latency problems for other threads if it runs for too long.</li>
<li>The bottom half can be either <em>tasklets</em> or <em>work queues</em>; the latter are threads that can be scheduled by the kernel and can sleep when necessary.</li>
</ul>
</li>
<li>Solaris-based systems promote interrupts to interrupt threads if more work needs to be performed</li>
</ul>
<p>The <em>interrupt latency</em> is the time from an interrupt arrival to when it is serviced. This is a subject of study for real-time or low-latency systems.</p>
<h4 id="interrupt-priority-level">Interrupt Priority Level<a class="headerlink" href="#interrupt-priority-level" title="Permanent link">&para;</a></h4>
<p>The <a href="https://en.wikipedia.org/wiki/Interrupt_priority_level">interrupt priority level</a> (IPL) represents the priority of the currently active interrupt service routine. It is read from the processor during the delivery of an interrupt signal, and the interrupt succeeds only if its level exceeds the currently executing interrupt (if any); otherwise the interrupt is queued for later delivery.  This prevents higher-priority work from being interrupted by lower-priority work.</p>
<p>An example IPL range is shown in the figure below:</p>
<p><a href="../figure_3.5.png" title="Figure 3.5 Example interrupt priority level range"><img alt="Figure 3.5 Example interrupt priority level range" src="../figure_3.5.png" /></a></p>
<p><a href="https://en.wikipedia.org/wiki/Serial_communication">Serial I/O</a> has a high interrupt because its hardware buffer is usually small and needs quick servicing to avoid overflows.</p>
<h4 id="processes">Processes<a class="headerlink" href="#processes" title="Permanent link">&para;</a></h4>
<p>A process is an environment for executing a user-level program. It consists of:</p>
<ul>
<li>Memory address space</li>
<li>File descriptors</li>
<li>Thread stacks</li>
<li>Registers</li>
</ul>
<p>A process is like a "virtual early computer", where only one program is executing, with its own registers and stacks.</p>
<p>Processes are multitasked by the kernel, which typically supports the execution of thousands of processes on a single system. They are individually identified by their <strong>process ID</strong> (PID), which is a unique numeric identifier.</p>
<p>A process contains one or more <strong>threads</strong>:</p>
<ul>
<li>Threads operate in the process address space and share the same file descriptors.</li>
<li>A thread is an executable context consisting of a stack, registers, and program counter.</li>
<li>Multiple threads allow a single process to execute in parallel across multiple CPUs.</li>
</ul>
<h5 id="process-creation"><strong>Process Creation</strong><a class="headerlink" href="#process-creation" title="Permanent link">&para;</a></h5>
<p>Processes are normally created using the <code>fork()</code> system call. This creates a duplicate of the process, with its own process ID. The <code>exec()</code> system call can then be called to begin execution of a different program.</p>
<p>The following figure shows an example process creation for the shell (<code>sh</code>) executing the ls command:</p>
<p><a href="../figure_3.6.png" title="Figure 3.6 Process creation"><img alt="Figure 3.6 Process creation" src="../figure_3.6.png" /></a></p>
<p>The <code>fork()</code> syscall may use a <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> (COW) strategy to improve performance, which adds references to the previous address space rather than copying all of the contents. Once either process modifies the multiply-referenced memory, a separate copy is then made for the modifications. This strategy either defers or eliminates the need to copy memory, reducing memory and CPU usage.</p>
<h5 id="process-life-cycle"><strong>Process Life Cycle</strong><a class="headerlink" href="#process-life-cycle" title="Permanent link">&para;</a></h5>
<p>The life cycle of a process is shown in a simplified diagram below:</p>
<p><a href="../figure_3.7.png" title="Figure 3.7 Process life cycle"><img alt="Figure 3.7 Process life cycle" src="../figure_3.7.png" /></a></p>
<p>On modern multithreaded operating systems, it is the threads that are scheduled and run. There are also some additional implementation details regarding how these map to process states.</p>
<ul>
<li>The <strong>on-proc state</strong> is for running on a processor (CPU).</li>
<li>The <strong>ready-to-run</strong> state is when the process is runnable but is waiting on a CPU run queue for its turn on a CPU.</li>
<li>I/O will block, putting the process in the <strong>sleep state</strong> until the I/O completes and the process is woken up.</li>
<li>The <strong>zombie state</strong> occurs during process termination, when the process waits until its process status has been read by the parent process, or until it is removed by the kernel.</li>
</ul>
<h5 id="process-environment"><strong>Process Environment</strong><a class="headerlink" href="#process-environment" title="Permanent link">&para;</a></h5>
<p>The process environment is shown in the figure below. It consists of data in the address space of the process and metadata (context) in the kernel.</p>
<p><a href="../figure_3.8.png" title="Figure 3.8 Process environment"><img alt="Figure 3.8 Process environment" src="../figure_3.8.png" /></a></p>
<p>The kernel context consists of various process properties and statistics (commonly examined via the <code>ps(1)</code> command):</p>
<ul>
<li>Process ID (PID)</li>
<li>Owner's user ID (UID)</li>
<li>Various times</li>
<li>A set of file descriptors, which refer to open files and which are (usually) shared between threads.</li>
</ul>
<p>The above figure pictures two threads, each containing some metadata, including a priority in kernel context and its stack in the user address space.</p>
<p>Note the diagram in this figure is not drawn to scale; the kernel context is very small compared to the process address space.</p>
<p>The user address space contains memory segments of the process: executable, libraries, and heap, which are detailed in <a href="../ch7/">Chapter 7 Memory</a>.</p>
<h3 id="doubts-and-solutions">Doubts and Solutions<a class="headerlink" href="#doubts-and-solutions" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<h5 id="p88-on-kernel-clock-routine"><strong>p88 on kernel <code>clock()</code> routine</strong><a class="headerlink" href="#p88-on-kernel-clock-routine" title="Permanent link">&para;</a></h5>
<blockquote>
<p>Linux has implemented <a href="https://www.kernel.org/doc/Documentation/timers/highres.txt">dynamic ticks</a>, so that when the system is idle, the timer routine (clock) does not fire.</p>
</blockquote>
<p><span class="text-danger">Question</span>: Need in-depth understanding of dynamic ticks.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>