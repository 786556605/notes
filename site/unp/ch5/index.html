<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/unp/ch5/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 5. TCP Client/Server Example - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                    
                        <li >
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UTLK <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../utlk/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../utlk/ch2/">Chapter 2. Memory Addressing</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../lkd/ch1/">Chapter 1. Introduction to the Linux Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch2/">Chapter 2. Getting Started with the Kernel</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch3/">Chapter 3. Process Management</a>
                        </li>
                    
                        <li >
                            <a href="../../lkd/ch4/">Chapter 4. Process Scheduling</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                    
                        <li >
                            <a href="../ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                    
                        <li class="active">
                            <a href="./">Chapter 5. TCP Client/Server Example</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">ICND <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../icnd1/part1/">ICND1 Part I: Networking Fundamentals</a>
                        </li>
                    
                        <li >
                            <a href="../../icnd2/part1/">ICND2 Part I: LAN Switching</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                    
                        <li >
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../../htae/">HTAE</a>
                        </li>
                    
                        <li >
                            <a href="../../golang/">Go</a>
                        </li>
                    
                        <li >
                            <a href="../../bash/">Bash</a>
                        </li>
                    
                        <li >
                            <a href="../../c/">C</a>
                        </li>
                    
                        <li >
                            <a href="../../iptables/">iptables</a>
                        </li>
                    
                        <li >
                            <a href="../../nginx/">Nginx</a>
                        </li>
                    
                        <li >
                            <a href="../../vim/">Vim</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="https://github.com/shichao-an/notes">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-5-tcp-clientserver-example">Chapter 5. TCP Client/Server Example</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#tcp-echo-server-main-function">TCP Echo Server: main Function</a></li>
        
    
        <li class="main "><a href="#tcp-echo-server-str_echo-function">TCP Echo Server: str_echo Function</a></li>
        
    
        <li class="main "><a href="#tcp-echo-client-main-function">TCP Echo Client: main Function</a></li>
        
    
        <li class="main "><a href="#tcp-echo-client-str_cli-function">TCP Echo Client: str_cli Function</a></li>
        
    
        <li class="main "><a href="#normal-startup">Normal Startup</a></li>
        
            <li><a href="#start-the-server-in-the-background">Start the server in the background</a></li>
        
            <li><a href="#run-netstat">Run netstat</a></li>
        
            <li><a href="#start-the-client-on-the-same-host">Start the client on the same host</a></li>
        
            <li><a href="#run-netstat-after-connection-completes">Run netstat after connection completes</a></li>
        
            <li><a href="#run-ps-to-check-process-status-and-relationship">Run ps to check process status and relationship</a></li>
        
    
        <li class="main "><a href="#normal-termination">Normal Termination</a></li>
        
    
        <li class="main "><a href="#posix-signal-handling">POSIX Signal Handling</a></li>
        
    
        <li class="main "><a href="#signal-function">signal Function</a></li>
        
            <li><a href="#simplify-function-prototype-using-typedef">Simplify function prototype using typedef</a></li>
        
            <li><a href="#set-handler">Set handler</a></li>
        
            <li><a href="#set-signal-mask-for-handler">Set signal mask for handler</a></li>
        
            <li><a href="#set-sa_restart-flag">Set SA_RESTART flag</a></li>
        
            <li><a href="#call-sigaction">Call sigaction</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-5-tcp-clientserver-example"><strong>Chapter 5. TCP Client/Server Example</strong></h3>
<h3 id="introduction">Introduction</h3>
<p>We will now use the elementary functions from the previous chapter to write a complete TCP client/server example. Our simple example is an echo server that performs the following steps:</p>
<ol>
<li>The client reads a line of text from its standard input and writes the line to the server.</li>
<li>The server reads the line from its network input and echoes the line back to the client.</li>
<li>The client reads the echoed line and prints it on its standard output.</li>
</ol>
<p>The figure below depcits this simple client/server:</p>
<p><a href="../figure_5.1.png" title="Figure 5.1. Simple echo client and server."><img alt="Figure 5.1. Simple echo client and server." src="../figure_5.1.png" /></a></p>
<p>Despite two arrows between the client and server in the above figure, it is really a <a href="../../unp/ch2/#transmission-control-protocol-tcp">full-duplex</a> TCP connection. <code>fgets</code> and <code>fputs</code> functions are from the standard I/O library. <code>writen</code> and <code>readline</code> functions were shown in <a href="../../unp/ch3/#readn-writen-and-readline-functions">Section 3.9</a>.</p>
<p>The echo client/server is a valid, simple example of a network application. To expand this example into your own application, all you need to do is change what the server does with the input it receives from its clients.</p>
<p>Besides running the client/server in normal mode (type in a line and watch it echo), we examine lots of boundary conditions:</p>
<ul>
<li>What happens when the client and server are started?</li>
<li>What happens when the client terminates normally?</li>
<li>What happens to the client if the server process terminates before the client is done?</li>
<li>What happens to the client if the server host crashes?</li>
</ul>
<p>In all these examples, we have "hard-coded" protocol-specific constants such as addresses and ports. There are two reasons for this:</p>
<ul>
<li>We must understand exactly what needs to be stored in the protocol-specific address structures</li>
<li>We have not yet covered the library functions that can make this more portable</li>
</ul>
<h3 id="tcp-echo-server-main-function">TCP Echo Server: <code>main</code> Function</h3>
<p>Our TCP client and server follow the flow of functions that we diagrammed in <a href="../figure_4.1.png">Figure 4.1</a>. The below code is the concurrent server program:</p>
<ul>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpserv01.c">tcpcliserv/tcpserv01.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include    &quot;unp.h&quot;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                 <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="kt">pid_t</span>               <span class="n">childpid</span><span class="p">;</span>
    <span class="kt">socklen_t</span>           <span class="n">clilen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">cliaddr</span><span class="p">,</span> <span class="n">servaddr</span><span class="p">;</span>

    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span>      <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span>        <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>

    <span class="n">Bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>

    <span class="n">Listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">clilen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* child process */</span>
            <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>    <span class="cm">/* close listening socket */</span>
            <span class="n">str_echo</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>   <span class="cm">/* process the request */</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>          <span class="cm">/* parent closes connected socket */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Create socket, bind server's well-known port</strong><ul>
<li>A TCP socket is created.</li>
<li>An Internet socket address structure is filled in with the wildcard address (<code>INADDR_ANY</code>) and the server's well-known port (<code>SERV_PORT</code>, which is defined as 9877 in our <a href="https://github.com/shichao-an/unpv13e/blob/master/lib/unp.h#L200">unp.h</a> header). Binding the wildcard address tells the system that we will accept a connection destined for any local interface, in case the system is multihomed. Our choice of the TCP port number is based on <a href="../figure_2.10.png">Figure 2.10</a> in <a href="../../unp/ch2/#port-numbers">Section 2.9</a>. It should be greater than 1023 (we do not need a reserved port), greater than 5000 (to avoid conflict with the ephemeral ports allocated by many Berkeley-derived implementations), less than 49152 (to avoid conflict with the "correct" range of ephemeral ports), and it should not conflict with any registered port.  [p122]</li>
<li>The socket is converted into a listening socket by <code>listen</code>.</li>
</ul>
</li>
<li><strong>Wait for client connection to complete</strong><ul>
<li>The server blocks in the call to <code>accept</code>, waiting for a client connection to complete.</li>
</ul>
</li>
<li><strong>Concurrent server</strong><ul>
<li>For each client, <code>fork</code> spawns a child, and the child handles the new client. The child closes the listening socket and the parent closes the connected socket. (<a href="../../unp/ch4/#concurrent-servers">Section 4.8</a>)</li>
</ul>
</li>
</ul>
<h3 id="tcp-echo-server-str_echo-function">TCP Echo Server: <code>str_echo</code> Function</h3>
<p>The function <code>str_echo</code> performs the server processing for each client: It reads data from the client and echoes it back to the client.</p>
<ul>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/str_echo.c">lib/str_echo.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include    &quot;unp.h&quot;</span>

<span class="kt">void</span>
<span class="nf">str_echo</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ssize_t</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span>        <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

<span class="nl">again</span><span class="p">:</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;str_echo: read error&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Read a buffer and echo the buffer</strong><ul>
<li><code>read</code> reads data from the socket and the line is echoed back to the client by <code>writen</code>. If the client closes the connection (the normal scenario), <u>the receipt of the client's FIN causes the child's read to return 0.</u> This causes the <code>str_echo</code> function to return, which terminates the child.</li>
</ul>
</li>
</ul>
<h3 id="tcp-echo-client-main-function">TCP Echo Client: <code>main</code> Function</h3>
<ul>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpcli01.c">tcpcliserv/tcpcli01.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include    &quot;unp.h&quot;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                 <span class="n">sockfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">servaddr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span><span class="p">);</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>
    <span class="n">Inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>

    <span class="n">Connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>

    <span class="n">str_cli</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>     <span class="cm">/* do it all */</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Create socket, fill in Internet socket address structure</strong><ul>
<li>A TCP socket is created and an Internet socket address structure is filled in with the server's IP address and port number. The server's IP address is taken from the command-line argument and the server's well-known port (<code>SERV_PORT</code>) is from our <code>unp.h</code> header.</li>
</ul>
</li>
<li><strong>Connect to server</strong><ul>
<li><code>connect</code> establishes the connection with the server. The function <code>str_cli</code> handles the rest of the client processing.</li>
</ul>
</li>
</ul>
<h3 id="tcp-echo-client-str_cli-function">TCP Echo Client: <code>str_cli</code> Function</h3>
<p>The <code>str_cli</code> function handles the client processing loop: It reads a line of text from standard input, writes it to the server, reads back the server's echo of the line, and outputs the echoed line to standard output.</p>
<ul>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/str_cli.c">lib/str_cli.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include    &quot;unp.h&quot;</span>

<span class="kt">void</span>
<span class="nf">str_cli</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span>    <span class="n">sendline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">recvline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">Fgets</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sendline</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sendline</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Readline</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;str_cli: server terminated prematurely&quot;</span><span class="p">);</span>

        <span class="n">Fputs</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Read a line, write to server</strong><ul>
<li><code>fgets</code> reads a line of text and <code>writen</code> sends the line to the server.</li>
</ul>
</li>
<li><strong>Read echoed line from server, write to standard output</strong><ul>
<li><code>readline</code> reads the line echoed back from the server and <code>fputs</code> writes it to standard output.</li>
</ul>
</li>
<li><strong>Return to main</strong></li>
<li>The loop terminates when <code>fgets</code> returns a null pointer, which occurs when it encounters either an end-of-file (EOF) or an error. Our <code>Fgets</code> wrapper function checks for an error and aborts if one occurs, so <code>Fgets</code> returns a null pointer only when an end-of-file is encountered.</li>
</ul>
<h3 id="normal-startup">Normal Startup</h3>
<p>Although the TCP example is small, it is essential that we understand:</p>
<ul>
<li>How the client and server start and end,</li>
<li>What happens when something goes wrong:<ul>
<li>the client host crashes,</li>
<li>the client process crashes,</li>
<li>network connectivity is lost</li>
</ul>
</li>
</ul>
<p>Only by understanding these boundary conditions, and their interaction with the TCP/IP protocols, can we write robust clients and servers that can handle these conditions.</p>
<h4 id="start-the-server-in-the-background">Start the server in the background</h4>
<p>First, we start the server in the background:</p>
<div class="codehilite"><pre>linux % tcpserv01 &amp;
[1] 17870
</pre></div>


<p>When the server starts, it calls <code>socket</code>, <code>bind</code>, <code>listen</code>, and <code>accept</code>, blocking in the call to accept.</p>
<h4 id="run-netstat">Run <code>netstat</code></h4>
<p>Before starting the client, we run the <code>netstat</code> program to verify the state of the server's listening socket.</p>
<div class="codehilite"><pre>linux % netstat -a
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address       Foreign Address      State
tcp        0      0 *:9877              *:*                  LISTEN
</pre></div>


<p>This command shows the status of all sockets on the system. We must specify the <code>-a</code> flag to see listening sockets.</p>
<p>In the output, a socket is in the LISTEN state with a wildcard for the local IP address and a local port of 9877. <code>netstat</code> prints an asterisk for an IP address of 0 (<code>INADDR_ANY</code>, the wildcard) or for a port of 0.</p>
<h4 id="start-the-client-on-the-same-host">Start the client on the same host</h4>
<p>We then start the client on the same host, specifying the server's IP address of 127.0.0.1 (the loopback address). We could have also specified the server's normal (nonloopback) IP address.</p>
<div class="codehilite"><pre>linux % tcpcli01 127.0.0.1
</pre></div>


<p>The client calls <code>socket</code>, and <code>connect</code> which causes TCP's three-way handshake. When the three-way handshake completes, <code>connect</code> returns in the client and <code>accept</code> returns in the server. The connection is established. The following steps then take place:</p>
<ol>
<li>The client calls <code>str_cli</code>, which will block in the call to <code>fgets</code>.</li>
<li>When <code>accept</code> returns in the server, it calls <code>fork</code> and the child calls <code>str_echo</code>. This function calls <code>readline</code>, which calls <code>read</code>, which blocks while waiting for a line to be sent from the client.</li>
<li>The server parent, on the other hand, calls <code>accept</code> again, and blocks while waiting for the next client connection.</li>
</ol>
<p>Notes from the previous three steps:</p>
<ul>
<li>All three processes are asleep (blocked): client, server parent, and server child.</li>
<li>We purposely list the client step first, and then the server steps when the three-way handshake completes. This is because <code>accept</code> returns one-half of the RTT after <code>connect</code> returns (see <a href="../figure_2.5.png">Figure 2.5</a>):<ul>
<li>On the client side, <code>connect</code> returns when the second segment of the handshake is received</li>
<li>On the server side, <code>accept</code> does not return until the third segment of the handshake is received</li>
</ul>
</li>
</ul>
<h4 id="run-netstat-after-connection-completes">Run <code>netstat</code> after connection completes</h4>
<p>Since we are running the client and server on the same host, <code>netstat</code> now shows two additional lines of output, corresponding to the TCP connection:</p>
<div class="codehilite"><pre>linux % netstat -a
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address          State
tcp        0      0 local host:9877         localhost:42758          ESTABLISHED
tcp        0      0 local host:42758        localhost:9877           ESTABLISHED
tcp        0      0 *:9877                  *:*                      LISTEN
</pre></div>


<ul>
<li>The first ESTABLISHED line corresponds to the server child's socket, since the local port is 9877.</li>
<li>The second ESTABLISHED lines is the client's socket, since the local port is 42758</li>
</ul>
<p>If we were running the client and server on different hosts, the client host would display only the client's socket, and the server host would display only the two server sockets.</p>
<h4 id="run-ps-to-check-process-status-and-relationship">Run <code>ps</code> to check process status and relationship</h4>
<div class="codehilite"><pre>linux % ps -t pts/6 -o pid,ppid,tty,stat,args,wchan
  PID  PPID TT       STAT COMMAND          WCHAN
22038 22036 pts/6    S    -bash            wait4
17870 22038 pts/6    S    ./tcpserv01      wait_for_connect
19315 17870 pts/6    S    ./tcpserv01      tcp_data_wait
19314 22038 pts/6    S    ./tcpcli01 127.0 read_chan
</pre></div>


<p>Very specific arguments to <code>ps</code> are used:</p>
<ul>
<li>The TT column (<code>pts/6</code>): client and server are run from the same window, pseudo-terminal number 6.</li>
<li>The PID and PPID columns show the parent and child relationships.<ul>
<li>The first <code>tcpserv01</code> line is the parent and the second tcpserv01 line is the child since the PPID of the child is the parent's PID.</li>
<li>The PPID of the parent is the shell (bash).</li>
</ul>
</li>
<li>The STAT column for all three of our network processes is "S", meaning the process is sleeping (waiting for something).</li>
<li>The WCHAN column specifies the condition when a process is asleep.<ul>
<li>Linux prints <code>wait_for_connect</code> when a process is blocked in either <code>accept</code> or <code>connect</code>, <code>tcp_data_wait</code> when a process is blocked on socket input or output, or <code>read_chan</code> when a process is blocked on terminal I/O.</li>
<li>In <a href="http://man7.org/linux/man-pages/man1/ps.1.html"><code>ps(1)</code></a>, WCHAN column indicates the name of the kernel function in which the process is sleeping, a "-" if the process is running, or a "*" if the process is multi-threaded and ps is not displaying threads.</li>
</ul>
</li>
</ul>
<h3 id="normal-termination">Normal Termination</h3>
<p>At this point, the connection is established and whatever we type to the client is echoed back.</p>
<div class="codehilite"><pre><span class="go">linux % tcpcli01 127.0.0.1   # we showed this line earlier</span>
<span class="go">hello, world                 # we now type this</span>
<span class="go">hello, world                 # and the line is echoed</span>
<span class="go">good bye</span>
<span class="go">good bye</span>
<span class="go">^D                           # Control-D is our terminal EOF character</span>
</pre></div>


<p>If we immediately execute netstat, we have:</p>
<div class="codehilite"><pre><span class="go">linux % netstat -a | grep 9877</span>
<span class="go">tcp        0      0 *:9877               *:*               LISTEN</span>
<span class="go">tcp        0      0 localhost:42758      localhost:9877    TIME_WAIT</span>
</pre></div>


<p>This time we pipe the output of netstat into <code>grep</code>, printing only the lines with our server's well-known port:</p>
<ul>
<li>The client's side of the connection (since the local port is 42758) enters the TIME_WAIT state</li>
<li>The listening server is still waiting for another client connection.</li>
</ul>
<p>The following steps are involved in the normal termination of client and server:</p>
<ol>
<li>When we type our EOF character, <code>fgets</code> returns a null pointer and the function <code>str_cli</code> (<a href="#tcp-echo-client-str_cli-function">Section 5.5</a>) returns.</li>
<li><code>str_cli</code> returns to the client <code>main</code> function (<a href="#tcp-echo-client-main-function">Section 5.5</a>), which terminates by calling <code>exit</code>.</li>
<li>Part of process termination is the closing of all open descriptors, so the client socket is closed by the kernel. This sends a FIN to the server, to which the server TCP responds with an ACK. This is the first half of the TCP connection termination sequence. At this point, the server socket is in the CLOSE_WAIT state and the client socket is in the FIN_WAIT_2 state (<a href="../figure_2.4.png">Figure 2.4</a> and <a href="../figure_2.5.png">Figure 2.5</a>)</li>
<li>When the server TCP receives the FIN, the server child is blocked in a call to <code>read</code> (<a href="#tcp-echo-server-str_echo-function">Section 3.8</a>), and <code>read</code> then returns 0. This causes the <code>str_echo</code> function to return to the server child main. [Errata] [p128]</li>
<li>The server child terminates by calling exit. (<a href="#tcp-echo-server-main-function">Section 5.2</a>)</li>
<li>All open descriptors in the server child are closed.<ul>
<li>The closing of the connected socket by the child causes the final two segments of the TCP connection termination to take place: a FIN from the server to the client, and an ACK from the client.</li>
</ul>
</li>
<li>Finally, the <code>SIGCHLD</code> signal is sent to the parent when the server child terminates.<ul>
<li>This occurs in this example, but we do not catch the signal in our code, and the default action of the signal is to be ignored. Thus, the child enters the zombie state. We can verify this with the <code>ps</code> command.</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span class="go">linux % ps -t pts/6 -o pid,ppid,tty,stat,args,wchan</span>
<span class="go">  PID  PPID TT       STAT COMMAND          WCHAN</span>
<span class="go">22038 22036 pts/6    S    -bash            read_chan</span>
<span class="go">17870 22038 pts/6    S    ./tcpserv01      wait_for_connect</span>
<span class="go">19315 17870 pts/6    Z    [tcpserv01 &lt;defu do_exit</span>
</pre></div>


<p>The STAT of the child is now <code>Z</code> (for zombie).</p>
<p>We need to clean up our zombie processes and doing this requires dealing with Unix signals. The next section will give an overview of signal handling.</p>
<h3 id="posix-signal-handling">POSIX Signal Handling</h3>
<p>A <strong>signal</strong> is a notification to a process that an event has occurred. Signals are sometimes called <strong>software interrupts</strong>. Signals usually occur asynchronously, which means that a process doesn't know ahead of time exactly when a signal will occur.</p>
<p>Signals can be sent:</p>
<ul>
<li>By one process to another process (or to itself)</li>
<li>By the kernel to a process.<ul>
<li>For example, whenever a process terminates, the kernel send a <code>SIGCHLD</code> signal to the parent of the terminating process.</li>
</ul>
</li>
</ul>
<p>Every signal has a <strong>disposition</strong>, which is also called the <strong>action</strong> associated with the signal. We set the disposition of a signal by calling the <code>sigaction</code> function and we have three choices for the disposition:</p>
<ol>
<li>
<p><strong>Catching a signal</strong>. We can provide a function called a <strong>signal handler</strong> that is called whenever a specific signal occurs. The two signals <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught. Our function is called with a single integer argument that is the signal number and the function returns nothing. Its function prototype is therefore:</p>
<div class="codehilite"><pre>void handler (int signo);
</pre></div>


<p>For most signals, we can call <code>sigaction</code> and specify the signal handler to catch it. A few signals, <code>SIGIO</code>, <code>SIGPOLL</code>, and <code>SIGURG</code>, all require additional actions on the part of the process to catch the signal.</p>
</li>
<li>
<p><strong>Ignoring a signal</strong>. We can ignore a signal by setting its disposition to <code>SIG_IGN</code>. The two signals SIGKILL and SIGSTOP cannot be ignored.</p>
</li>
<li><strong>Setting the default disposition for a signal</strong>. This can be done by setting its disposition to <code>SIG_DFL</code>. The default is normally to terminate a process on receipt of a signal, with certain signals also generating a core image of the process in its current working directory. There are a few signals whose default disposition is to be ignored: <code>SIGCHLD</code> and <code>SIGURG</code> (sent on the arrival of out-of-band data) are two that we will encounter in this text.</li>
</ol>
<h3 id="signal-function"><code>signal</code> Function</h3>
<p>The POSIX way to establish the disposition of a signal is to call the <code>sigaction</code> function, which is complicated in that one argument to the function is a structure (<code>struct sigaction</code>) that we must allocate and fill in.</p>
<p>An easier way to set the disposition of a signal is to call the <code>signal</code> function. The first argument is the signal name and the second argument is either a pointer to a function or one of the constants <code>SIG_IGN</code> or <code>SIG_DFL</code>.</p>
<p>However, <code>signal</code> is an historical function that predates POSIX. Different implementations provide different signal semantics when it is called, providing backward compatibility, whereas POSIX explicitly spells out the semantics when <code>sigaction</code> is called.</p>
<p>The solution is to define our own function named <code>signal</code> that just calls the POSIX <code>sigaction</code> function. This provides a simple interface with the desired POSIX semantics. We include this function in our own library, along with our <code>err</code>_XXX functions and our wrapper functions. [p130]</p>
<ul>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/signal.c">lib/signal.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include    &quot;unp.h&quot;</span>

<span class="n">Sigfunc</span> <span class="o">*</span>
<span class="nf">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">act</span><span class="p">,</span> <span class="n">oact</span><span class="p">;</span>

    <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGALRM</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef  SA_INTERRUPT</span>
        <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_INTERRUPT</span><span class="p">;</span>   <span class="cm">/* SunOS 4.x */</span>
<span class="cp">#endif</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef  SA_RESTART</span>
        <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span>     <span class="cm">/* SVR4, 44BSD */</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">SIG_ERR</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">oact</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* end signal */</span>

<span class="n">Sigfunc</span> <span class="o">*</span>
<span class="nf">Signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>    <span class="cm">/* for our signal() function */</span>
<span class="p">{</span>
    <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">sigfunc</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sigfunc</span> <span class="o">=</span> <span class="n">signal</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal error&quot;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">sigfunc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h4 id="simplify-function-prototype-using-typedef">Simplify function prototype using <code>typedef</code></h4>
<p>The normal function prototype for <code>signal</code> is complicated by the level of nested parentheses.</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>


<p>To simplify this, we define the <code>Sigfunc</code> type in our <a href="https://github.com/shichao-an/unpv13e/blob/master/lib/unp.h#L243">unp.h</a> header as</p>
<div class="codehilite"><pre><span class="k">typedef</span>    <span class="kt">void</span>    <span class="nf">Sigfunc</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>


<p>stating that signal handlers are functions with an integer argument and the function returns nothing (<code>void</code>). The function prototype then becomes</p>
<div class="codehilite"><pre><span class="n">Sigfunc</span> <span class="o">*</span><span class="nf">signal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>
</pre></div>


<p>A pointer to a signal handling function is the second argument to the function, as well as the return value from the function.</p>
<h4 id="set-handler">Set handler</h4>
<p>The <code>sa_handler</code> member of the <code>sigaction</code> structure is set to the <em>func</em> argument.</p>
<h4 id="set-signal-mask-for-handler">Set signal mask for handler</h4>
<p>POSIX allows us to specify a set of signals that will be blocked when our signal handler is called. Any signal that is blocked cannot be delivered to a process. We set the <code>sa_mask</code> member to the empty set, which means that no additional signals will be blocked while our signal handler is running. <u>POSIX guarantees that the signal being caught is always blocked while its handler is executing.</u></p>
<h4 id="set-sa_restart-flag">Set <code>SA_RESTART</code> flag</h4>
<p><code>SA_RESTART</code> is an optional flag. When the flag is set, a system call interrupted by this signal will be automatically restarted by the kernel.</p>
<p>If the signal being caught is not <code>SIGALRM</code>, we specify the <code>SA_RESTART</code> flag, if defined. This is because the purpose of generating the <code>SIGALRM</code> signal is normally to place a timeout on an I/O operation, in which case, we want the blocked system call to be interrupted by the signal. [p131]</p>
<h4 id="call-sigaction">Call <code>sigaction</code></h4>
<p>We call <code>sigaction</code> and then <u>return the old action for the signal as the return value of the signal function.</u></p>
<p>Throughout this text, we will use the <code>signal</code> function from the above definition.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>